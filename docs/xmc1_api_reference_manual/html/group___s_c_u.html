<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XMC Peripheral Library for XMC1000 Family: System Control Unit(SCU)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC1000 Family</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___s_c_u.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">System Control Unit(SCU)</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___s_c_u___s_u_p_p_l_y_m_o_n_i_t_o_r__t.html">XMC_SCU_SUPPLYMONITOR_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gafb46d68d66d9b23bc878c7e06696c72a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gafb46d68d66d9b23bc878c7e06696c72a">XMC_BMI_ADDR</a>&#160;&#160;&#160;(0x10000e00U)</td></tr>
<tr class="separator:gafb46d68d66d9b23bc878c7e06696c72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eda1a0078fb1dc13593680dcc4c1886"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga8eda1a0078fb1dc13593680dcc4c1886">XMC_SCU_BMI_CANCLK_DCO1</a>&#160;&#160;&#160;(0U &lt;&lt; 11)</td></tr>
<tr class="separator:ga8eda1a0078fb1dc13593680dcc4c1886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb50fbefee333f0aa9bb1a5d510d6e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga7cb50fbefee333f0aa9bb1a5d510d6e7">XMC_SCU_BMI_CANCLK_OSCHP</a>&#160;&#160;&#160;(1U &lt;&lt; 11)</td></tr>
<tr class="separator:ga7cb50fbefee333f0aa9bb1a5d510d6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02558dc388806845c40f83ba2f8f87cd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga02558dc388806845c40f83ba2f8f87cd">XMC_SCU_BMI_DAPDIS_CHANNEL_0</a>&#160;&#160;&#160;(0U &lt;&lt; 9)</td></tr>
<tr class="separator:ga02558dc388806845c40f83ba2f8f87cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4863740cd6d84afcfc0d01685f6d3afd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4863740cd6d84afcfc0d01685f6d3afd">XMC_SCU_BMI_DAPDIS_CHANNEL_1</a>&#160;&#160;&#160;(1U &lt;&lt; 9)</td></tr>
<tr class="separator:ga4863740cd6d84afcfc0d01685f6d3afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf08ce8782ed3f2501f91d39847e55086"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaf08ce8782ed3f2501f91d39847e55086">XMC_SCU_BMI_DAPTYP_SPD</a>&#160;&#160;&#160;(1U &lt;&lt; 8)</td></tr>
<tr class="separator:gaf08ce8782ed3f2501f91d39847e55086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b090323ebddb3615f33e806b23b1d02"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga8b090323ebddb3615f33e806b23b1d02">XMC_SCU_BMI_DAPTYP_SWD</a>&#160;&#160;&#160;(0U &lt;&lt; 8)</td></tr>
<tr class="separator:ga8b090323ebddb3615f33e806b23b1d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f00e1b1262b3eab4b98353a06673c3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga7f00e1b1262b3eab4b98353a06673c3b">XMC_SCU_BMI_HWCFG_ASC_BSL</a>&#160;&#160;&#160;(0x0040U)</td></tr>
<tr class="separator:ga7f00e1b1262b3eab4b98353a06673c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1b90b10b5672ffe1a3b38f7bbc81b8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga0d1b90b10b5672ffe1a3b38f7bbc81b8">XMC_SCU_BMI_HWCFG_ASC_BSLTO</a>&#160;&#160;&#160;(0x0050U)</td></tr>
<tr class="separator:ga0d1b90b10b5672ffe1a3b38f7bbc81b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccc3853c66324f7c0f2ff6e5c260d38d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaccc3853c66324f7c0f2ff6e5c260d38d">XMC_SCU_BMI_HWCFG_CAN_BSL</a>&#160;&#160;&#160;(0x0000U)</td></tr>
<tr class="separator:gaccc3853c66324f7c0f2ff6e5c260d38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2218430a09e0824a83c23c626ed1668b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga2218430a09e0824a83c23c626ed1668b">XMC_SCU_BMI_HWCFG_CAN_BSLTO</a>&#160;&#160;&#160;(0x0010U)</td></tr>
<tr class="separator:ga2218430a09e0824a83c23c626ed1668b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56ed923f3d9fe179cec0b4c187d0d4c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga56ed923f3d9fe179cec0b4c187d0d4c6">XMC_SCU_BMI_HWCFG_PINDIS</a>&#160;&#160;&#160;(0x0080U)</td></tr>
<tr class="separator:ga56ed923f3d9fe179cec0b4c187d0d4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf41aeb0d9c158e1ae9bd34906ddab27"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gacf41aeb0d9c158e1ae9bd34906ddab27">XMC_SCU_BMI_HWCFG_SBSL</a>&#160;&#160;&#160;(0x007AU)</td></tr>
<tr class="separator:gacf41aeb0d9c158e1ae9bd34906ddab27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ad45fc801302e2ce9583aba0ffe58e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga6ad45fc801302e2ce9583aba0ffe58e0">XMC_SCU_BMI_HWCFG_SBSL_CANOPEN</a>&#160;&#160;&#160;(0x0020U)</td></tr>
<tr class="separator:ga6ad45fc801302e2ce9583aba0ffe58e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88de483723947ca91ce5d5bfd1b89a51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga88de483723947ca91ce5d5bfd1b89a51">XMC_SCU_BMI_HWCFG_SSC_BSL</a>&#160;&#160;&#160;(0x0048U)</td></tr>
<tr class="separator:ga88de483723947ca91ce5d5bfd1b89a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga442aa39ffc3bcc290964bf9c04a558ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga442aa39ffc3bcc290964bf9c04a558ef">XMC_SCU_BMI_HWCFG_SSC_BSLTO</a>&#160;&#160;&#160;(0x0058U)</td></tr>
<tr class="separator:ga442aa39ffc3bcc290964bf9c04a558ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga397fae0a8dfbdfb975010cbb94a8bb42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga397fae0a8dfbdfb975010cbb94a8bb42">XMC_SCU_BMI_HWCFG_UMD</a>&#160;&#160;&#160;(0x0043U)</td></tr>
<tr class="separator:ga397fae0a8dfbdfb975010cbb94a8bb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf42b9eea5286aec14668d952527be70e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaf42b9eea5286aec14668d952527be70e">XMC_SCU_BMI_HWCFG_UMHAR</a>&#160;&#160;&#160;(0x0047U)</td></tr>
<tr class="separator:gaf42b9eea5286aec14668d952527be70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ab345ab24ec81394d45deeb874f3d5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga3ab345ab24ec81394d45deeb874f3d5d">XMC_SCU_BMI_HWCFG_UPM</a>&#160;&#160;&#160;(0x0041U)</td></tr>
<tr class="separator:ga3ab345ab24ec81394d45deeb874f3d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga308e4ef91ac83cd186f90da9b9a23daf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga308e4ef91ac83cd186f90da9b9a23daf">XMC_SCU_INTERRUPT_EVENT_ACMP0</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ACMP0I_Msk</td></tr>
<tr class="separator:ga308e4ef91ac83cd186f90da9b9a23daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f74e12714dc4a7afc11a826de45a46c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4f74e12714dc4a7afc11a826de45a46c">XMC_SCU_INTERRUPT_EVENT_ACMP1</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ACMP1I_Msk</td></tr>
<tr class="separator:ga4f74e12714dc4a7afc11a826de45a46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa904d78eebc226dddec7a80bbadfb09"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gafa904d78eebc226dddec7a80bbadfb09">XMC_SCU_INTERRUPT_EVENT_ACMP2</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ACMP2I_Msk</td></tr>
<tr class="separator:gafa904d78eebc226dddec7a80bbadfb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8cb2163ea141171ed94de73943ba2b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaf8cb2163ea141171ed94de73943ba2b4">XMC_SCU_INTERRUPT_EVENT_ACMP3</a>&#160;&#160;&#160;(((int64_t)SCU_INTERRUPT_SRMSK1_ACMP3I_Msk) &lt;&lt; 32U)</td></tr>
<tr class="separator:gaf8cb2163ea141171ed94de73943ba2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae86b268dee92492bd26b2560ba438f51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gae86b268dee92492bd26b2560ba438f51">XMC_SCU_INTERRUPT_EVENT_DCO1_OUT_SYNC</a>&#160;&#160;&#160;(((int64_t)SCU_INTERRUPT_SRMSK1_DCO1OFSI_Msk) &lt;&lt; 32U)</td></tr>
<tr class="separator:gae86b268dee92492bd26b2560ba438f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga933407ad8d21c4eaabf846df522d3a22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga933407ad8d21c4eaabf846df522d3a22">XMC_SCU_INTERRUPT_EVENT_FLASH_COMPLETED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRCLR_FLCMPLTI_Msk</td></tr>
<tr class="separator:ga933407ad8d21c4eaabf846df522d3a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9069357593905c91623a208725b60311"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga9069357593905c91623a208725b60311">XMC_SCU_INTERRUPT_EVENT_FLASH_ERROR</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_FLECC2I_Msk</td></tr>
<tr class="separator:ga9069357593905c91623a208725b60311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac94bcfa909e35d08abf33f3c7250ba34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gac94bcfa909e35d08abf33f3c7250ba34">XMC_SCU_INTERRUPT_EVENT_LOCI</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_LOCI_Msk</td></tr>
<tr class="separator:gac94bcfa909e35d08abf33f3c7250ba34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad852bbb36333f51cda1a932b6dc40f6b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gad852bbb36333f51cda1a932b6dc40f6b">XMC_SCU_INTERRUPT_EVENT_LOSS_EXT_CLOCK</a>&#160;&#160;&#160;(((int64_t)SCU_INTERRUPT_SRMSK1_LOECI_Msk) &lt;&lt; 32U)</td></tr>
<tr class="separator:gad852bbb36333f51cda1a932b6dc40f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga642c29068f2e6bdd74e887be8546e7a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga642c29068f2e6bdd74e887be8546e7a3">XMC_SCU_INTERRUPT_EVENT_ORC0</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ORC0I_Msk</td></tr>
<tr class="separator:ga642c29068f2e6bdd74e887be8546e7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec2d8151a9de33b25883afb34fdd301a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaec2d8151a9de33b25883afb34fdd301a">XMC_SCU_INTERRUPT_EVENT_ORC1</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ORC1I_Msk</td></tr>
<tr class="separator:gaec2d8151a9de33b25883afb34fdd301a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd248e69d02615043dd0c0d1621f234e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gacd248e69d02615043dd0c0d1621f234e">XMC_SCU_INTERRUPT_EVENT_ORC2</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ORC2I_Msk</td></tr>
<tr class="separator:gacd248e69d02615043dd0c0d1621f234e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca42ac1f2af14eeb54dcede45105957f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaca42ac1f2af14eeb54dcede45105957f">XMC_SCU_INTERRUPT_EVENT_ORC3</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ORC3I_Msk</td></tr>
<tr class="separator:gaca42ac1f2af14eeb54dcede45105957f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8a5050ecb73f339481656e2ae74d2f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab8a5050ecb73f339481656e2ae74d2f4">XMC_SCU_INTERRUPT_EVENT_ORC4</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ORC4I_Msk</td></tr>
<tr class="separator:gab8a5050ecb73f339481656e2ae74d2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b28472219d9903bc4eab24c3909481f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga1b28472219d9903bc4eab24c3909481f">XMC_SCU_INTERRUPT_EVENT_ORC5</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ORC5I_Msk</td></tr>
<tr class="separator:ga1b28472219d9903bc4eab24c3909481f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d53254ae3d670df28ddba679a46b008"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga5d53254ae3d670df28ddba679a46b008">XMC_SCU_INTERRUPT_EVENT_ORC6</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ORC6I_Msk</td></tr>
<tr class="separator:ga5d53254ae3d670df28ddba679a46b008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad73b4f7e40c5a5fa6b14ed3122870739"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gad73b4f7e40c5a5fa6b14ed3122870739">XMC_SCU_INTERRUPT_EVENT_ORC7</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ORC7I_Msk</td></tr>
<tr class="separator:gad73b4f7e40c5a5fa6b14ed3122870739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga866288d67356b65d98698b1a56fbe223"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga866288d67356b65d98698b1a56fbe223">XMC_SCU_INTERRUPT_EVENT_PEMCAN</a>&#160;&#160;&#160;(((int64_t)SCU_INTERRUPT_SRMSK1_PEMCI_Msk) &lt;&lt; 32U)</td></tr>
<tr class="separator:ga866288d67356b65d98698b1a56fbe223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c39fdf288796b8a9a5ac8d026b8fca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga49c39fdf288796b8a9a5ac8d026b8fca">XMC_SCU_INTERRUPT_EVENT_PESRAM</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_PESRAMI_Msk</td></tr>
<tr class="separator:ga49c39fdf288796b8a9a5ac8d026b8fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ed3fc3428042a020278b68b29fcef3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga76ed3fc3428042a020278b68b29fcef3">XMC_SCU_INTERRUPT_EVENT_PEUSIC0</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_PEU0I_Msk</td></tr>
<tr class="separator:ga76ed3fc3428042a020278b68b29fcef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06cec44b1ef45bd7456fa076cfc7fa4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga06cec44b1ef45bd7456fa076cfc7fa4f">XMC_SCU_INTERRUPT_EVENT_PEUSIC1</a>&#160;&#160;&#160;(((int64_t)SCU_INTERRUPT_SRMSK1_PEU1I_Msk) &lt;&lt; 32U)</td></tr>
<tr class="separator:ga06cec44b1ef45bd7456fa076cfc7fa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2de9ba5dfa78e350e552cc36529ad22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab2de9ba5dfa78e350e552cc36529ad22">XMC_SCU_INTERRUPT_EVENT_RTC_ALARM</a>&#160;&#160;&#160;SCU_INTERRUPT_SRCLR_AI_Msk</td></tr>
<tr class="separator:gab2de9ba5dfa78e350e552cc36529ad22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b86e6490dd0310069274f042ef47625"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga2b86e6490dd0310069274f042ef47625">XMC_SCU_INTERRUPT_EVENT_RTC_PERIODIC</a>&#160;&#160;&#160;SCU_INTERRUPT_SRCLR_PI_Msk</td></tr>
<tr class="separator:ga2b86e6490dd0310069274f042ef47625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33dc60f1ff3285386633b53623dca92b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga33dc60f1ff3285386633b53623dca92b">XMC_SCU_INTERRUPT_EVENT_RTCATIM0_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_RTC_ATIM0_Msk</td></tr>
<tr class="separator:ga33dc60f1ff3285386633b53623dca92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a78d87581dbbf3db6f3f23ee4db98e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga19a78d87581dbbf3db6f3f23ee4db98e">XMC_SCU_INTERRUPT_EVENT_RTCATIM1_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_RTC_ATIM1_Msk</td></tr>
<tr class="separator:ga19a78d87581dbbf3db6f3f23ee4db98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07039df071591f92674bdd82fc735030"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga07039df071591f92674bdd82fc735030">XMC_SCU_INTERRUPT_EVENT_RTCCTR_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_RTC_CTR_Msk</td></tr>
<tr class="separator:ga07039df071591f92674bdd82fc735030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34acc61e5b01e7f6b4ea1d7a9a9195c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga34acc61e5b01e7f6b4ea1d7a9a9195c9">XMC_SCU_INTERRUPT_EVENT_RTCTIM0_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_RTC_TIM0_Msk</td></tr>
<tr class="separator:ga34acc61e5b01e7f6b4ea1d7a9a9195c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcaa73f61c18ec8237e076da6c3bc0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga7fcaa73f61c18ec8237e076da6c3bc0e">XMC_SCU_INTERRUPT_EVENT_RTCTIM1_UPDATED</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_RTC_TIM1_Msk</td></tr>
<tr class="separator:ga7fcaa73f61c18ec8237e076da6c3bc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8ff14f167b6080d5eb8c0ea9b417502"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gac8ff14f167b6080d5eb8c0ea9b417502">XMC_SCU_INTERRUPT_EVENT_STDBYCLKFAIL</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_SBYCLKFI_Msk</td></tr>
<tr class="separator:gac8ff14f167b6080d5eb8c0ea9b417502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed038de303f619ac3bfd3aa6371c4bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gabed038de303f619ac3bfd3aa6371c4bd">XMC_SCU_INTERRUPT_EVENT_TSE_DONE</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_TSE_DONE_Msk</td></tr>
<tr class="separator:gabed038de303f619ac3bfd3aa6371c4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef196ed92cf8f7cee093c9307dc047c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaef196ed92cf8f7cee093c9307dc047c6">XMC_SCU_INTERRUPT_EVENT_TSE_HIGH</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_TSE_HIGH_Msk</td></tr>
<tr class="separator:gaef196ed92cf8f7cee093c9307dc047c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0334f0b6343f5e9843663247c7a03292"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga0334f0b6343f5e9843663247c7a03292">XMC_SCU_INTERRUPT_EVENT_TSE_LOW</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_TSE_LOW_Msk</td></tr>
<tr class="separator:ga0334f0b6343f5e9843663247c7a03292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1ea44665421053f203a6c2b8d65989"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga0d1ea44665421053f203a6c2b8d65989">XMC_SCU_INTERRUPT_EVENT_VCLIP</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_VCLIPI_Msk</td></tr>
<tr class="separator:ga0d1ea44665421053f203a6c2b8d65989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga492c0bffe4cfdf7320ea164ee8789c7c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga492c0bffe4cfdf7320ea164ee8789c7c">XMC_SCU_INTERRUPT_EVENT_VDDPI</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_VDDPI_Msk</td></tr>
<tr class="separator:ga492c0bffe4cfdf7320ea164ee8789c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e4ab0550fde6e69b1e3612182190875"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga8e4ab0550fde6e69b1e3612182190875">XMC_SCU_INTERRUPT_EVENT_VDROP</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_VDROPI_Msk</td></tr>
<tr class="separator:ga8e4ab0550fde6e69b1e3612182190875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61bedea1698b39bbd1fa3d2cd79a9f33"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga61bedea1698b39bbd1fa3d2cd79a9f33">XMC_SCU_INTERRUPT_EVENT_WDT_WARN</a>&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_PRWARN_Msk</td></tr>
<tr class="separator:ga61bedea1698b39bbd1fa3d2cd79a9f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4b50170c441fb21833c07a27b814a581"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4b50170c441fb21833c07a27b814a581">XMC_SCU_INTERRUPT_EVENT_HANDLER_t</a>) (void)</td></tr>
<tr class="separator:ga4b50170c441fb21833c07a27b814a581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18e68742408210603bed8d0806ce1573"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a></td></tr>
<tr class="separator:ga18e68742408210603bed8d0806ce1573"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga51850699f03c906a5fefcc4f04c6b2c1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga51850699f03c906a5fefcc4f04c6b2c1">XMC_SCU_CCU_TRIGGER_t</a> </td></tr>
<tr class="separator:ga51850699f03c906a5fefcc4f04c6b2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga353883c8a243d54487bb5cc8edc20a32"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga353883c8a243d54487bb5cc8edc20a32">XMC_SCU_CLOCK_ADCCLKSRC_t</a> </td></tr>
<tr class="separator:ga353883c8a243d54487bb5cc8edc20a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa23b0a26e39703fa5dd32dc275fb4f12"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaa23b0a26e39703fa5dd32dc275fb4f12">XMC_SCU_CLOCK_DCLKSRC_t</a> </td></tr>
<tr class="separator:gaa23b0a26e39703fa5dd32dc275fb4f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48301d5a516ffd248e062d8f98bb8148"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga48301d5a516ffd248e062d8f98bb8148">XMC_SCU_CLOCK_OSCHP_MODE_t</a> </td></tr>
<tr class="separator:ga48301d5a516ffd248e062d8f98bb8148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5bf98e9ea7d145180ad029ea3560d8d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gad5bf98e9ea7d145180ad029ea3560d8d">XMC_SCU_CLOCK_OSCLP_MODE_t</a> </td></tr>
<tr class="separator:gad5bf98e9ea7d145180ad029ea3560d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ef17eaabe7b13c5c159ba6b24c6a2c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gad4ef17eaabe7b13c5c159ba6b24c6a2c">XMC_SCU_CLOCK_PCLKSRC_t</a> </td></tr>
<tr class="separator:gad4ef17eaabe7b13c5c159ba6b24c6a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cf5c338f64adfc26ef8c49e826cd752"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga6cf5c338f64adfc26ef8c49e826cd752">XMC_SCU_CLOCK_RTCCLKSRC_t</a> </td></tr>
<tr class="separator:ga6cf5c338f64adfc26ef8c49e826cd752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26cbc15f43439603ed5976e7be9b6212"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga26cbc15f43439603ed5976e7be9b6212">XMC_SCU_CLOCK_SYNC_CLKSRC_t</a> </td></tr>
<tr class="separator:ga26cbc15f43439603ed5976e7be9b6212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad54a1c90f3b35f4c49d62ac204678487"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gad54a1c90f3b35f4c49d62ac204678487">XMC_SCU_IRQCTRL_t</a> </td></tr>
<tr class="separator:gad54a1c90f3b35f4c49d62ac204678487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29713150fdafc3c88f3c73f621410239"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> </td></tr>
<tr class="separator:ga29713150fdafc3c88f3c73f621410239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae067899a6cfa605f5ebfef2c1f8d393"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaae067899a6cfa605f5ebfef2c1f8d393">XMC_SCU_POWER_MONITOR_DELAY_t</a> </td></tr>
<tr class="separator:gaae067899a6cfa605f5ebfef2c1f8d393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga985038b59c5bc1d8341db06c6c7cbfdc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga985038b59c5bc1d8341db06c6c7cbfdc">XMC_SCU_POWER_MONITOR_RANGE_t</a> </td></tr>
<tr class="separator:ga985038b59c5bc1d8341db06c6c7cbfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae01c08f5d524dadbc6e0c4128b348dc3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gae01c08f5d524dadbc6e0c4128b348dc3">XMC_SCU_RESET_REASON_t</a> </td></tr>
<tr class="separator:gae01c08f5d524dadbc6e0c4128b348dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff029b1575acc0712d494932d8ca6d60"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a> </td></tr>
<tr class="separator:gaff029b1575acc0712d494932d8ca6d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4988413b7da85ed020b8d1a8243e28aa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4988413b7da85ed020b8d1a8243e28aa">XMC_SCU_SYSTEM_RESET_REQUEST_t</a> </td></tr>
<tr class="separator:ga4988413b7da85ed020b8d1a8243e28aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae175b564557503258d534719100f899d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gae175b564557503258d534719100f899d">XMC_SCU_CalcTemperature</a> (void)</td></tr>
<tr class="separator:gae175b564557503258d534719100f899d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7b20e6cd4212c28515a21ad6305bfa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gae7b20e6cd4212c28515a21ad6305bfa3">XMC_SCU_CLOCK_CalibrateOscillatorOnTemperature</a> (int32_t temperature)</td></tr>
<tr class="separator:gae7b20e6cd4212c28515a21ad6305bfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a3d595fe9b1c99675f569c5e98bbe20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga1a3d595fe9b1c99675f569c5e98bbe20">XMC_SCU_CLOCK_ClearDCO1OscillatorWatchdogStatus</a> (void)</td></tr>
<tr class="separator:ga1a3d595fe9b1c99675f569c5e98bbe20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1593fcaf7e9cfb8a276c564ca69cbe48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga1593fcaf7e9cfb8a276c564ca69cbe48">XMC_SCU_CLOCK_DisableDCO1ExtRefCalibration</a> (void)</td></tr>
<tr class="separator:ga1593fcaf7e9cfb8a276c564ca69cbe48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bc3a0cbd7a1ce7fe4b45e6b975151b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga0bc3a0cbd7a1ce7fe4b45e6b975151b9">XMC_SCU_CLOCK_DisableDCO1OscillatorWatchdog</a> (void)</td></tr>
<tr class="separator:ga0bc3a0cbd7a1ce7fe4b45e6b975151b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d273cfcd218e2e9061efe150f8e88d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga1d273cfcd218e2e9061efe150f8e88d9">XMC_SCU_CLOCK_EnableDCO1ExtRefCalibration</a> (<a class="el" href="group___s_c_u.html#ga26cbc15f43439603ed5976e7be9b6212">XMC_SCU_CLOCK_SYNC_CLKSRC_t</a> sync_clk, uint32_t prescaler, uint32_t syn_preload)</td></tr>
<tr class="separator:ga1d273cfcd218e2e9061efe150f8e88d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadec9aee733bfd18a1f91d19417f6d129"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gadec9aee733bfd18a1f91d19417f6d129">XMC_SCU_CLOCK_EnableDCO1OscillatorWatchdog</a> (void)</td></tr>
<tr class="separator:gadec9aee733bfd18a1f91d19417f6d129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0af70f90b9a1f24d3a0a4764543d833"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock</a> (const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> peripheral)</td></tr>
<tr class="separator:gab0af70f90b9a1f24d3a0a4764543d833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e78410c4d0c9f9b54aa0965d16c3795"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga3e78410c4d0c9f9b54aa0965d16c3795">XMC_SCU_CLOCK_GetCpuClockFrequency</a> (void)</td></tr>
<tr class="separator:ga3e78410c4d0c9f9b54aa0965d16c3795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4269bd27311f46c895b7ca474236d71c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4269bd27311f46c895b7ca474236d71c">XMC_SCU_CLOCK_GetFastPeripheralClockFrequency</a> (void)</td></tr>
<tr class="separator:ga4269bd27311f46c895b7ca474236d71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a1be4f0e96fcda7b2c0feb542af250"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga55a1be4f0e96fcda7b2c0feb542af250">XMC_SCU_CLOCK_GetPeripheralClockFrequency</a> (void)</td></tr>
<tr class="separator:ga55a1be4f0e96fcda7b2c0feb542af250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c337e8a728604e7eb54dff78ae2d9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga08c337e8a728604e7eb54dff78ae2d9d">XMC_SCU_CLOCK_Init</a> (const <a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga08c337e8a728604e7eb54dff78ae2d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52987a0ed17a5ac8644163a1f7b008e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga52987a0ed17a5ac8644163a1f7b008e7">XMC_SCU_CLOCK_IsDCO1ExtRefCalibrationReady</a> (void)</td></tr>
<tr class="separator:ga52987a0ed17a5ac8644163a1f7b008e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga804f98badedf0e0ba4ce09f445687a37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated</a> (const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> peripheral)</td></tr>
<tr class="separator:ga804f98badedf0e0ba4ce09f445687a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66a7775d9fe9ee50a3936bd1abf20733"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga66a7775d9fe9ee50a3936bd1abf20733">XMC_SCU_CLOCK_ScaleMCLKFrequency</a> (uint32_t idiv, uint32_t fdiv)</td></tr>
<tr class="separator:ga66a7775d9fe9ee50a3936bd1abf20733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1565840d44662b5655d67726624540ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga1565840d44662b5655d67726624540ca">XMC_SCU_CLOCK_SetAdcClockSrc</a> (<a class="el" href="group___s_c_u.html#ga353883c8a243d54487bb5cc8edc20a32">XMC_SCU_CLOCK_ADCCLKSRC_t</a> adcclk_src)</td></tr>
<tr class="separator:ga1565840d44662b5655d67726624540ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6103bc92c9cd326903ee4e6b2e1d055d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga6103bc92c9cd326903ee4e6b2e1d055d">XMC_SCU_CLOCK_SetFastPeripheralClockSource</a> (const <a class="el" href="group___s_c_u.html#gad4ef17eaabe7b13c5c159ba6b24c6a2c">XMC_SCU_CLOCK_PCLKSRC_t</a> source)</td></tr>
<tr class="separator:ga6103bc92c9cd326903ee4e6b2e1d055d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafddcd1db57d4ff9eacf15ff37c2ca133"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gafddcd1db57d4ff9eacf15ff37c2ca133">XMC_SCU_CLOCK_SetHighPerformanceOscillatorMode</a> (<a class="el" href="group___s_c_u.html#ga48301d5a516ffd248e062d8f98bb8148">XMC_SCU_CLOCK_OSCHP_MODE_t</a> mode)</td></tr>
<tr class="separator:gafddcd1db57d4ff9eacf15ff37c2ca133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33901ef9d941e0cd074e1a9adcff26ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga33901ef9d941e0cd074e1a9adcff26ed">XMC_SCU_CLOCK_SetLowPerformanceOscillatorMode</a> (<a class="el" href="group___s_c_u.html#gad5bf98e9ea7d145180ad029ea3560d8d">XMC_SCU_CLOCK_OSCLP_MODE_t</a> mode)</td></tr>
<tr class="separator:ga33901ef9d941e0cd074e1a9adcff26ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e80d9644d060fdb10194d63d439e5d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4e80d9644d060fdb10194d63d439e5d6">XMC_SCU_CLOCK_SetMCLKFrequency</a> (uint32_t freq_khz)</td></tr>
<tr class="separator:ga4e80d9644d060fdb10194d63d439e5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702904d10b6e6c6a55db381763fd322f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga702904d10b6e6c6a55db381763fd322f">XMC_SCU_CLOCK_UngatePeripheralClock</a> (const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> peripheral)</td></tr>
<tr class="separator:ga702904d10b6e6c6a55db381763fd322f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga161d3851c3f1c11f90526a283a27b16c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga161d3851c3f1c11f90526a283a27b16c">XMC_SCU_DisablePrefetchUnit</a> (void)</td></tr>
<tr class="separator:ga161d3851c3f1c11f90526a283a27b16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3125df313f406750ec52080e3e6f50ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga3125df313f406750ec52080e3e6f50ba">XMC_SCU_EnablePrefetchUnit</a> (void)</td></tr>
<tr class="separator:ga3125df313f406750ec52080e3e6f50ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b1b16ac491c542ceffa20679c8e9c6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga25b1b16ac491c542ceffa20679c8e9c6">XMC_SCU_GetBMI</a> (void)</td></tr>
<tr class="separator:ga25b1b16ac491c542ceffa20679c8e9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga494b75a841498374cfee9664e6ce9cee"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga494b75a841498374cfee9664e6ce9cee">XMC_SCU_GetMirrorStatus</a> (void)</td></tr>
<tr class="separator:ga494b75a841498374cfee9664e6ce9cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71c4f02eb6036f0d3a13af5e10bf56cc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga71c4f02eb6036f0d3a13af5e10bf56cc">XMC_SCU_GetTemperature</a> (void)</td></tr>
<tr class="separator:ga71c4f02eb6036f0d3a13af5e10bf56cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0ad9c467d9549542d0f0275bae6314"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga5a0ad9c467d9549542d0f0275bae6314">XMC_SCU_HighTemperature</a> (void)</td></tr>
<tr class="separator:ga5a0ad9c467d9549542d0f0275bae6314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd2e577339ff5af48261d18e0e41dc50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gabd2e577339ff5af48261d18e0e41dc50">XMC_SCU_INTERRUPT_ClearEventStatus</a> (const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> event)</td></tr>
<tr class="separator:gabd2e577339ff5af48261d18e0e41dc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa814678729d6b7f41c558e768ba8ecd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaa814678729d6b7f41c558e768ba8ecd4">XMC_SCU_INTERRUPT_DisableEvent</a> (const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> event)</td></tr>
<tr class="separator:gaa814678729d6b7f41c558e768ba8ecd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4cfb9545d1e561e1f24aeaa69af821c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab4cfb9545d1e561e1f24aeaa69af821c">XMC_SCU_INTERRUPT_EnableEvent</a> (const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> event)</td></tr>
<tr class="separator:gab4cfb9545d1e561e1f24aeaa69af821c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae03c6bcc3ccade266b46d84f7715e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler</a> (const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> event, const <a class="el" href="group___s_c_u.html#ga4b50170c441fb21833c07a27b814a581">XMC_SCU_INTERRUPT_EVENT_HANDLER_t</a> handler)</td></tr>
<tr class="separator:ga4ae03c6bcc3ccade266b46d84f7715e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa55b2098ce803174e7dfd680d0c30728"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaa55b2098ce803174e7dfd680d0c30728">XMC_SCU_INTERRUPT_TriggerEvent</a> (const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> event)</td></tr>
<tr class="separator:gaa55b2098ce803174e7dfd680d0c30728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae23dfad3e5e11c78791e5d5a777c44a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gae23dfad3e5e11c78791e5d5a777c44a8">XMC_SCU_INTERUPT_GetEventStatus</a> (void)</td></tr>
<tr class="separator:gae23dfad3e5e11c78791e5d5a777c44a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ba1ce317ce89edfea107893fbd8a0be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga9ba1ce317ce89edfea107893fbd8a0be">XMC_SCU_IRQHandler</a> (uint32_t sr_num)</td></tr>
<tr class="separator:ga9ba1ce317ce89edfea107893fbd8a0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga370ea6fa8641ab74386314bbaa6ffb44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga370ea6fa8641ab74386314bbaa6ffb44">XMC_SCU_IsTempMeasurementDone</a> (void)</td></tr>
<tr class="separator:ga370ea6fa8641ab74386314bbaa6ffb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9ba5dce219ea8390f4aa9f7bc46aafe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gad9ba5dce219ea8390f4aa9f7bc46aafe">XMC_SCU_LockProtectedBits</a> (void)</td></tr>
<tr class="separator:gad9ba5dce219ea8390f4aa9f7bc46aafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8573534003ebf11fbaa49e331238fb86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga8573534003ebf11fbaa49e331238fb86">XMC_SCU_LowTemperature</a> (void)</td></tr>
<tr class="separator:ga8573534003ebf11fbaa49e331238fb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4105a1ad04e87b7ca5ec0c88242ed991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4105a1ad04e87b7ca5ec0c88242ed991">XMC_SCU_POWER_DisableMonitor</a> (void)</td></tr>
<tr class="separator:ga4105a1ad04e87b7ca5ec0c88242ed991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff55cce9dfcad7e04e6de5f3d352978"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gabff55cce9dfcad7e04e6de5f3d352978">XMC_SCU_POWER_EnableMonitor</a> (<a class="el" href="group___s_c_u.html#ga985038b59c5bc1d8341db06c6c7cbfdc">XMC_SCU_POWER_MONITOR_RANGE_t</a> range, <a class="el" href="group___s_c_u.html#gaae067899a6cfa605f5ebfef2c1f8d393">XMC_SCU_POWER_MONITOR_DELAY_t</a> delay)</td></tr>
<tr class="separator:gabff55cce9dfcad7e04e6de5f3d352978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c6ab2add788e4bd31eb563e0f8f8b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga77c6ab2add788e4bd31eb563e0f8f8b1">XMC_SCU_RESET_AssertMasterReset</a> (void)</td></tr>
<tr class="separator:ga77c6ab2add788e4bd31eb563e0f8f8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf9396e8b46be98f73999575d13bf6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4bf9396e8b46be98f73999575d13bf6d">XMC_SCU_RESET_ClearDeviceResetReason</a> (void)</td></tr>
<tr class="separator:ga4bf9396e8b46be98f73999575d13bf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4dbbfd3a9346cc7eb84bda46d084607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaa4dbbfd3a9346cc7eb84bda46d084607">XMC_SCU_RESET_EnableResetRequest</a> (uint32_t request)</td></tr>
<tr class="separator:gaa4dbbfd3a9346cc7eb84bda46d084607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f779c81bdc29b44c644017a52aff300"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga3f779c81bdc29b44c644017a52aff300">XMC_SCU_RESET_GetDeviceResetReason</a> (void)</td></tr>
<tr class="separator:ga3f779c81bdc29b44c644017a52aff300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5e684d3534fefaad8787c241f54c310"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaf5e684d3534fefaad8787c241f54c310">XMC_SCU_SetBMI</a> (uint32_t flags, uint8_t timeout)</td></tr>
<tr class="separator:gaf5e684d3534fefaad8787c241f54c310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac10ca2cd72477476ffe38a4818bcae4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gac10ca2cd72477476ffe38a4818bcae4b">XMC_SCU_SetCcuTriggerHigh</a> (const uint32_t trigger)</td></tr>
<tr class="separator:gac10ca2cd72477476ffe38a4818bcae4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53300d587bbd03bc34c5a4396f5a34b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga53300d587bbd03bc34c5a4396f5a34b9">XMC_SCU_SetCcuTriggerLow</a> (const uint32_t trigger)</td></tr>
<tr class="separator:ga53300d587bbd03bc34c5a4396f5a34b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6804b5ee7f0e08ee13d2863f1a35bdcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga6804b5ee7f0e08ee13d2863f1a35bdcf">XMC_SCU_SetInterruptControl</a> (uint8_t irq_number, <a class="el" href="group___s_c_u.html#gad54a1c90f3b35f4c49d62ac204678487">XMC_SCU_IRQCTRL_t</a> source)</td></tr>
<tr class="separator:ga6804b5ee7f0e08ee13d2863f1a35bdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f600fa31f024ec9d8e0c17fc767772f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga0f600fa31f024ec9d8e0c17fc767772f">XMC_SCU_SetRawTempLimits</a> (const uint32_t lower_temp, const uint32_t upper_temp)</td></tr>
<tr class="separator:ga0f600fa31f024ec9d8e0c17fc767772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacda844c46f28753e5698c9edf1da89c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gacda844c46f28753e5698c9edf1da89c6">XMC_SCU_SetTempHighLimit</a> (uint32_t limit)</td></tr>
<tr class="separator:gacda844c46f28753e5698c9edf1da89c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9075804b25596f546110b908fbcb7957"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga9075804b25596f546110b908fbcb7957">XMC_SCU_SetTempLowLimit</a> (uint32_t limit)</td></tr>
<tr class="separator:ga9075804b25596f546110b908fbcb7957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b00187ccda526f06802152ecf199fa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga3b00187ccda526f06802152ecf199fa4">XMC_SCU_StartTempMeasurement</a> (void)</td></tr>
<tr class="separator:ga3b00187ccda526f06802152ecf199fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5851b97d5f0830ba58eecc516a488db0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga5851b97d5f0830ba58eecc516a488db0">XMC_SCU_StopTempMeasurement</a> (void)</td></tr>
<tr class="separator:ga5851b97d5f0830ba58eecc516a488db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab79580e5b6decc4f6ecce14be9efe17d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab79580e5b6decc4f6ecce14be9efe17d">XMC_SCU_SupplyMonitorInit</a> (const <a class="el" href="struct_x_m_c___s_c_u___s_u_p_p_l_y_m_o_n_i_t_o_r__t.html">XMC_SCU_SUPPLYMONITOR_t</a> *obj)</td></tr>
<tr class="separator:gab79580e5b6decc4f6ecce14be9efe17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf60632360634a2f1be0f8af715c03dea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaf60632360634a2f1be0f8af715c03dea">XMC_SCU_UnlockProtectedBits</a> (void)</td></tr>
<tr class="separator:gaf60632360634a2f1be0f8af715c03dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>System control unit is the SoC power, reset and a clock manager with additional responsibility of providing system stability protection and other auxiliary functions.<br />
 SCU provides the following features,</p><ol type="1">
<li>Power control</li>
<li>Reset control</li>
<li>Clock control</li>
<li>Miscellaneous control(boot mode, system interrupts etc.)<br />
<br />
</li>
</ol>
<p>The SCU driver is divided in to clock control logic, reset control logic, system interrupt control logic and miscellaneous control logic.<br />
</p>
<p>Clock driver features:</p><ol type="1">
<li>Allows clock configuration using the structure <a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_CONFIG_t</a> and API <a class="el" href="group___s_c_u.html#ga08c337e8a728604e7eb54dff78ae2d9d">XMC_SCU_CLOCK_Init()</a></li>
<li>Allows selection of peripheral clock frequency, <a class="el" href="group___s_c_u.html#ga6103bc92c9cd326903ee4e6b2e1d055d">XMC_SCU_CLOCK_SetFastPeripheralClockSource()</a></li>
<li>Provides API to get the peripheral clock frequency, <a class="el" href="group___s_c_u.html#ga4269bd27311f46c895b7ca474236d71c">XMC_SCU_CLOCK_GetFastPeripheralClockFrequency()</a></li>
</ol>
<p>Reset driver features:</p><ol type="1">
<li>Allows to trigger device reset <a class="el" href="group___s_c_u.html#ga77c6ab2add788e4bd31eb563e0f8f8b1">XMC_SCU_RESET_AssertMasterReset()</a></li>
<li>Allows to configure multiple sources for reset, <a class="el" href="group___s_c_u.html#gaa4dbbfd3a9346cc7eb84bda46d084607">XMC_SCU_RESET_EnableResetRequest()</a> <br />
</li>
</ol>
<p>Interrupt driver features:</p><ol type="1">
<li>Provides APIs for enabling/ disabling interrupt event generation <a class="el" href="group___s_c_u.html#gab4cfb9545d1e561e1f24aeaa69af821c">XMC_SCU_INTERRUPT_EnableEvent()</a>, <a class="el" href="group___s_c_u.html#gaa814678729d6b7f41c558e768ba8ecd4">XMC_SCU_INTERRUPT_DisableEvent()</a></li>
<li>Provides API for registering callback function for events <a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a><br />
</li>
</ol>
<p>Miscellaneous features:</p><ol type="1">
<li>Allows to trigger multiple capture compare unit(CCU) channels to be started together <a class="el" href="group___s_c_u.html#gac10ca2cd72477476ffe38a4818bcae4b">XMC_SCU_SetCcuTriggerHigh()</a></li>
<li>Enables configuration of die temperature sensor <a class="el" href="group___s_c_u.html#ga3b00187ccda526f06802152ecf199fa4">XMC_SCU_StartTempMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga0f600fa31f024ec9d8e0c17fc767772f">XMC_SCU_SetRawTempLimits()</a></li>
<li>Allows configuring supply monitor unit using the structure <a class="el" href="struct_x_m_c___s_c_u___s_u_p_p_l_y_m_o_n_i_t_o_r__t.html">XMC_SCU_SUPPLYMONITOR_t</a> and API <a class="el" href="group___s_c_u.html#gab79580e5b6decc4f6ecce14be9efe17d">XMC_SCU_SupplyMonitorInit()</a></li>
<li>Allows handling of protected bits <a class="el" href="group___s_c_u.html#gad9ba5dce219ea8390f4aa9f7bc46aafe">XMC_SCU_LockProtectedBits()</a>, <a class="el" href="group___s_c_u.html#gaf60632360634a2f1be0f8af715c03dea">XMC_SCU_UnlockProtectedBits()</a><br />
 </li>
</ol>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gafb46d68d66d9b23bc878c7e06696c72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb46d68d66d9b23bc878c7e06696c72a">&#9670;&nbsp;</a></span>XMC_BMI_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_BMI_ADDR&#160;&#160;&#160;(0x10000e00U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Boot Mode Index (BMI) address holding information about start-up mode and debug configuration of the device. </p>

</div>
</div>
<a id="ga8eda1a0078fb1dc13593680dcc4c1886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8eda1a0078fb1dc13593680dcc4c1886">&#9670;&nbsp;</a></span>XMC_SCU_BMI_CANCLK_DCO1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_CANCLK_DCO1&#160;&#160;&#160;(0U &lt;&lt; 11)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronous CAN clock via internal oscillator (DCO1) with enabled trimming via external reference is selected </p>

</div>
</div>
<a id="ga7cb50fbefee333f0aa9bb1a5d510d6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cb50fbefee333f0aa9bb1a5d510d6e7">&#9670;&nbsp;</a></span>XMC_SCU_BMI_CANCLK_OSCHP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_CANCLK_OSCHP&#160;&#160;&#160;(1U &lt;&lt; 11)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronous CAN clock via external oscillator (OSC_HP) is selected </p>

</div>
</div>
<a id="ga02558dc388806845c40f83ba2f8f87cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02558dc388806845c40f83ba2f8f87cd">&#9670;&nbsp;</a></span>XMC_SCU_BMI_DAPDIS_CHANNEL_0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_DAPDIS_CHANNEL_0&#160;&#160;&#160;(0U &lt;&lt; 9)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SWD/SPD_0 pin is selected </p>

</div>
</div>
<a id="ga4863740cd6d84afcfc0d01685f6d3afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4863740cd6d84afcfc0d01685f6d3afd">&#9670;&nbsp;</a></span>XMC_SCU_BMI_DAPDIS_CHANNEL_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_DAPDIS_CHANNEL_1&#160;&#160;&#160;(1U &lt;&lt; 9)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SWD/SPD_1 pin is selected </p>

</div>
</div>
<a id="gaf08ce8782ed3f2501f91d39847e55086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf08ce8782ed3f2501f91d39847e55086">&#9670;&nbsp;</a></span>XMC_SCU_BMI_DAPTYP_SPD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_DAPTYP_SPD&#160;&#160;&#160;(1U &lt;&lt; 8)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Single pin debug (SPD) interface is selected </p>

</div>
</div>
<a id="ga8b090323ebddb3615f33e806b23b1d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b090323ebddb3615f33e806b23b1d02">&#9670;&nbsp;</a></span>XMC_SCU_BMI_DAPTYP_SWD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_DAPTYP_SWD&#160;&#160;&#160;(0U &lt;&lt; 8)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serial wire debug (SWD) interface is selected </p>

</div>
</div>
<a id="ga7f00e1b1262b3eab4b98353a06673c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f00e1b1262b3eab4b98353a06673c3b">&#9670;&nbsp;</a></span>XMC_SCU_BMI_HWCFG_ASC_BSL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_HWCFG_ASC_BSL&#160;&#160;&#160;(0x0040U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ASC Bootstrap Loader Start-up Mode </p>

</div>
</div>
<a id="ga0d1b90b10b5672ffe1a3b38f7bbc81b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d1b90b10b5672ffe1a3b38f7bbc81b8">&#9670;&nbsp;</a></span>XMC_SCU_BMI_HWCFG_ASC_BSLTO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_HWCFG_ASC_BSLTO&#160;&#160;&#160;(0x0050U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ASC BSL Start-up Mode with time-out </p>

</div>
</div>
<a id="gaccc3853c66324f7c0f2ff6e5c260d38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccc3853c66324f7c0f2ff6e5c260d38d">&#9670;&nbsp;</a></span>XMC_SCU_BMI_HWCFG_CAN_BSL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_HWCFG_CAN_BSL&#160;&#160;&#160;(0x0000U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CAN Bootstrap Loader Start-up Mode </p>

</div>
</div>
<a id="ga2218430a09e0824a83c23c626ed1668b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2218430a09e0824a83c23c626ed1668b">&#9670;&nbsp;</a></span>XMC_SCU_BMI_HWCFG_CAN_BSLTO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_HWCFG_CAN_BSLTO&#160;&#160;&#160;(0x0010U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CAN Bootstrap Loader Start-up Mode with time-out </p>

</div>
</div>
<a id="ga56ed923f3d9fe179cec0b4c187d0d4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56ed923f3d9fe179cec0b4c187d0d4c6">&#9670;&nbsp;</a></span>XMC_SCU_BMI_HWCFG_PINDIS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_HWCFG_PINDIS&#160;&#160;&#160;(0x0080U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Boot Configuration Type Selection, Boot from BMI is selected </p>

</div>
</div>
<a id="gacf41aeb0d9c158e1ae9bd34906ddab27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf41aeb0d9c158e1ae9bd34906ddab27">&#9670;&nbsp;</a></span>XMC_SCU_BMI_HWCFG_SBSL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_HWCFG_SBSL&#160;&#160;&#160;(0x007AU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Secure Bootstrap Loader Start-up Mode over ASC </p>

</div>
</div>
<a id="ga6ad45fc801302e2ce9583aba0ffe58e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ad45fc801302e2ce9583aba0ffe58e0">&#9670;&nbsp;</a></span>XMC_SCU_BMI_HWCFG_SBSL_CANOPEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_HWCFG_SBSL_CANOPEN&#160;&#160;&#160;(0x0020U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Secure Bootstrap Loader Start-up Mode over CANopen </p>

</div>
</div>
<a id="ga88de483723947ca91ce5d5bfd1b89a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88de483723947ca91ce5d5bfd1b89a51">&#9670;&nbsp;</a></span>XMC_SCU_BMI_HWCFG_SSC_BSL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_HWCFG_SSC_BSL&#160;&#160;&#160;(0x0048U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SSC Bootstrap Loader Start-up Mode </p>

</div>
</div>
<a id="ga442aa39ffc3bcc290964bf9c04a558ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga442aa39ffc3bcc290964bf9c04a558ef">&#9670;&nbsp;</a></span>XMC_SCU_BMI_HWCFG_SSC_BSLTO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_HWCFG_SSC_BSLTO&#160;&#160;&#160;(0x0058U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SSC BSL Start-up Mode with time-out </p>

</div>
</div>
<a id="ga397fae0a8dfbdfb975010cbb94a8bb42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga397fae0a8dfbdfb975010cbb94a8bb42">&#9670;&nbsp;</a></span>XMC_SCU_BMI_HWCFG_UMD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_HWCFG_UMD&#160;&#160;&#160;(0x0043U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>User Start-up Mode with debug enabled </p>

</div>
</div>
<a id="gaf42b9eea5286aec14668d952527be70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf42b9eea5286aec14668d952527be70e">&#9670;&nbsp;</a></span>XMC_SCU_BMI_HWCFG_UMHAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_HWCFG_UMHAR&#160;&#160;&#160;(0x0047U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>User Start-up Mode with debug enabled and halt after reset (HAR) </p>

</div>
</div>
<a id="ga3ab345ab24ec81394d45deeb874f3d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ab345ab24ec81394d45deeb874f3d5d">&#9670;&nbsp;</a></span>XMC_SCU_BMI_HWCFG_UPM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_BMI_HWCFG_UPM&#160;&#160;&#160;(0x0041U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>User productive Start-up Mode </p>

</div>
</div>
<a id="ga308e4ef91ac83cd186f90da9b9a23daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga308e4ef91ac83cd186f90da9b9a23daf">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_ACMP0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_ACMP0&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ACMP0I_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analog comparator-0 output event. </p>

</div>
</div>
<a id="ga4f74e12714dc4a7afc11a826de45a46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f74e12714dc4a7afc11a826de45a46c">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_ACMP1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_ACMP1&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ACMP1I_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analog comparator-1 output event. </p>

</div>
</div>
<a id="gafa904d78eebc226dddec7a80bbadfb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa904d78eebc226dddec7a80bbadfb09">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_ACMP2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_ACMP2&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ACMP2I_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analog comparator-2 output event. </p>

</div>
</div>
<a id="gaf8cb2163ea141171ed94de73943ba2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8cb2163ea141171ed94de73943ba2b4">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_ACMP3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_ACMP3&#160;&#160;&#160;(((int64_t)SCU_INTERRUPT_SRMSK1_ACMP3I_Msk) &lt;&lt; 32U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analog comparator-3 output event. </p><dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="gae86b268dee92492bd26b2560ba438f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae86b268dee92492bd26b2560ba438f51">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_DCO1_OUT_SYNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_DCO1_OUT_SYNC&#160;&#160;&#160;(((int64_t)SCU_INTERRUPT_SRMSK1_DCO1OFSI_Msk) &lt;&lt; 32U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DCO1 Out of SYNC Event. </p><dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="ga933407ad8d21c4eaabf846df522d3a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga933407ad8d21c4eaabf846df522d3a22">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_FLASH_COMPLETED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_FLASH_COMPLETED&#160;&#160;&#160;SCU_INTERRUPT_SRCLR_FLCMPLTI_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flash operation completion event. </p>

</div>
</div>
<a id="ga9069357593905c91623a208725b60311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9069357593905c91623a208725b60311">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_FLASH_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_FLASH_ERROR&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_FLECC2I_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flash ECC double bit error event. </p>

</div>
</div>
<a id="gac94bcfa909e35d08abf33f3c7250ba34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac94bcfa909e35d08abf33f3c7250ba34">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_LOCI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_LOCI&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_LOCI_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loss of clock event. </p>

</div>
</div>
<a id="gad852bbb36333f51cda1a932b6dc40f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad852bbb36333f51cda1a932b6dc40f6b">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_LOSS_EXT_CLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_LOSS_EXT_CLOCK&#160;&#160;&#160;(((int64_t)SCU_INTERRUPT_SRMSK1_LOECI_Msk) &lt;&lt; 32U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loss of external OSC_HP clock event. </p><dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="ga642c29068f2e6bdd74e887be8546e7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga642c29068f2e6bdd74e887be8546e7a3">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_ORC0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_ORC0&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ORC0I_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Out of range comparator-0 event. </p>

</div>
</div>
<a id="gaec2d8151a9de33b25883afb34fdd301a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec2d8151a9de33b25883afb34fdd301a">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_ORC1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_ORC1&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ORC1I_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Out of range comparator-1 event. </p>

</div>
</div>
<a id="gacd248e69d02615043dd0c0d1621f234e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd248e69d02615043dd0c0d1621f234e">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_ORC2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_ORC2&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ORC2I_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Out of range comparator-2 event. </p>

</div>
</div>
<a id="gaca42ac1f2af14eeb54dcede45105957f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca42ac1f2af14eeb54dcede45105957f">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_ORC3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_ORC3&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ORC3I_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Out of range comparator-3 event. </p>

</div>
</div>
<a id="gab8a5050ecb73f339481656e2ae74d2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8a5050ecb73f339481656e2ae74d2f4">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_ORC4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_ORC4&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ORC4I_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Out of range comparator-4 event. </p>

</div>
</div>
<a id="ga1b28472219d9903bc4eab24c3909481f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b28472219d9903bc4eab24c3909481f">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_ORC5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_ORC5&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ORC5I_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Out of range comparator-5 event. </p>

</div>
</div>
<a id="ga5d53254ae3d670df28ddba679a46b008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d53254ae3d670df28ddba679a46b008">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_ORC6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_ORC6&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ORC6I_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Out of range comparator-6 event. </p>

</div>
</div>
<a id="gad73b4f7e40c5a5fa6b14ed3122870739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad73b4f7e40c5a5fa6b14ed3122870739">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_ORC7</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_ORC7&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_ORC7I_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Out of range comparator-7 event. </p>

</div>
</div>
<a id="ga866288d67356b65d98698b1a56fbe223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga866288d67356b65d98698b1a56fbe223">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_PEMCAN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_PEMCAN&#160;&#160;&#160;(((int64_t)SCU_INTERRUPT_SRMSK1_PEMCI_Msk) &lt;&lt; 32U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MultiCAN SRAM Parity Error Event. </p>

</div>
</div>
<a id="ga49c39fdf288796b8a9a5ac8d026b8fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49c39fdf288796b8a9a5ac8d026b8fca">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_PESRAM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_PESRAM&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_PESRAMI_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PSRAM Parity error event. </p>

</div>
</div>
<a id="ga76ed3fc3428042a020278b68b29fcef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76ed3fc3428042a020278b68b29fcef3">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_PEUSIC0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_PEUSIC0&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_PEU0I_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC0 Parity error event. </p>

</div>
</div>
<a id="ga06cec44b1ef45bd7456fa076cfc7fa4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06cec44b1ef45bd7456fa076cfc7fa4f">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_PEUSIC1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_PEUSIC1&#160;&#160;&#160;(((int64_t)SCU_INTERRUPT_SRMSK1_PEU1I_Msk) &lt;&lt; 32U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC1 Parity error event. </p>

</div>
</div>
<a id="gab2de9ba5dfa78e350e552cc36529ad22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2de9ba5dfa78e350e552cc36529ad22">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_RTC_ALARM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_RTC_ALARM&#160;&#160;&#160;SCU_INTERRUPT_SRCLR_AI_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTC alarm event. </p>

</div>
</div>
<a id="ga2b86e6490dd0310069274f042ef47625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b86e6490dd0310069274f042ef47625">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_RTC_PERIODIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_RTC_PERIODIC&#160;&#160;&#160;SCU_INTERRUPT_SRCLR_PI_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTC periodic event. </p>

</div>
</div>
<a id="ga33dc60f1ff3285386633b53623dca92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33dc60f1ff3285386633b53623dca92b">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_RTCATIM0_UPDATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_RTCATIM0_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_RTC_ATIM0_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTCATIM0 register update event. </p>

</div>
</div>
<a id="ga19a78d87581dbbf3db6f3f23ee4db98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a78d87581dbbf3db6f3f23ee4db98e">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_RTCATIM1_UPDATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_RTCATIM1_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_RTC_ATIM1_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTCATIM1 register update event. </p>

</div>
</div>
<a id="ga07039df071591f92674bdd82fc735030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07039df071591f92674bdd82fc735030">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_RTCCTR_UPDATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_RTCCTR_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_RTC_CTR_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTCCTR register update event. </p>

</div>
</div>
<a id="ga34acc61e5b01e7f6b4ea1d7a9a9195c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34acc61e5b01e7f6b4ea1d7a9a9195c9">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_RTCTIM0_UPDATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_RTCTIM0_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_RTC_TIM0_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTCTIM0 register update event. </p>

</div>
</div>
<a id="ga7fcaa73f61c18ec8237e076da6c3bc0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fcaa73f61c18ec8237e076da6c3bc0e">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_RTCTIM1_UPDATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_RTCTIM1_UPDATED&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_RTC_TIM1_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RTCTIM1 register update event. </p>

</div>
</div>
<a id="gac8ff14f167b6080d5eb8c0ea9b417502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8ff14f167b6080d5eb8c0ea9b417502">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_STDBYCLKFAIL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_STDBYCLKFAIL&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_SBYCLKFI_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standby clock failure event. </p>

</div>
</div>
<a id="gabed038de303f619ac3bfd3aa6371c4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabed038de303f619ac3bfd3aa6371c4bd">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_TSE_DONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_TSE_DONE&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_TSE_DONE_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Temperature measurement Completion event. </p>

</div>
</div>
<a id="gaef196ed92cf8f7cee093c9307dc047c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef196ed92cf8f7cee093c9307dc047c6">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_TSE_HIGH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_TSE_HIGH&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_TSE_HIGH_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Temperature too high event. </p>

</div>
</div>
<a id="ga0334f0b6343f5e9843663247c7a03292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0334f0b6343f5e9843663247c7a03292">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_TSE_LOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_TSE_LOW&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_TSE_LOW_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Temperature too low event. </p>

</div>
</div>
<a id="ga0d1ea44665421053f203a6c2b8d65989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d1ea44665421053f203a6c2b8d65989">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_VCLIP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_VCLIP&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_VCLIPI_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VCLIP event. </p>

</div>
</div>
<a id="ga492c0bffe4cfdf7320ea164ee8789c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga492c0bffe4cfdf7320ea164ee8789c7c">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_VDDPI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_VDDPI&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_VDDPI_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VDDP pre-warning event. </p>

</div>
</div>
<a id="ga8e4ab0550fde6e69b1e3612182190875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e4ab0550fde6e69b1e3612182190875">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_VDROP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_VDROP&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_VDROPI_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VDROP event. </p>

</div>
</div>
<a id="ga61bedea1698b39bbd1fa3d2cd79a9f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61bedea1698b39bbd1fa3d2cd79a9f33">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_WDT_WARN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_SCU_INTERRUPT_EVENT_WDT_WARN&#160;&#160;&#160;SCU_INTERRUPT_SRMSK_PRWARN_Msk</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>WDT pre-warning event. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga4b50170c441fb21833c07a27b814a581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b50170c441fb21833c07a27b814a581">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_HANDLER_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XMC_SCU_INTERRUPT_EVENT_HANDLER_t) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function pointer type used for registering callback functions on SCU event occurrence. </p>

</div>
</div>
<a id="ga18e68742408210603bed8d0806ce1573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18e68742408210603bed8d0806ce1573">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines list of events that can generate SCU interrupt. These enums can be used to configure events in <em>SRMSK</em> register for assertion of interrupt. All the enum items are tabulated as per bits present in <em>SRMSK</em> register. Use type <em>XMC_SCU_INTERRUPT_EVENT_t</em> for accessing these enum parameters. These enums can also be used for checking the status of events from the <em>SRSTAT</em> register. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga51850699f03c906a5fefcc4f04c6b2c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51850699f03c906a5fefcc4f04c6b2c1">&#9670;&nbsp;</a></span>XMC_SCU_CCU_TRIGGER_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga51850699f03c906a5fefcc4f04c6b2c1">XMC_SCU_CCU_TRIGGER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines options for Capture/Compare unit timer slice trigger that enables synchronous start function available on the <em>SCU</em>, <em>CCUCON</em> register. Use type <em>XMC_SCU_CCU_TRIGGER_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga51850699f03c906a5fefcc4f04c6b2c1ab9e67fe77a9a1219bd0d4594c3f7a0ea"></a>XMC_SCU_CCU_TRIGGER_CCU40&#160;</td><td class="fielddoc"><p>Trigger CCU40 peripheral. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51850699f03c906a5fefcc4f04c6b2c1ae5aa55222489a096c454eb0ce95e1bf2"></a>XMC_SCU_CCU_TRIGGER_CCU80&#160;</td><td class="fielddoc"><p>Trigger CCU80 peripheral. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51850699f03c906a5fefcc4f04c6b2c1aa247a6e6177fb8baf1b9b1c50f7652d1"></a>XMC_SCU_CCU_TRIGGER_CCU41&#160;</td><td class="fielddoc"><p>Trigger CCU40 peripheral. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51850699f03c906a5fefcc4f04c6b2c1a283d83cce4146c37511e1a8a8ac1a54b"></a>XMC_SCU_CCU_TRIGGER_CCU81&#160;</td><td class="fielddoc"><p>Trigger CCU80 peripheral. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga353883c8a243d54487bb5cc8edc20a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga353883c8a243d54487bb5cc8edc20a32">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_ADCCLKSRC_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga353883c8a243d54487bb5cc8edc20a32">XMC_SCU_CLOCK_ADCCLKSRC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC clock source selection </p><dl class="section note"><dt>Note</dt><dd>Only available in XMC1400 series </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga353883c8a243d54487bb5cc8edc20a32ac4326ac9cab781cf12f53f6901879fd2"></a>XMC_SCU_CLOCK_ADCCLKSRC_48MHZ&#160;</td><td class="fielddoc"><p>Internal oscillator DCO1 (48MHz) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga353883c8a243d54487bb5cc8edc20a32a660788de8c6b105e41a76ab8e0aeee8c"></a>XMC_SCU_CLOCK_ADCCLKSRC_32MHZ&#160;</td><td class="fielddoc"><p>Internal oscillator DCO1 (48MHz) divided by 1.5 </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa23b0a26e39703fa5dd32dc275fb4f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa23b0a26e39703fa5dd32dc275fb4f12">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_DCLKSRC_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gaa23b0a26e39703fa5dd32dc275fb4f12">XMC_SCU_CLOCK_DCLKSRC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DCLK clock source selection </p><dl class="section note"><dt>Note</dt><dd>Only available in XMC1400 series </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa23b0a26e39703fa5dd32dc275fb4f12a9a1224f2164635157989f7f15b46d1c9"></a>XMC_SCU_CLOCK_DCLKSRC_DCO1&#160;</td><td class="fielddoc"><p>Internal oscillator DCO1 (48MHz) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa23b0a26e39703fa5dd32dc275fb4f12a818faff3197a02732cce678cc6aaf0e9"></a>XMC_SCU_CLOCK_DCLKSRC_EXT_XTAL&#160;</td><td class="fielddoc"><p>External crystal oscillator </p>
</td></tr>
</table>

</div>
</div>
<a id="ga48301d5a516ffd248e062d8f98bb8148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48301d5a516ffd248e062d8f98bb8148">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_OSCHP_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga48301d5a516ffd248e062d8f98bb8148">XMC_SCU_CLOCK_OSCHP_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OSCHP mode </p><dl class="section note"><dt>Note</dt><dd>Only available in XMC1400 series </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga48301d5a516ffd248e062d8f98bb8148ac342e04de860ad8d166b9fb10e92163d"></a>XMC_SCU_CLOCK_OSCHP_MODE_OSC&#160;</td><td class="fielddoc"><p>Oscillator is enabled and in active power mode with shaper enabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga48301d5a516ffd248e062d8f98bb8148a5973a8a04d3f804c808fd1751f39a9c2"></a>XMC_SCU_CLOCK_OSCHP_MODE_DIRECT&#160;</td><td class="fielddoc"><p>Oscillator in power down mode with shaper enabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga48301d5a516ffd248e062d8f98bb8148a45d0117c4bcf14330b02309938efa07a"></a>XMC_SCU_CLOCK_OSCHP_MODE_DISABLED&#160;</td><td class="fielddoc"><p>Oscillator in power down mode with shaper enabled </p>
</td></tr>
</table>

</div>
</div>
<a id="gad5bf98e9ea7d145180ad029ea3560d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5bf98e9ea7d145180ad029ea3560d8d">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_OSCLP_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gad5bf98e9ea7d145180ad029ea3560d8d">XMC_SCU_CLOCK_OSCLP_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OSCLP mode </p><dl class="section note"><dt>Note</dt><dd>Only available in XMC1400 series </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad5bf98e9ea7d145180ad029ea3560d8dabba44053922460bd51b848758b68652c"></a>XMC_SCU_CLOCK_OSCLP_MODE_OSC&#160;</td><td class="fielddoc"><p>Oscillator is enabled and in active power mode with shaper enabled </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad5bf98e9ea7d145180ad029ea3560d8da2aa0726d469344af68cf72f8ed3b1841"></a>XMC_SCU_CLOCK_OSCLP_MODE_DISABLED&#160;</td><td class="fielddoc"><p>Oscillator in power down mode with shaper enabled </p>
</td></tr>
</table>

</div>
</div>
<a id="gad4ef17eaabe7b13c5c159ba6b24c6a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4ef17eaabe7b13c5c159ba6b24c6a2c">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_PCLKSRC_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gad4ef17eaabe7b13c5c159ba6b24c6a2c">XMC_SCU_CLOCK_PCLKSRC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines possible sources of peripheral clock (PCLK). These enums can be used to configure <em>PCLKSEL</em> bits of <em>CLKCR</em> Clock Control Register. Use type <em>XMC_SCU_CLOCK_PCLKSRC_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad4ef17eaabe7b13c5c159ba6b24c6a2ca68981ef360c0c5bd355918858a72c3f3"></a>XMC_SCU_CLOCK_PCLKSRC_MCLK&#160;</td><td class="fielddoc"><p>MCLK as the source for PCLK. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad4ef17eaabe7b13c5c159ba6b24c6a2cac5e87eeb279a280a096fccee739e1cc1"></a>XMC_SCU_CLOCK_PCLKSRC_DOUBLE_MCLK&#160;</td><td class="fielddoc"><p>Source of PCLK is twice the MCLK. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6cf5c338f64adfc26ef8c49e826cd752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cf5c338f64adfc26ef8c49e826cd752">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_RTCCLKSRC_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga6cf5c338f64adfc26ef8c49e826cd752">XMC_SCU_CLOCK_RTCCLKSRC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines possible sources of RTC clock. These enums can be used to configure <em>RTCCLKSEL</em> bits of <em>CLKCR</em> Clock Control Register. Use type <em>XMC_SCU_CLOCK_RTCCLKSRC_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6cf5c338f64adfc26ef8c49e826cd752a53e45cffbefd82a99a6b3823ac158007"></a>XMC_SCU_CLOCK_RTCCLKSRC_DCO2&#160;</td><td class="fielddoc"><p>RTC clock source is standby clock. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6cf5c338f64adfc26ef8c49e826cd752a73ebf57da51c953f94ac117429da1728"></a>XMC_SCU_CLOCK_RTCCLKSRC_ERU_IOUT0&#160;</td><td class="fielddoc"><p>RTC clock source is external clock from ERU0.IOUT0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6cf5c338f64adfc26ef8c49e826cd752a41b802a680db96bfed5bb865e665101b"></a>XMC_SCU_CLOCK_RTCCLKSRC_ACMP0_OUT&#160;</td><td class="fielddoc"><p>RTC clock source is external clock from ACMP0.OUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6cf5c338f64adfc26ef8c49e826cd752a1c9bca4660e4084fe22e2b5f8025ccf5"></a>XMC_SCU_CLOCK_RTCCLKSRC_ACMP1_OUT&#160;</td><td class="fielddoc"><p>RTC clock source is external clock from ACMP1.OUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6cf5c338f64adfc26ef8c49e826cd752a2fe29d440be9a7d055d919a602ed86c8"></a>XMC_SCU_CLOCK_RTCCLKSRC_ACMP2_OUT&#160;</td><td class="fielddoc"><p>RTC clock source is external clock from ACMP2.OUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6cf5c338f64adfc26ef8c49e826cd752a58dac8adf80251961dae7f44f12e4819"></a>XMC_SCU_CLOCK_RTCCLKSRC_OSCLP&#160;</td><td class="fielddoc"><p>32.768kHz XTAL clock via OSC_LP. </p><dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="ga26cbc15f43439603ed5976e7be9b6212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26cbc15f43439603ed5976e7be9b6212">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_SYNC_CLKSRC_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga26cbc15f43439603ed5976e7be9b6212">XMC_SCU_CLOCK_SYNC_CLKSRC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clock source for synchronization </p><dl class="section note"><dt>Note</dt><dd>Only available in XMC1400 series </dd></dl>

</div>
</div>
<a id="gad54a1c90f3b35f4c49d62ac204678487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad54a1c90f3b35f4c49d62ac204678487">&#9670;&nbsp;</a></span>XMC_SCU_IRQCTRL_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gad54a1c90f3b35f4c49d62ac204678487">XMC_SCU_IRQCTRL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects the service request connected to the interrupt node. </p><div class="image">
<img src="xmc1400_irqmux.png" alt="xmc1400_irqmux.png"/>
</div>
 <dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ab1be359c25b9ee5e1cd77625752f88f6"></a>XMC_SCU_IRQCTRL_SCU_SR0_IRQ0&#160;</td><td class="fielddoc"><p>SCU_SR0 connected to IRQ0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a1744de354138e96d9c18e8db6e3dde0e"></a>XMC_SCU_IRQCTRL_CAN0_SR0_IRQ0&#160;</td><td class="fielddoc"><p>CAN0_SR0 connected to IRQ0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a4e8d1706cedff9e187ab2caa45eb3c24"></a>XMC_SCU_IRQCTRL_CCU40_SR0_IRQ0&#160;</td><td class="fielddoc"><p>CCU40_SR0 connected to IRQ0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a919c57326c65f967a4f068e2e61191b6"></a>XMC_SCU_IRQCTRL_SCU_SR0_OR_CAN0_SR0_IRQ0&#160;</td><td class="fielddoc"><p>SCU_SR0 and CAN_SR0 are both connected to IRQ0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a3503a4df9fd7656de16783863adaf145"></a>XMC_SCU_IRQCTRL_SCU_SR1_IRQ1&#160;</td><td class="fielddoc"><p>SCU_SR1 connected to IRQ1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a575c54815d2e530313280a6d6da4ad8c"></a>XMC_SCU_IRQCTRL_CAN0_SR1_IRQ1&#160;</td><td class="fielddoc"><p>CAN0_SR1 connected to IRQ1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487aaf752f48d20a35f36d6296bdd6ec198d"></a>XMC_SCU_IRQCTRL_CCU80_SR0_IRQ1&#160;</td><td class="fielddoc"><p>CCU80_SR0 connected to IRQ1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a4bd21bd938ac670ad202dbd04d39dfc5"></a>XMC_SCU_IRQCTRL_SCU_SR1_OR_CAN0_SR1_IRQ1&#160;</td><td class="fielddoc"><p>SCU_SR1 and CAN0_SR1 connected to IRQ1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ab623c552b1a92626f5f065e4564ab076"></a>XMC_SCU_IRQCTRL_SCU_SR2_IRQ2&#160;</td><td class="fielddoc"><p>SCU_SR2 connected to IRQ2 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a7055efec30fe6b77780f10729e6ccdd3"></a>XMC_SCU_IRQCTRL_CAN0_SR2_IRQ2&#160;</td><td class="fielddoc"><p>CAN0_SR2 connected to IRQ2 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a4ec7109975079964c5af452061e376ba"></a>XMC_SCU_IRQCTRL_CCU80_SR1_IRQ2&#160;</td><td class="fielddoc"><p>CCU80_SR1 connected to IRQ2 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487af90f457ea27729d6dd66910f4feec1c8"></a>XMC_SCU_IRQCTRL_SCU_SR2_OR_CAN0_SR2_IRQ2&#160;</td><td class="fielddoc"><p>SCU_SR2 and CAN0_SR2 connected to IRQ2 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487aebda6657ba02109dcd9594fb39517350"></a>XMC_SCU_IRQCTRL_ERU0_SR0_IRQ3&#160;</td><td class="fielddoc"><p>ERU0_SR0 connected to IRQ3 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ae7e19b40961c05a1a39f150a3d530ea5"></a>XMC_SCU_IRQCTRL_ERU1_SR0_IRQ3&#160;</td><td class="fielddoc"><p>ERU1_SR0 connected to IRQ3 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487add9f667f5da28b7b0b353b10c57798ff"></a>XMC_SCU_IRQCTRL_CAN0_SR0_IRQ3&#160;</td><td class="fielddoc"><p>CAN0_SR0 connected to IRQ3 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a8f30ea448697223320ed95b114326604"></a>XMC_SCU_IRQCTRL_ERU0_SR0_OR_ERU1_SR0_IRQ3&#160;</td><td class="fielddoc"><p>ERU0_SR0 and ERU1_SR0 connected to IRQ3 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ac68238fef35855b64d29c302591fdd51"></a>XMC_SCU_IRQCTRL_ERU0_SR1_IRQ4&#160;</td><td class="fielddoc"><p>ERU0_SR1 connected to IRQ4 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a6994100b7c761b15ad8766d4375e78c5"></a>XMC_SCU_IRQCTRL_ERU1_SR1_IRQ4&#160;</td><td class="fielddoc"><p>ERU1_SR1 connected to IRQ4 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a5d57f3d50c270203e904d986a819db32"></a>XMC_SCU_IRQCTRL_CAN0_SR1_IRQ4&#160;</td><td class="fielddoc"><p>CAN0_SR1 connected to IRQ4 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a70ab9a6c4c3019e3bc8ce18392cea454"></a>XMC_SCU_IRQCTRL_ERU0_SR1_OR_ERU1_SR1_IRQ4&#160;</td><td class="fielddoc"><p>ERU0_SR1 and ERU1_SR1 connected to IRQ4 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a06a7523a0ef54aeacfc3bfcc74afdc27"></a>XMC_SCU_IRQCTRL_ERU0_SR2_IRQ5&#160;</td><td class="fielddoc"><p>ERU0_SR2 connected to IRQ5 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ae983faf01a2deae6864b0650d4d246ed"></a>XMC_SCU_IRQCTRL_ERU1_SR2_IRQ5&#160;</td><td class="fielddoc"><p>ERU1_SR2 connected to IRQ5 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a11c05b03a927b95afe128d7b7b014648"></a>XMC_SCU_IRQCTRL_CAN0_SR2_IRQ5&#160;</td><td class="fielddoc"><p>CAN0_SR2 connected to IRQ5 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487adb769033bc3c3d376ae4f813a944ca22"></a>XMC_SCU_IRQCTRL_ERU0_SR2_OR_ERU1_SR2_IRQ5&#160;</td><td class="fielddoc"><p>ERU0_SR2 and ERU1_SR2 connected to IRQ5 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a05319a726da644ae8f4014fc6100f769"></a>XMC_SCU_IRQCTRL_ERU0_SR3_IRQ6&#160;</td><td class="fielddoc"><p>ERU0_SR3 connected to IRQ6 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a66fbb751d3e51be99e2786e7ecb92f63"></a>XMC_SCU_IRQCTRL_ERU1_SR3_IRQ6&#160;</td><td class="fielddoc"><p>ERU1_SR3 connected to IRQ6 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a981a9c9010cf08bcec62512700bf46fb"></a>XMC_SCU_IRQCTRL_CAN0_SR3_IRQ6&#160;</td><td class="fielddoc"><p>CAN0_SR3 connected to IRQ6 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a9606144931f452469a46f5e694333b2a"></a>XMC_SCU_IRQCTRL_ERU0_SR3_OR_ERU1_SR3_IRQ6&#160;</td><td class="fielddoc"><p>ERU0_SR3 and ERU1_SR3 connected to IRQ6 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a38aafd96c4252a8a8e60075c9959fab4"></a>XMC_SCU_IRQCTRL_MATH_SR0_IRQ7&#160;</td><td class="fielddoc"><p>MATH_SR0 connected to IRQ7 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a93da91d7d87dae525f5054648daf0318"></a>XMC_SCU_IRQCTRL_CAN0_SR3_IRQ7&#160;</td><td class="fielddoc"><p>CAN0_SR3 connected to IRQ7 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a9e0f2e1b5eda81c5a90d03bd91a417a5"></a>XMC_SCU_IRQCTRL_CCU40_SR1_IRQ7&#160;</td><td class="fielddoc"><p>CCU40_SR1 connected to IRQ7 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a65883869e7537e2584b5ec9ffd4f1c3a"></a>XMC_SCU_IRQCTRL_MATH_SR0_OR_CAN0_SR3_IRQ7&#160;</td><td class="fielddoc"><p>MATH_SR0 and CAN0_SR3 connected to IRQ7 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ac8cffdcac35b278cb0283b0293819e75"></a>XMC_SCU_IRQCTRL_LEDTS2_SR0_IRQ8&#160;</td><td class="fielddoc"><p>LEDTS2_SR0 connected to IRQ8 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ae55ca402502427e40fab2bc90ad60ca6"></a>XMC_SCU_IRQCTRL_CCU40_SR0_IRQ8&#160;</td><td class="fielddoc"><p>CCU40_SR0 connected to IRQ8 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487aad1595526dbdaf7661a8938c0cbe5676"></a>XMC_SCU_IRQCTRL_CCU80_SR0_IRQ8&#160;</td><td class="fielddoc"><p>CCU80_SR0 connected to IRQ8 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a3076625d59271dbbdc84ef71f0024211"></a>XMC_SCU_IRQCTRL_LEDTS2_SR0_OR_CCU40_SR0_IRQ8&#160;</td><td class="fielddoc"><p>LEDTS2_SR0 and CCU40_SR0 connected to IRQ8 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a9189904698eabda9528b8a9b8fa58f22"></a>XMC_SCU_IRQCTRL_USIC0_SR0_IRQ9&#160;</td><td class="fielddoc"><p>USIC0_SR0 connected to IRQ9 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a4ceef8589ce433dc0edaa0999125d167"></a>XMC_SCU_IRQCTRL_USIC1_SR0_IRQ9&#160;</td><td class="fielddoc"><p>USIC1_SR0 connected to IRQ9 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487aee0ba725d1bdfba388240d01fe3eb046"></a>XMC_SCU_IRQCTRL_ERU0_SR0_IRQ9&#160;</td><td class="fielddoc"><p>ERU0_SR0 connected to IRQ9 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a6033d30fbdbaee43faaf1ea106f4f2f6"></a>XMC_SCU_IRQCTRL_USIC0_SR0_OR_USIC1_SR0_IRQ9&#160;</td><td class="fielddoc"><p>USIC0_SR0 and USIC1_SR0 connected to IRQ9 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a08ce26ed33b17e866283d82d4fb54a5b"></a>XMC_SCU_IRQCTRL_USIC0_SR1_IRQ10&#160;</td><td class="fielddoc"><p>USIC0_SR1 connected to IRQ10 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487afa2a49255c585e257f08bf2771c9f5c8"></a>XMC_SCU_IRQCTRL_USIC1_SR1_IRQ10&#160;</td><td class="fielddoc"><p>USIC1_SR1 connected to IRQ10 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487aeb405a90e207a9b13c0b6c9788aa1e13"></a>XMC_SCU_IRQCTRL_ERU0_SR1_IRQ10&#160;</td><td class="fielddoc"><p>ERU0_SR1 connected to IRQ10 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487aaea3f81a42c2d68fe942b45d8fa99574"></a>XMC_SCU_IRQCTRL_USIC0_SR1_OR_USIC1_SR1_IRQ10&#160;</td><td class="fielddoc"><p>USIC0_SR1 and USIC1_SR1 connected to IRQ10 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a47ef0f2233fa669d704d862a44de7506"></a>XMC_SCU_IRQCTRL_USIC0_SR2_IRQ11&#160;</td><td class="fielddoc"><p>USIC0_SR2 connected to IRQ11 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ab708686ee3dfb9ac95634ccadcd8e71c"></a>XMC_SCU_IRQCTRL_USIC1_SR2_IRQ11&#160;</td><td class="fielddoc"><p>USIC1_SR2 connected to IRQ11 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a1a65532e07b826b1bc0f34a857bb4118"></a>XMC_SCU_IRQCTRL_ERU0_SR2_IRQ11&#160;</td><td class="fielddoc"><p>ERU0_SR2 connected to IRQ11 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a8445a27dd1ee5241853d8eea69db36a1"></a>XMC_SCU_IRQCTRL_USIC0_SR2_OR_USIC1_SR2_IRQ11&#160;</td><td class="fielddoc"><p>USIC0_SR2 and USIC1_SR2 connected to IRQ11 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a4f658f6a02d06f8009dc9966949d40ac"></a>XMC_SCU_IRQCTRL_USIC0_SR3_IRQ12&#160;</td><td class="fielddoc"><p>USIC0_SR3 connected to IRQ12 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a2dae2e55845c2d03679d4af66561b246"></a>XMC_SCU_IRQCTRL_USIC1_SR3_IRQ12&#160;</td><td class="fielddoc"><p>USIC1_SR3 connected to IRQ12 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a07e2523568d98a296e1ef5a849be0ec4"></a>XMC_SCU_IRQCTRL_ERU0_SR3_IRQ12&#160;</td><td class="fielddoc"><p>ERU0_SR3 connected to IRQ12 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ae00c5659bc7d9bc922a90f3eed32299e"></a>XMC_SCU_IRQCTRL_USIC0_SR3_OR_USIC1_SR3_IRQ12&#160;</td><td class="fielddoc"><p>USIC0_SR3 and USIC1_SR3 connected to IRQ12 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a765463e45a5f0893bf21be42e40866ff"></a>XMC_SCU_IRQCTRL_USIC0_SR4_IRQ13&#160;</td><td class="fielddoc"><p>USIC0_SR4 connected to IRQ13 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ab952f9c88de828afce16223d30735b5d"></a>XMC_SCU_IRQCTRL_USIC1_SR4_IRQ13&#160;</td><td class="fielddoc"><p>USIC1_SR4 connected to IRQ13 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a60f7f438d5ac7e730035696530c175d6"></a>XMC_SCU_IRQCTRL_CCU80_SR1_IRQ13&#160;</td><td class="fielddoc"><p>CCU80_SR1 connected to IRQ13 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487aed4ef906abd76ecd762f27435bf6f8f5"></a>XMC_SCU_IRQCTRL_USIC0_SR4_OR_USIC1_SR4_IRQ13&#160;</td><td class="fielddoc"><p>USIC0_SR4 and USIC1_SR4 connected to IRQ13 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ab5e90c490a8ea3102a2bd516e9d01806"></a>XMC_SCU_IRQCTRL_USIC0_SR5_IRQ14&#160;</td><td class="fielddoc"><p>USIC0_SR5 connected to IRQ14 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a0bc69b6ee1e377b3d300a7bf07455a1a"></a>XMC_SCU_IRQCTRL_USIC1_SR5_IRQ14&#160;</td><td class="fielddoc"><p>USIC1_SR5 connected to IRQ14 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a748c3f4888b6d7b09d09aaabbe6ac224"></a>XMC_SCU_IRQCTRL_POSIF0_SR0_IRQ14&#160;</td><td class="fielddoc"><p>POSIF0_SR0 connected to IRQ14 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a4ca14c7313a8fd76d03d4e53c20e2834"></a>XMC_SCU_IRQCTRL_USIC0_SR5_OR_USIC1_SR5_IRQ14&#160;</td><td class="fielddoc"><p>USIC0_SR5 and USIC1_SR5 connected to IRQ14 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a94e93b78bdd037d4a1284208b85cd229"></a>XMC_SCU_IRQCTRL_VADC0_C0SR0_IRQ15&#160;</td><td class="fielddoc"><p>VADC0_C0SR0 connected to IRQ15 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a48f1bef1e243db79368b3269fdfd4563"></a>XMC_SCU_IRQCTRL_USIC0_SR0_IRQ15&#160;</td><td class="fielddoc"><p>USIC0_SR0 connected to IRQ15 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a57d9be78e17dcd335f2f997976be6dc8"></a>XMC_SCU_IRQCTRL_POSIF0_SR1_IRQ15&#160;</td><td class="fielddoc"><p>POSIF0_SR1 connected to IRQ15 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a907c8a80aeed03a3fdc89d3cb7fec76c"></a>XMC_SCU_IRQCTRL_VADC0_C0SR0_OR_USIC0_SR0_IRQ15&#160;</td><td class="fielddoc"><p>VADC0_C0SR0 and USIC0_SR0 connected to IRQ15 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a465bbff5c1426edb87da7f6b2d8f7184"></a>XMC_SCU_IRQCTRL_VADC0_C0SR1_IRQ16&#160;</td><td class="fielddoc"><p>VADC0_C0SR1 connected to IRQ16 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487aa1ad57ab3d01e0e3c524831d3e0adf45"></a>XMC_SCU_IRQCTRL_USIC0_SR1_IRQ16&#160;</td><td class="fielddoc"><p>USIC0_SR1 connected to IRQ16 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a6af1b76f88f1a4358315e889f25d4df1"></a>XMC_SCU_IRQCTRL_CCU40_SR2_IRQ16&#160;</td><td class="fielddoc"><p>CCU40_SR2 connected to IRQ16 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487aa3fee73223d9ffd5415de1b5e53f9d29"></a>XMC_SCU_IRQCTRL_VADC0_C0SR1_OR_USIC0_SR1_IRQ16&#160;</td><td class="fielddoc"><p>VADC0_C0SR1 and USIC0_SR1 connected to IRQ16 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a90bfff1848a2b557a7aaeff2845ac14d"></a>XMC_SCU_IRQCTRL_VADC0_G0SR0_IRQ17&#160;</td><td class="fielddoc"><p>VADC0_G0SR0 connected to IRQ17 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a6d1e56fca660d3d79eb98cb0bed52548"></a>XMC_SCU_IRQCTRL_USIC0_SR2_IRQ17&#160;</td><td class="fielddoc"><p>USIC0_SR2 connected to IRQ17 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a7b5b7b647e2b3e7174de8fad10a88463"></a>XMC_SCU_IRQCTRL_CAN0_SR0_IRQ17&#160;</td><td class="fielddoc"><p>CAN0_SR0 connected to IRQ17 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ad9f4b3cff2f6a5b9eda4b9399e1a8ace"></a>XMC_SCU_IRQCTRL_VADC0_G0SR0_OR_USIC0_SR2_IRQ17&#160;</td><td class="fielddoc"><p>VADC0_G0SR0 and USIC0_SR2 connected to IRQ17 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a0061d150fb4a068d86781f6a8e2830b7"></a>XMC_SCU_IRQCTRL_VADC0_G0SR1_IRQ18&#160;</td><td class="fielddoc"><p>VADC0_G0SR1 connected to IRQ18 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a41724a6af82d90953a59ba7ecb0b30aa"></a>XMC_SCU_IRQCTRL_USIC0_SR3_IRQ18&#160;</td><td class="fielddoc"><p>USIC0_SR3 connected to IRQ18 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487afe71fd3f565d4350553be8cc53cf5198"></a>XMC_SCU_IRQCTRL_CAN0_SR1_IRQ18&#160;</td><td class="fielddoc"><p>CAN0_SR1 connected to IRQ18 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ab67dcfd5c191bab2a5874731571cbaad"></a>XMC_SCU_IRQCTRL_VADC0_G0SR1_OR_USIC0_SR3_IRQ18&#160;</td><td class="fielddoc"><p>VADC0_G0SR1 and USIC0_SR3 connected to IRQ18 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ae781ff0ccedcf3cab18b86288e0518f6"></a>XMC_SCU_IRQCTRL_VADC0_G1SR0_IRQ19&#160;</td><td class="fielddoc"><p>VADC0_G1SR0 connected to IRQ19 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ab5da0a2ba63155a33f86f6efd66d6a20"></a>XMC_SCU_IRQCTRL_USIC0_SR4_IRQ19&#160;</td><td class="fielddoc"><p>USIC0_SR4 connected to IRQ19 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a7f36c1b64f73cc04b3ec2ede26a601cc"></a>XMC_SCU_IRQCTRL_CAN0_SR2_IRQ19&#160;</td><td class="fielddoc"><p>CAN0_SR2 connected to IRQ19 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a0b330cf4649e3bc20fae4e0a3026a15d"></a>XMC_SCU_IRQCTRL_VADC0_G1SR0_OR_USIC0_SR4_IRQ19&#160;</td><td class="fielddoc"><p>VADC0_G1SR0 and USIC0_SR4 connected to IRQ19 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a903c8990aa86851399acefd9d030eb1a"></a>XMC_SCU_IRQCTRL_VADC0_G1SR1_IRQ20&#160;</td><td class="fielddoc"><p>VADC0_G1SR1 connected to IRQ20 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ae401eb81ffad416816e43f205527dd59"></a>XMC_SCU_IRQCTRL_USIC0_SR5_IRQ20&#160;</td><td class="fielddoc"><p>USIC0_SR5 connected to IRQ20 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487afa8c9fc2605fee21aed7363a4f596f56"></a>XMC_SCU_IRQCTRL_CAN0_SR3_IRQ20&#160;</td><td class="fielddoc"><p>CAN0_SR3 connected to IRQ20 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a31781eadd9e14fa8061d3d2e7d7d5b90"></a>XMC_SCU_IRQCTRL_CAN0_SR4_IRQ20&#160;</td><td class="fielddoc"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>use instead XMC_SCU_IRQCTRL_CAN0_SR3_IRQ20 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487abe456b050e3ed637c034067bfd8e754e"></a>XMC_SCU_IRQCTRL_VADC0_G1SR1_OR_USIC0_SR5_IRQ20&#160;</td><td class="fielddoc"><p>VADC0_G1SR1 and USIC0_SR5 connected to IRQ20 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ae74bffd8b6012a5f09ea9104c7500f1a"></a>XMC_SCU_IRQCTRL_CCU40_SR0_IRQ21&#160;</td><td class="fielddoc"><p>CCU40_SR0 connected to IRQ21 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a53589ccabe281e70c0139809f7b9b9eb"></a>XMC_SCU_IRQCTRL_CCU41_SR0_IRQ21&#160;</td><td class="fielddoc"><p>CCU41_SR0 connected to IRQ21 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a4daded2e6d3faab4cc7b0ddb712c3650"></a>XMC_SCU_IRQCTRL_USIC0_SR0_IRQ21&#160;</td><td class="fielddoc"><p>USIC0_SR0 connected to IRQ21 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487add96da5af4b3f6fb2d015c7557ee01ee"></a>XMC_SCU_IRQCTRL_CCU40_SR0_OR_CCU41_SR0_IRQ21&#160;</td><td class="fielddoc"><p>CCU40_SR0 and CCU41_SR0 connected to IRQ21 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a45d0af7974161839adf9501af8e1f7d6"></a>XMC_SCU_IRQCTRL_CCU40_SR1_IRQ22&#160;</td><td class="fielddoc"><p>CCU40_SR1 connected to IRQ22 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ac27ee9dffe128becd26ea837a08b736c"></a>XMC_SCU_IRQCTRL_CCU41_SR1_IRQ22&#160;</td><td class="fielddoc"><p>CCU41_SR1 connected to IRQ22 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487af09d9e948383e50db35eb0f8e3edca6c"></a>XMC_SCU_IRQCTRL_USIC0_SR1_IRQ22&#160;</td><td class="fielddoc"><p>USIC0_SR1 connected to IRQ22 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ae84bcdb66bfe212d675d0dfbc53c8bdf"></a>XMC_SCU_IRQCTRL_CCU40_SR0_OR_CCU41_SR0_IRQ22&#160;</td><td class="fielddoc"><p>CCU40_SR0 and CCU41_SR0 connected to IRQ22 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487afbdb8c2f25d94f8e330cccf0141043db"></a>XMC_SCU_IRQCTRL_CCU40_SR2_IRQ23&#160;</td><td class="fielddoc"><p>CCU40_SR2 connected to IRQ23 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a5c49ad1d64be477f8ee29f8e2f776a56"></a>XMC_SCU_IRQCTRL_CCU41_SR2_IRQ23&#160;</td><td class="fielddoc"><p>CCU41_SR2 connected to IRQ23 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a69c46671c2f044e070c7bb7c7eb7b403"></a>XMC_SCU_IRQCTRL_USIC0_SR2_IRQ23&#160;</td><td class="fielddoc"><p>USIC0_SR2 connected to IRQ23 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a5db7f53061b476a69fdd8dd4d6476cc7"></a>XMC_SCU_IRQCTRL_CCU40_SR2_OR_CCU41_SR2_IRQ23&#160;</td><td class="fielddoc"><p>CCU40_SR2 and CCU41_SR2 connected to IRQ23 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ad952aa6d09a65d9f8e301e64fbfbeadd"></a>XMC_SCU_IRQCTRL_CCU40_SR3_IRQ24&#160;</td><td class="fielddoc"><p>CCU40_SR3 connected to IRQ24 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487aeeb3b1751509edc22635f09660e3ecd0"></a>XMC_SCU_IRQCTRL_CCU41_SR3_IRQ24&#160;</td><td class="fielddoc"><p>CCU41_SR3 connected to IRQ24 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a774000bc8ed15d88e8ae6dafd243ba9d"></a>XMC_SCU_IRQCTRL_USIC0_SR3_IRQ24&#160;</td><td class="fielddoc"><p>USIC0_SR3 connected to IRQ24 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a7c1898b2456b991cf7d097429373fb34"></a>XMC_SCU_IRQCTRL_CCU40_SR3_OR_CCU41_SR3_IRQ24&#160;</td><td class="fielddoc"><p>CCU40_SR3 and CCU41_SR3 connected to IRQ24 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ab5b6fea127f6e88d90523b4f1c3e36aa"></a>XMC_SCU_IRQCTRL_CCU80_SR0_IRQ25&#160;</td><td class="fielddoc"><p>CCU80_SR0 connected to IRQ25 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a8febf5082c634874f8a18b9818f5a1f4"></a>XMC_SCU_IRQCTRL_CCU81_SR0_IRQ25&#160;</td><td class="fielddoc"><p>CCU81_SR0 connected to IRQ25 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ad945c0350977bcaa63a92fef4ab71535"></a>XMC_SCU_IRQCTRL_USIC0_SR4_IRQ25&#160;</td><td class="fielddoc"><p>USIC0_SR4 connected to IRQ25 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a2ad937077b3af70a0eb69be9e9c8a2c4"></a>XMC_SCU_IRQCTRL_CCU80_SR0_OR_CCU81_SR0_IRQ25&#160;</td><td class="fielddoc"><p>CCU80_SR0 and CCU81_SR0 connected to IRQ25 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a080768080aee7028c680471f1bcbbf57"></a>XMC_SCU_IRQCTRL_CCU80_SR1_IRQ26&#160;</td><td class="fielddoc"><p>CCU80_SR1 connected to IRQ26 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a9d425c6de940d472d45a71815d49c6ed"></a>XMC_SCU_IRQCTRL_CCU81_SR1_IRQ26&#160;</td><td class="fielddoc"><p>CCU81_SR1 connected to IRQ26 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a50332444818b9e10dd845ef94c127e7a"></a>XMC_SCU_IRQCTRL_USIC0_SR5_IRQ26&#160;</td><td class="fielddoc"><p>USIC0_SR5 connected to IRQ26 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ab22342e8fd2533cb71c74e290dbc6028"></a>XMC_SCU_IRQCTRL_CCU80_SR1_OR_CCU81_SR1_IRQ26&#160;</td><td class="fielddoc"><p>CCU80_SR1 and CCU81_SR1 connected to IRQ26 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a8f2a9b764dd039fa23bf8b10c713fc52"></a>XMC_SCU_IRQCTRL_POSIF0_SR0_IRQ27&#160;</td><td class="fielddoc"><p>POSIF0_SR0 connected to IRQ27 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ab94cf1ca85eb5f2df25454271a530103"></a>XMC_SCU_IRQCTRL_POSIF1_SR0_IRQ27&#160;</td><td class="fielddoc"><p>POSIF1_SR0 connected to IRQ27 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487aa9eabac16ee2f77d4a866d799f661ae8"></a>XMC_SCU_IRQCTRL_CCU40_SR3_IRQ27&#160;</td><td class="fielddoc"><p>CCU40_SR3 connected to IRQ27 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ad21c1ad6b0b73ee76b06a6e6cde41ac8"></a>XMC_SCU_IRQCTRL_POSIF0_SR0_OR_POSIF1_SR0_IRQ27&#160;</td><td class="fielddoc"><p>POSIF0_SR0 and POSIF1_SR0 connected to IRQ27 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ae896410e0f5c5575737457b8d2b35112"></a>XMC_SCU_IRQCTRL_POSIF0_SR1_IRQ28&#160;</td><td class="fielddoc"><p>POSIF0_SR1 connected to IRQ28 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487accb2090aeab29489530ae8705cdd8540"></a>XMC_SCU_IRQCTRL_POSIF1_SR1_IRQ28&#160;</td><td class="fielddoc"><p>POSIF1_SR1 connected to IRQ28 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487aa46886530c76776e6f481da1f5fb0645"></a>XMC_SCU_IRQCTRL_ERU0_SR0_IRQ28&#160;</td><td class="fielddoc"><p>ERU0_SR0 connected to IRQ28 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487abfbae1dc5496d31df11dff2e628a5314"></a>XMC_SCU_IRQCTRL_POSIF0_SR1_OR_POSIF1_SR1_IRQ28&#160;</td><td class="fielddoc"><p>POSIF0_SR1 and POSIF1_SR1 connected to IRQ28 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ad08774b555828acc8d42a801cb10578a"></a>XMC_SCU_IRQCTRL_LEDTS0_SR0_IRQ29&#160;</td><td class="fielddoc"><p>LEDTS0_SR0 connected to IRQ29 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ad8829fd344aba45cef944038a5a865be"></a>XMC_SCU_IRQCTRL_CCU40_SR1_IRQ29&#160;</td><td class="fielddoc"><p>CCU40_SR1 connected to IRQ29 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a54c813d81e501dea34f08ea70d1749f6"></a>XMC_SCU_IRQCTRL_ERU0_SR1_IRQ29&#160;</td><td class="fielddoc"><p>ERU0_SR1 connected to IRQ29 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a1f6e05987e426cc6a7f279582565b7b7"></a>XMC_SCU_IRQCTRL_LEDTS0_SR0_OR_CCU40_SR1_IRQ29&#160;</td><td class="fielddoc"><p>LEDTS0_SR0 and CCU40_SR1 connected to IRQ29 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ac7b7d2db575e6cb8fb45bed40353477e"></a>XMC_SCU_IRQCTRL_LEDTS1_SR0_IRQ30&#160;</td><td class="fielddoc"><p>LEDTS1_SR0 connected to IRQ30 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487ab33a29b2399b855e4e68a0b5e494d4d6"></a>XMC_SCU_IRQCTRL_CCU40_SR2_IRQ30&#160;</td><td class="fielddoc"><p>CCU40_SR2 connected to IRQ30 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487afffa939ee67090ac8f6cbb4d90d49d5b"></a>XMC_SCU_IRQCTRL_ERU0_SR2_IRQ30&#160;</td><td class="fielddoc"><p>ERU0_SR2 connected to IRQ30 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a858eb58c2db680dcc40a68e56c3121e1"></a>XMC_SCU_IRQCTRL_LEDTS0_SR0_OR_CCU40_SR1_IRQ30&#160;</td><td class="fielddoc"><p>LEDTS0_SR0 and CCU40_SR1 connected to IRQ30 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a99a7d773dcb096dce98893c1d1ee9317"></a>XMC_SCU_IRQCTRL_BCCU0_SR0_IRQ31&#160;</td><td class="fielddoc"><p>BCCU0_SR0 connected to IRQ31 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487aeb0fb2957c372f43ebaefd2613673f14"></a>XMC_SCU_IRQCTRL_CCU40_SR3_IRQ31&#160;</td><td class="fielddoc"><p>CCU40_SR3 connected to IRQ31 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a6b56c02001068a4345bf1f6d9db93584"></a>XMC_SCU_IRQCTRL_ERU0_SR3_IRQ31&#160;</td><td class="fielddoc"><p>ERU0_SR3 connected to IRQ31 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad54a1c90f3b35f4c49d62ac204678487a1691b22a07cf9d49299c891d5e447b53"></a>XMC_SCU_IRQCTRL_BCCU0_SR0_OR_CCU40_SR3_IRQ31&#160;</td><td class="fielddoc"><p>BCCU0_SR0 and CCU40_SR3 connected to IRQ31 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga29713150fdafc3c88f3c73f621410239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29713150fdafc3c88f3c73f621410239">&#9670;&nbsp;</a></span>XMC_SCU_PERIPHERAL_CLOCK_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the list of peripherals that support clock gating. After a master reset, only core, memories, SCU and PORT peripheral are not clock gated. The rest of the peripherals are by default clock gated. All the enum items are tabulated as per bits present in <em>CGATSTAT0</em> register. Use type <em>XMC_SCU_PERIPHERAL_CLOCK_t</em> for accessing these enum parameters. </p><dl class="section note"><dt>Note</dt><dd>Peripherals availability depends on device </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga29713150fdafc3c88f3c73f621410239a0bb88ac36dfd3545282123f56c5c2374"></a>XMC_SCU_PERIPHERAL_CLOCK_CCU80&#160;</td><td class="fielddoc"><p>CCU80 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29713150fdafc3c88f3c73f621410239a346af75d76735810851f4175e0aa7510"></a>XMC_SCU_PERIPHERAL_CLOCK_CCU40&#160;</td><td class="fielddoc"><p>CCU40 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29713150fdafc3c88f3c73f621410239a3b7bdfee77b9c35016b8c8367fa19cc2"></a>XMC_SCU_PERIPHERAL_CLOCK_USIC0&#160;</td><td class="fielddoc"><p>USIC0 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29713150fdafc3c88f3c73f621410239ad9f67751fcf7facbbf4cd2a5b36e38f0"></a>XMC_SCU_PERIPHERAL_CLOCK_BCCU0&#160;</td><td class="fielddoc"><p>BCCU0 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29713150fdafc3c88f3c73f621410239a2cdc8717b252a95151639d5f95c5d0a2"></a>XMC_SCU_PERIPHERAL_CLOCK_LEDTS0&#160;</td><td class="fielddoc"><p>LEDTS0 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29713150fdafc3c88f3c73f621410239a9979deef2f645ef5335292f656b301b8"></a>XMC_SCU_PERIPHERAL_CLOCK_LEDTS1&#160;</td><td class="fielddoc"><p>LEDTS1 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29713150fdafc3c88f3c73f621410239a7d81755a02791cef84e36351a4e21ca5"></a>XMC_SCU_PERIPHERAL_CLOCK_POSIF0&#160;</td><td class="fielddoc"><p>POSIF0 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29713150fdafc3c88f3c73f621410239abd383e07c1966b805eabc208362baefd"></a>XMC_SCU_PERIPHERAL_CLOCK_MATH&#160;</td><td class="fielddoc"><p>MATH peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29713150fdafc3c88f3c73f621410239a94022ad63fa2dbbbf514709a230956ea"></a>XMC_SCU_PERIPHERAL_CLOCK_WDT&#160;</td><td class="fielddoc"><p>WDT peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29713150fdafc3c88f3c73f621410239a274fa98fa526d3ea003785ecbcba9e36"></a>XMC_SCU_PERIPHERAL_CLOCK_RTC&#160;</td><td class="fielddoc"><p>RTC peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29713150fdafc3c88f3c73f621410239aef9ea70d04e1bea868c12afb6652c2e6"></a>XMC_SCU_PERIPHERAL_CLOCK_CCU81&#160;</td><td class="fielddoc"><p>CCU80 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29713150fdafc3c88f3c73f621410239acd9123d275104ad16e58a1eed3e3a8de"></a>XMC_SCU_PERIPHERAL_CLOCK_CCU41&#160;</td><td class="fielddoc"><p>CCU80 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29713150fdafc3c88f3c73f621410239a37d2702a725dfc9bf6093e324a530ffb"></a>XMC_SCU_PERIPHERAL_CLOCK_USIC1&#160;</td><td class="fielddoc"><p>USIC0 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29713150fdafc3c88f3c73f621410239a596167ddbcaed12bfe7ae0dcfe6d3a3f"></a>XMC_SCU_PERIPHERAL_CLOCK_LEDTS2&#160;</td><td class="fielddoc"><p>LEDTS1 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29713150fdafc3c88f3c73f621410239aae87aa0eeb15734f1d6681258f2e1db3"></a>XMC_SCU_PERIPHERAL_CLOCK_POSIF1&#160;</td><td class="fielddoc"><p>POSIF0 peripheral clock gate. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29713150fdafc3c88f3c73f621410239ab6ee98017bc789b6642e875cd7918c0f"></a>XMC_SCU_PERIPHERAL_CLOCK_MCAN&#160;</td><td class="fielddoc"><p>POSIF0 peripheral clock gate. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaae067899a6cfa605f5ebfef2c1f8d393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae067899a6cfa605f5ebfef2c1f8d393">&#9670;&nbsp;</a></span>XMC_SCU_POWER_MONITOR_DELAY_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gaae067899a6cfa605f5ebfef2c1f8d393">XMC_SCU_POWER_MONITOR_DELAY_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TODO </p>

</div>
</div>
<a id="ga985038b59c5bc1d8341db06c6c7cbfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga985038b59c5bc1d8341db06c6c7cbfdc">&#9670;&nbsp;</a></span>XMC_SCU_POWER_MONITOR_RANGE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga985038b59c5bc1d8341db06c6c7cbfdc">XMC_SCU_POWER_MONITOR_RANGE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TODO </p>

</div>
</div>
<a id="gae01c08f5d524dadbc6e0c4128b348dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae01c08f5d524dadbc6e0c4128b348dc3">&#9670;&nbsp;</a></span>XMC_SCU_RESET_REASON_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gae01c08f5d524dadbc6e0c4128b348dc3">XMC_SCU_RESET_REASON_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the cause of last reset. The cause of last reset gets automatically stored in the <em>SCU_RSTSTAT</em> register and can be checked by user software to determine the state of the system and for debug purpose. All the enum items are tabulated as per bits present in <em>SCU_RSTSTAT</em> register. Use type <em>XMC_SCU_RESET_REASON_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae01c08f5d524dadbc6e0c4128b348dc3ae8bea77e364f87d9c74afb215da65273"></a>XMC_SCU_RESET_REASON_PORST&#160;</td><td class="fielddoc"><p>Reset due to Power On reset. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01c08f5d524dadbc6e0c4128b348dc3a1742c1894d91860d7541385f3f0c4fe1"></a>XMC_SCU_RESET_REASON_MASTER&#160;</td><td class="fielddoc"><p>Reset due to Master reset. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01c08f5d524dadbc6e0c4128b348dc3aa6d2a43d58beebfabf3897c2ed65bd03"></a>XMC_SCU_RESET_REASON_SW&#160;</td><td class="fielddoc"><p>Reset due to Software initiated reset. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01c08f5d524dadbc6e0c4128b348dc3aa147b82fa48ea09fe9137601ce28b6c9"></a>XMC_SCU_RESET_REASON_LOCKUP&#160;</td><td class="fielddoc"><p>Reset due to CPU lockup. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01c08f5d524dadbc6e0c4128b348dc3a5b52d4b8f8aa89a37e05e865ffaef900"></a>XMC_SCU_RESET_REASON_FLASH&#160;</td><td class="fielddoc"><p>Reset due to flash error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01c08f5d524dadbc6e0c4128b348dc3acd2ed3c6d9ade72259637c7c80a840cb"></a>XMC_SCU_RESET_REASON_WATCHDOG&#160;</td><td class="fielddoc"><p>Reset due to watchdog. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01c08f5d524dadbc6e0c4128b348dc3a0e3a7d9ed387fd8d11576c4f63d61cb2"></a>XMC_SCU_RESET_REASON_CLOCK_LOSS&#160;</td><td class="fielddoc"><p>Reset due to clock loss. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01c08f5d524dadbc6e0c4128b348dc3a9d34595d39facbd7b114462d5cc5b0c8"></a>XMC_SCU_RESET_REASON_PARITY_ERROR&#160;</td><td class="fielddoc"><p>Reset due to RAM parity error. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaff029b1575acc0712d494932d8ca6d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff029b1575acc0712d494932d8ca6d60">&#9670;&nbsp;</a></span>XMC_SCU_STATUS_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the status of SCU API execution, used to verify the SCU related API calls. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaff029b1575acc0712d494932d8ca6d60a764eaaa84d169b3222ae9174d1fa6855"></a>XMC_SCU_STATUS_OK&#160;</td><td class="fielddoc"><p>SCU related operation successfully completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaff029b1575acc0712d494932d8ca6d60aaf8f778e9be5e754dcaa0c1cf83e1e4b"></a>XMC_SCU_STATUS_ERROR&#160;</td><td class="fielddoc"><p>SCU related operation failed. When API cannot fulfill request, this value is returned. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaff029b1575acc0712d494932d8ca6d60a6f6a43bd2a61be2a1b0b57601d58bd77"></a>XMC_SCU_STATUS_BUSY&#160;</td><td class="fielddoc"><p>Cannot execute the SCU related operation request because another operation is in progress. <em>XMC_SCU_STATUS_BUSY</em> is returned when API is busy processing another request. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4988413b7da85ed020b8d1a8243e28aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4988413b7da85ed020b8d1a8243e28aa">&#9670;&nbsp;</a></span>XMC_SCU_SYSTEM_RESET_REQUEST_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga4988413b7da85ed020b8d1a8243e28aa">XMC_SCU_SYSTEM_RESET_REQUEST_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the reset sources that can cause device reset. These enums can be used to configure reset source in reset control <em>RSTCON</em> register which enables different reset sources to identify the reset cause. The <em>SCU_RSTSTAT</em> register can be checked by user software to determine the state of the system and for debug purpose. Use type <em>XMC_SCU_SYSTEM_RESET_REQUEST_t</em> for accessing these enum parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4988413b7da85ed020b8d1a8243e28aaa97383dd0b2c36dbb082441a879289a0d"></a>XMC_SCU_RESET_REQUEST_FLASH_ECC_ERROR&#160;</td><td class="fielddoc"><p>Reset when ECC double bit error occurs. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4988413b7da85ed020b8d1a8243e28aaa4e8060a113c0650c5c1ef3f200ce4e39"></a>XMC_SCU_RESET_REQUEST_CLOCK_LOSS&#160;</td><td class="fielddoc"><p>Reset when loss of clock occurs. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4988413b7da85ed020b8d1a8243e28aaaa2c6d4ddc9c83f71bf47d2b39ef25e83"></a>XMC_SCU_RESET_REQUEST_SRAM_PARITY_ERROR&#160;</td><td class="fielddoc"><p>Reset when SRAM parity error occurs. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4988413b7da85ed020b8d1a8243e28aaa50dee8709c1bc2b69bcf3e90ca52ce90"></a>XMC_SCU_RESET_REQUEST_USIC_SRAM_PARITY_ERROR&#160;</td><td class="fielddoc"><p>Reset when USIC0 memory parity error occurs. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae175b564557503258d534719100f899d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae175b564557503258d534719100f899d">&#9670;&nbsp;</a></span>XMC_SCU_CalcTemperature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CalcTemperature </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Calculate die temperature value. <b>Range:</b> 16 bit value.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Calculates the die temperature value using ROM function.<br />
<br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3b00187ccda526f06802152ecf199fa4">XMC_SCU_StartTempMeasurement()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gae7b20e6cd4212c28515a21ad6305bfa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7b20e6cd4212c28515a21ad6305bfa3">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_CalibrateOscillatorOnTemperature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_CalibrateOscillatorOnTemperature </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>temperature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">temperature</td><td>measured temperature using the on-chip temperature sensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>DCO1 clock frequency can be calibrated during runtime to achieve a better accuracy. This function start the DCO1 calibration based on temperature. </dd></dl>

</div>
</div>
<a id="ga1a3d595fe9b1c99675f569c5e98bbe20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a3d595fe9b1c99675f569c5e98bbe20">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_ClearDCO1OscillatorWatchdogStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_ClearDCO1OscillatorWatchdogStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>This function clears the status of the watchdog on the DCO1 frequency </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="ga1593fcaf7e9cfb8a276c564ca69cbe48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1593fcaf7e9cfb8a276c564ca69cbe48">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_DisableDCO1ExtRefCalibration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_DisableDCO1ExtRefCalibration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>This function stops the automatic DCO1 calibration based on the selected clock source. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="ga0bc3a0cbd7a1ce7fe4b45e6b975151b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bc3a0cbd7a1ce7fe4b45e6b975151b9">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_DisableDCO1OscillatorWatchdog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_DisableDCO1OscillatorWatchdog </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>This function disables the watchdog on the DCO1 frequency </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="ga1d273cfcd218e2e9061efe150f8e88d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d273cfcd218e2e9061efe150f8e88d9">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_EnableDCO1ExtRefCalibration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_EnableDCO1ExtRefCalibration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_c_u.html#ga26cbc15f43439603ed5976e7be9b6212">XMC_SCU_CLOCK_SYNC_CLKSRC_t</a>&#160;</td>
          <td class="paramname"><em>sync_clk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>prescaler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>syn_preload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync_clk</td><td>Clock source selected as external reference. <a class="el" href="group___s_c_u.html#ga26cbc15f43439603ed5976e7be9b6212">XMC_SCU_CLOCK_SYNC_CLKSRC_t</a> </td></tr>
    <tr><td class="paramname">prescaler</td><td>integer( \(\frac{syn_preload \times f_{OSC}[MHz]}{48}\)) </td></tr>
    <tr><td class="paramname">syn_preload</td><td>max. value 0x1FFF integer( \(\frac{48 \times prescaler}{f_{OSC}[MHz]}\))</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>DCO1 clock frequency can be calibrated during runtime to achieve a better accuracy. This function starts the automatic DCO1 calibration based on the selected clock source. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="gadec9aee733bfd18a1f91d19417f6d129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadec9aee733bfd18a1f91d19417f6d129">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_EnableDCO1OscillatorWatchdog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_EnableDCO1OscillatorWatchdog </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>This function enables the watchdog on the DCO1 frequency </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="gab0af70f90b9a1f24d3a0a4764543d833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0af70f90b9a1f24d3a0a4764543d833">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_GatePeripheralClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_GatePeripheralClock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a>&#160;</td>
          <td class="paramname"><em>peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>The peripheral for which the clock has to be gated. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> to identify the peripheral clock to be gated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Blocks the supply of clock to the selected peripheral.<br />
<br />
Clock gating helps in reducing the power consumption. User can selectively gate the clocks of unused peripherals. fPCLK is the source of clock to various peripherals. Some peripherals support clock gate. Such a gate blocks the clock supply for the selected peripheral. Software can request for individual gating of such peripheral clocks by enabling the <em>SCU_CGATSET0</em> register bit field. Every bit in <em>SCU_CGATSET0</em> register is protected by the bit protection scheme. Access to protected bit fields are handled internally. Note: Clock gating shall not be activated unless the module is in reset state. So use <em><a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated()</a></em> API before enabling the gating of any peripheral. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated()</a>, <a class="el" href="group___s_c_u.html#ga702904d10b6e6c6a55db381763fd322f">XMC_SCU_CLOCK_UngatePeripheralClock()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga3e78410c4d0c9f9b54aa0965d16c3795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e78410c4d0c9f9b54aa0965d16c3795">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_GetCpuClockFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetCpuClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Value of CPU clock frequency.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the vlaue of CPU clock frequency.<br />
<br />
The value is stored in a global variable <em><b>SystemCoreClock</b>.</em> It is updated when the clock configuration is done using the SCU LLD APIs. The value represents the frequency of clock used for CPU operation. <b>Range:</b> Value is of type uint32_t, and gives the value of frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga55a1be4f0e96fcda7b2c0feb542af250">XMC_SCU_CLOCK_GetPeripheralClockFrequency()</a>, <a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga4269bd27311f46c895b7ca474236d71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4269bd27311f46c895b7ca474236d71c">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_GetFastPeripheralClockFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetFastPeripheralClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Fast peripheral clock frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the clock frequency of peripherals on the peripheral bus that are using a shared functional clock.<br />
<br />
The value is derived using the bitfield <em>PCLKSEL</em> from <em>CLKCR</em> register. Peripheral clock can have 2 times the frequency of system clock if the <em>PCLKSEL</em> is set. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga6103bc92c9cd326903ee4e6b2e1d055d">XMC_SCU_CLOCK_SetFastPeripheralClockSource()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga55a1be4f0e96fcda7b2c0feb542af250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55a1be4f0e96fcda7b2c0feb542af250">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_GetPeripheralClockFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Value of peripheral clock frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the vlaue of clock frequency at which the peripherals are working.<br />
<br />
The value is derived from the CPU frequency. <b>Range:</b> Value is of type uint32_t. It is represented in Hertz. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3e78410c4d0c9f9b54aa0965d16c3795">XMC_SCU_CLOCK_GetCpuClockFrequency()</a>,<a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga08c337e8a728604e7eb54dff78ae2d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08c337e8a728604e7eb54dff78ae2d9d">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Pointer to structure holding the clock prescaler values and divider values for configuring clock generators and clock tree.<br />
 <b>Range:</b> Configure the members of structure <a class="el" href="struct_x_m_c___s_c_u___c_l_o_c_k___c_o_n_f_i_g__t.html">XMC_SCU_CLOCK_CONFIG_t</a> for various parameters of clock setup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Initializes clock generators and clock tree.<br />
<br />
Peripheral clock and system clock are configured based on the input configuration <em>config</em>. The system clock frequency is tuned by configuring the FDIV and IDIV values of CLKCR register. The values of FDIV and IDIV can be provided as part of input configuration. The PCLK divider determines the ratio of peripheral clock to the system clock. The source of RTC clock is set based on the input configuration. <em>SystemCoreClock</em> variable will be updated with the value of system clock frequency. Access to protected bit fields are handled internally. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga55a1be4f0e96fcda7b2c0feb542af250">XMC_SCU_CLOCK_GetPeripheralClockFrequency()</a>, <a class="el" href="group___s_c_u.html#ga3e78410c4d0c9f9b54aa0965d16c3795">XMC_SCU_CLOCK_GetCpuClockFrequency()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga52987a0ed17a5ac8644163a1f7b008e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52987a0ed17a5ac8644163a1f7b008e7">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_IsDCO1ExtRefCalibrationReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_CLOCK_IsDCO1ExtRefCalibrationReady </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true DCO1 is synchronized to the selected XTAL frequency </dd>
<dd>
false Actual DCO1 frequency is out of target</dd></dl>
<dl class="section user"><dt>Description</dt><dd>This functions checks the status of the synchronisation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="ga804f98badedf0e0ba4ce09f445687a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga804f98badedf0e0ba4ce09f445687a37">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_IsPeripheralClockGated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_CLOCK_IsPeripheralClockGated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a>&#160;</td>
          <td class="paramname"><em>peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>The peripheral for which the check for clock gating has to be done. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> to identify the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Status of the peripheral clock gating. <b>Range:</b> true if the peripheral clock is gated. false if the peripheral clock ungated(gate de-asserted).</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Gives the status of peripheral clock gating.<br />
<br />
Checks the status of peripheral clock gating using the register CGATSTAT0. It is recommended to use this API before enabling the gating of any peripherals through <em><a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a></em> API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga702904d10b6e6c6a55db381763fd322f">XMC_SCU_CLOCK_UngatePeripheralClock()</a>, <a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga66a7775d9fe9ee50a3936bd1abf20733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66a7775d9fe9ee50a3936bd1abf20733">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_ScaleMCLKFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_ScaleMCLKFrequency </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fdiv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idiv</td><td>Divider value.<br />
 <b>Range:</b> 0 to 255.<br />
</td></tr>
    <tr><td class="paramname">fdiv</td><td>Fractional Divider value.<br />
 <b>Range:</b> XMC11/XMC12/XMC13 Device: 0 to 255. XMC14 Device: 0 to 1023.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>This API configures main clock (MCLK) frequency by updating user provided divider values.<br />
<br />
The API configures main clock by setting <em>IDIV</em> and <em>FDIV</em> bit's of the <em>CLKCR</em> register for XMC11/XMC12/XMC13/XMC14 Device and with additional <em>FDIV</em> bit (FDIV[9:8]) of the <em>CLKCR1</em> register settings for XMC14 device. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga4e80d9644d060fdb10194d63d439e5d6">XMC_SCU_CLOCK_SetMCLKFrequency()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga1565840d44662b5655d67726624540ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1565840d44662b5655d67726624540ca">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_SetAdcClockSrc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetAdcClockSrc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_c_u.html#ga353883c8a243d54487bb5cc8edc20a32">XMC_SCU_CLOCK_ADCCLKSRC_t</a>&#160;</td>
          <td class="paramname"><em>adcclk_src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adcclk_src</td><td>Clock source selected as external reference. <a class="el" href="group___s_c_u.html#ga353883c8a243d54487bb5cc8edc20a32">XMC_SCU_CLOCK_ADCCLKSRC_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>ADC converter clock (fCONV) selection </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="ga6103bc92c9cd326903ee4e6b2e1d055d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6103bc92c9cd326903ee4e6b2e1d055d">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_SetFastPeripheralClockSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetFastPeripheralClockSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#gad4ef17eaabe7b13c5c159ba6b24c6a2c">XMC_SCU_CLOCK_PCLKSRC_t</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Fast peripheral clock source.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#gad4ef17eaabe7b13c5c159ba6b24c6a2c">XMC_SCU_CLOCK_PCLKSRC_t</a> to identify the clock source.<br />
 XMC_SCU_CLOCK_PCLKSRC_MCLK- Use MCLK as the peripheral clock.<br />
 XMC_SCU_CLOCK_PCLKSRC_DOUBLE_MCLK- peripheral clock will be 2 times the MCLK frequency.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures the source of peripheral clock. <br />
<br />
The peripheral clock can be either same as MCLK or twice the frequency of MCLK. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga4269bd27311f46c895b7ca474236d71c">XMC_SCU_CLOCK_GetFastPeripheralClockFrequency()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gafddcd1db57d4ff9eacf15ff37c2ca133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafddcd1db57d4ff9eacf15ff37c2ca133">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_SetHighPerformanceOscillatorMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetHighPerformanceOscillatorMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_c_u.html#ga48301d5a516ffd248e062d8f98bb8148">XMC_SCU_CLOCK_OSCHP_MODE_t</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Oscillator mode. <a class="el" href="group___s_c_u.html#ga48301d5a516ffd248e062d8f98bb8148">XMC_SCU_CLOCK_OSCHP_MODE_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configure functional mode of the OSCHP. </dd></dl>

</div>
</div>
<a id="ga33901ef9d941e0cd074e1a9adcff26ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33901ef9d941e0cd074e1a9adcff26ed">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_SetLowPerformanceOscillatorMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetLowPerformanceOscillatorMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_c_u.html#gad5bf98e9ea7d145180ad029ea3560d8d">XMC_SCU_CLOCK_OSCLP_MODE_t</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Oscillator mode. <a class="el" href="group___s_c_u.html#gad5bf98e9ea7d145180ad029ea3560d8d">XMC_SCU_CLOCK_OSCLP_MODE_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configure functional mode of the OSCLP. </dd></dl>

</div>
</div>
<a id="ga4e80d9644d060fdb10194d63d439e5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e80d9644d060fdb10194d63d439e5d6">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_SetMCLKFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_SetMCLKFrequency </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>freq_khz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq_khz</td><td>Required MCLK frequency value in kHz.<br />
 <b>Range:</b> XMC11/XMC12/XMC13 Device: 125 to 32000. XMC14 Device: 188 to 48000 when DCO1 is clock source for clock control unit. 79 to 48000 when OSC_HP is clock source for clock control unit.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>This API configures main clock (MCLK) frequency to requested frequency value.<br />
<br />
The API configures main clock by setting <em>IDIV</em> and <em>FDIV</em> bit's of the <em>CLKCR</em> register for XMC11/XMC12/XMC13/XMC14 Device and with additional <em>FDIV</em> bit (FDIV[9:8]) of the <em>CLKCR1</em> register settings for XMC14 device. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga66a7775d9fe9ee50a3936bd1abf20733">XMC_SCU_CLOCK_ScaleMCLKFrequency()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga702904d10b6e6c6a55db381763fd322f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga702904d10b6e6c6a55db381763fd322f">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_UngatePeripheralClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_UngatePeripheralClock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a>&#160;</td>
          <td class="paramname"><em>peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>The peripheral for which the clock has to be ungated. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga29713150fdafc3c88f3c73f621410239">XMC_SCU_PERIPHERAL_CLOCK_t</a> to identify the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the supply of clock to the selected peripheral.<br />
<br />
By default when the device powers on, the peripheral clock will be gated for the peripherals that support clock gating. The peripheral clock should be enabled before using it for any functionality. fPCLK is the source of clock to various peripherals. Some peripherals support clock gate. Software can request for individual ungating of such peripheral clocks by setting respective bits in the <em>SCU_CGATCLR0</em> register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated()</a>, <a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga161d3851c3f1c11f90526a283a27b16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga161d3851c3f1c11f90526a283a27b16c">&#9670;&nbsp;</a></span>XMC_SCU_DisablePrefetchUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_DisablePrefetchUnit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function disables the Prefetch Unit (PFU). The purpose of the Prefetch unit is to reduce the Flash latency gap at higher system frequencies to increase the instruction per cycle performance.</p>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="ga3125df313f406750ec52080e3e6f50ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3125df313f406750ec52080e3e6f50ba">&#9670;&nbsp;</a></span>XMC_SCU_EnablePrefetchUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_EnablePrefetchUnit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function enables the Prefetch Unit (PFU). The purpose of the Prefetch unit is to reduce the Flash latency gap at higher system frequencies to increase the instruction per cycle performance.</p>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="ga25b1b16ac491c542ceffa20679c8e9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25b1b16ac491c542ceffa20679c8e9c6">&#9670;&nbsp;</a></span>XMC_SCU_GetBMI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_GetBMI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Current BMI value.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>This procedure initiates installation of a new BMI value. In particular, it can be used as well as to restore the state upon delivery for a device already in User Productive mode.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Switch to ASC Bootstrap Loader</span></div><div class="line">bmi_value = <a class="code" href="group___s_c_u.html#ga25b1b16ac491c542ceffa20679c8e9c6">XMC_SCU_GetBMI</a>();</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> ((bmi_value &amp; 0x000000ffU) != XMC_SCU_BMI_HWCFG_ASC)</div><div class="line">{</div><div class="line">  <a class="code" href="group___s_c_u.html#gaf5e684d3534fefaad8787c241f54c310">XMC_SCU_SetBMI</a>(XMC_SCU_BMI_HWCFG_ASC, 0);</div><div class="line">}</div></div><!-- fragment --> <p>&lt; Boot Mode Index (BMI) address holding information about start-up mode and debug configuration of the device. </p>

</div>
</div>
<a id="ga494b75a841498374cfee9664e6ce9cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga494b75a841498374cfee9664e6ce9cee">&#9670;&nbsp;</a></span>XMC_SCU_GetMirrorStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_GetMirrorStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Status of the register mirror update.<br />
 <b>Range:</b> Use the bit mask of the SCU_GENERAL_MIRRSTS register for the mirror update event of interest. e.g.: SCU_GENERAL_MIRRSTS_RTC_CTR_Msk. Multiple update events can be combined using <em>OR</em> operation.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the status of hibernate domain register update, when the respective mirror registers are changed. <br />
<br />
The hibernate domain is connected to the core domain via SPI serial communication. MIRRSTS is a status register representing the communication of changed value of a mirror register to its corresponding register in the hibernate domain. The bit fields of the register indicate that a corresponding register of the hibernate domain is ready to accept a write or that the communication interface is busy with executing the previous operation.<br />
Note: There is no hibernate domain in XMC1x devices. This register is retained for legacy purpose. </dd></dl>

</div>
</div>
<a id="ga71c4f02eb6036f0d3a13af5e10bf56cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71c4f02eb6036f0d3a13af5e10bf56cc">&#9670;&nbsp;</a></span>XMC_SCU_GetTemperature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_GetTemperature </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Raw die temperature value. <b>Range:</b> 16 bit value.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the raw die temperature value.<br />
<br />
The API reads temperature measurement result from <em>SCU_ANALOG-&gt;ANATSEMON</em> bit fields. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3b00187ccda526f06802152ecf199fa4">XMC_SCU_StartTempMeasurement()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga5a0ad9c467d9549542d0f0275bae6314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a0ad9c467d9549542d0f0275bae6314">&#9670;&nbsp;</a></span>XMC_SCU_HighTemperature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_HighTemperature </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>bool Result of checking whether the die temperature is more than the upper threshold.<br />
 <b>Range:</b> <em>false</em> if temperature is below the upper threshold. <em>true</em> if temperature has exceeded the upper threshold configured in <em>ANATSEIH</em> register.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Check if the temperature has exceeded the upper threshold value.<br />
<br />
The API checks for <em>TSE_HIGH</em> bit (TSE Compare High Temperature Event Status bit) of <em>SRRAW</em> register. The bit will be set when the <em>TSE_MON</em> value in <em>ANATSEMON</em> register exceeds the value of <em>TSE_IH</em> value in <em>ANATSEIH</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3b00187ccda526f06802152ecf199fa4">XMC_SCU_StartTempMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga0f600fa31f024ec9d8e0c17fc767772f">XMC_SCU_SetRawTempLimits()</a>, <a class="el" href="group___s_c_u.html#ga71c4f02eb6036f0d3a13af5e10bf56cc">XMC_SCU_GetTemperature()</a>, <a class="el" href="group___s_c_u.html#ga8573534003ebf11fbaa49e331238fb86">XMC_SCU_LowTemperature()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gabd2e577339ff5af48261d18e0e41dc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd2e577339ff5af48261d18e0e41dc50">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_ClearEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_ClearEventStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bit mask of the events to clear. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> for providing the input value. Multiple events can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the event status bit in SRRAW register.<br />
<br />
The events are cleared by writing value 1 to their bit positions in the SRCLR register. The API can be used when polling method is used. After detecting the event, the event status should be cleared using software to detect the event again.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gae23dfad3e5e11c78791e5d5a777c44a8">XMC_SCU_INTERUPT_GetEventStatus()</a>, <a class="el" href="group___s_c_u.html#gaa55b2098ce803174e7dfd680d0c30728">XMC_SCU_INTERRUPT_TriggerEvent()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gaa814678729d6b7f41c558e768ba8ecd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa814678729d6b7f41c558e768ba8ecd4">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_DisableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_DisableEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bit mask of the event to disable. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> for providing the input value. Multiple events can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables generation of interrupt on occurrence of the input event.<br />
<br />
The events are disabled by resetting the respective bit fields in the SRMSK register. <br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>NVIC_DisableIRQ(), <a class="el" href="group___s_c_u.html#gab4cfb9545d1e561e1f24aeaa69af821c">XMC_SCU_INTERRUPT_EnableEvent()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gab4cfb9545d1e561e1f24aeaa69af821c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4cfb9545d1e561e1f24aeaa69af821c">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EnableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_EnableEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bit mask of the event to enable. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> for providing the input value. Multiple events can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the generation of interrupt for the input events.<br />
<br />
The events are enabled by setting the respective bit fields in the SRMSK register. <br />
Note: User should separately enable the NVIC node responsible for handling the SCU interrupt. The interrupt will be generated when the respective event occurs. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>NVIC_EnableIRQ(), <a class="el" href="group___s_c_u.html#gaa814678729d6b7f41c558e768ba8ecd4">XMC_SCU_INTERRUPT_DisableEvent()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga4ae03c6bcc3ccade266b46d84f7715e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ae03c6bcc3ccade266b46d84f7715e6">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_SetEventHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a> XMC_SCU_INTERRUPT_SetEventHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga4b50170c441fb21833c07a27b814a581">XMC_SCU_INTERRUPT_EVENT_HANDLER_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event for which the interrupt handler is to be configured. <br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> for identifying the event. </td></tr>
    <tr><td class="paramname">handler</td><td>Name of the function to be executed when the event if detected. <br />
 <b>Range:</b> The function accepts no arguments and returns no value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_SCU_STATUS_t Status of configuring the event handler function for the selected event.<br />
 <b>Range:</b> <em>XMC_SCU_STATUS_OK</em> if the event handler is successfully configured.<br />
 <em>XMC_SCU_STATUS_ERROR</em> if the input event is invalid.<br />
</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Assigns the event handler function to be executed on occurrence of the selected event.<br />
<br />
If the input event is valid, the handler function will be assigned to a table to be executed when the interrupt is generated and the event status is set in the event status register. By using this API, polling for a particular event can be avoided. This way the CPU utilization will be optimized. Multiple SCU events can generate a common interrupt. When the interrupt is generated, a common interrupt service routine is executed. It checks for status flags of events which can generate the interrupt. The handler function will be executed if the event flag is set.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaa55b2098ce803174e7dfd680d0c30728">XMC_SCU_INTERRUPT_TriggerEvent()</a>, <a class="el" href="group___s_c_u.html#gae23dfad3e5e11c78791e5d5a777c44a8">XMC_SCU_INTERUPT_GetEventStatus()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gaa55b2098ce803174e7dfd680d0c30728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa55b2098ce803174e7dfd680d0c30728">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_TriggerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_TriggerEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bit mask of the event to be triggered. <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> for providing the input value. Multiple events can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Triggers the event as if the hardware raised it.<br />
<br />
Event will be triggered by setting the respective bitfield in the SRSET register.<br />
Note: User should enable the NVIC node that handles the respective event for interrupt generation. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>NVIC_EnableIRQ(), <a class="el" href="group___s_c_u.html#gae23dfad3e5e11c78791e5d5a777c44a8">XMC_SCU_INTERUPT_GetEventStatus()</a>, <a class="el" href="group___s_c_u.html#gabd2e577339ff5af48261d18e0e41dc50">XMC_SCU_INTERRUPT_ClearEventStatus()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gae23dfad3e5e11c78791e5d5a777c44a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae23dfad3e5e11c78791e5d5a777c44a8">&#9670;&nbsp;</a></span>XMC_SCU_INTERUPT_GetEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a> XMC_SCU_INTERUPT_GetEventStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Status of the SCU events.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the status of all SCU events.<br />
<br />
The status is read from the SRRAW register. To check the status of a particular event, the returned value should be masked with the bit mask of the event. The bitmask of events can be obtained using the type <a class="el" href="group___s_c_u.html#ga18e68742408210603bed8d0806ce1573">XMC_SCU_INTERRUPT_EVENT_t</a>. Multiple events' status can be checked by combining the bit masks using <em>OR</em> operation. After detecting the event, the event status should be cleared using software to detect the event again. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gabd2e577339ff5af48261d18e0e41dc50">XMC_SCU_INTERRUPT_ClearEventStatus()</a>, <a class="el" href="group___s_c_u.html#gaa55b2098ce803174e7dfd680d0c30728">XMC_SCU_INTERRUPT_TriggerEvent()</a>, <a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga9ba1ce317ce89edfea107893fbd8a0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ba1ce317ce89edfea107893fbd8a0be">&#9670;&nbsp;</a></span>XMC_SCU_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_IRQHandler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sr_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sr_num</td><td>Service request number identifying the SCU interrupt generated.<br />
 <b>Range:</b> 0 to 2. XMC4x devices have one common SCU interrupt, so the value should be 0.<br />
 But XMC1x devices support 3 interrupt nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
<dl class="section user"><dt>Description</dt><dd>A common function to execute callback functions for multiple events.<br />
<br />
It checks for the status of events which can generate the interrupt with the selected service request. If the event is set, the corresponding callback function will be executed. It also clears the event status bit.<br />
<b>Note:</b> This is an internal function. It should not be called by the user application.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga370ea6fa8641ab74386314bbaa6ffb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga370ea6fa8641ab74386314bbaa6ffb44">&#9670;&nbsp;</a></span>XMC_SCU_IsTempMeasurementDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_IsTempMeasurementDone </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true DTS Measurement Done </dd>
<dd>
false DTS Measurement not Done</dd></dl>
<dl class="section user"><dt>Description</dt><dd>This functions checks the status of the DTS Measurement completion.<br />
<br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3b00187ccda526f06802152ecf199fa4">XMC_SCU_StartTempMeasurement()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gad9ba5dce219ea8390f4aa9f7bc46aafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9ba5dce219ea8390f4aa9f7bc46aafe">&#9670;&nbsp;</a></span>XMC_SCU_LockProtectedBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_LockProtectedBits </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Locks access to protected bit fields of the SCU.<br />
<br />
The bit protection scheme prevents changing selected register bits by unauthorized code. Bit protection scheme is enabled by writing 000000C3H to <em>PASSWD</em> register. By writing this value, the API is setting the <em>MODE</em> bit field to bit protection enabled state.<br />
List of Protected Register Bit Fields are mentioned below. <br />
<table class="doxtable">
<tr>
<td><em>Register</em>  </td><td><em>Bit</em> fields  </td></tr>
<tr>
<td>SCU_CLKCR  </td><td>FDIV, IDIV, PCLKSEL, RTCLKSEL  </td></tr>
<tr>
<td>SCU_CGATSET0  </td><td>All bits  </td></tr>
<tr>
<td>SCU_CGATCLR0  </td><td>All bits  </td></tr>
<tr>
<td>SCU_ANAOFFSET  </td><td>ADJL_OFFSET  </td></tr>
<tr>
<td>VADC0_ACCPROT0  </td><td>All bits  </td></tr>
<tr>
<td>VADC0_ACCPROT1  </td><td>All bits  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaf60632360634a2f1be0f8af715c03dea">XMC_SCU_UnlockProtectedBits()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga8573534003ebf11fbaa49e331238fb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8573534003ebf11fbaa49e331238fb86">&#9670;&nbsp;</a></span>XMC_SCU_LowTemperature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_LowTemperature </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>bool Result of checking whether the die temperature is less than the lower threshold.<br />
 <b>Range:</b> <em>false</em> if temperature is higher than the lower threshold. <em>true</em> if temperature has dropped below the lower threshold configured in <em>ANATSEIL</em> register.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Check if the temperature has dropped below the lower threshold value.<br />
<br />
The API checks for <em>TSE_LOW</em> bit (TSE Compare Low Temperature Event Status bit) of <em>SRRAW</em> register. The bit will be set when the <em>TSE_MON</em> value in <em>ANATSEMON</em> register drops below the value of <em>TSE_IL</em> value in <em>ANATSEIL</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3b00187ccda526f06802152ecf199fa4">XMC_SCU_StartTempMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga0f600fa31f024ec9d8e0c17fc767772f">XMC_SCU_SetRawTempLimits()</a>, <a class="el" href="group___s_c_u.html#ga71c4f02eb6036f0d3a13af5e10bf56cc">XMC_SCU_GetTemperature()</a>, <a class="el" href="group___s_c_u.html#ga5a0ad9c467d9549542d0f0275bae6314">XMC_SCU_HighTemperature()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga4105a1ad04e87b7ca5ec0c88242ed991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4105a1ad04e87b7ca5ec0c88242ed991">&#9670;&nbsp;</a></span>XMC_SCU_POWER_DisableMonitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_POWER_DisableMonitor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables VDEL detector </dd></dl>

</div>
</div>
<a id="gabff55cce9dfcad7e04e6de5f3d352978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabff55cce9dfcad7e04e6de5f3d352978">&#9670;&nbsp;</a></span>XMC_SCU_POWER_EnableMonitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_POWER_EnableMonitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_c_u.html#ga985038b59c5bc1d8341db06c6c7cbfdc">XMC_SCU_POWER_MONITOR_RANGE_t</a>&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_c_u.html#gaae067899a6cfa605f5ebfef2c1f8d393">XMC_SCU_POWER_MONITOR_DELAY_t</a>&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>VDEL Range Select <a class="el" href="group___s_c_u.html#ga985038b59c5bc1d8341db06c6c7cbfdc">XMC_SCU_POWER_MONITOR_RANGE_t</a> </td></tr>
    <tr><td class="paramname">delay</td><td>VDEL Timing Setting <a class="el" href="group___s_c_u.html#gaae067899a6cfa605f5ebfef2c1f8d393">XMC_SCU_POWER_MONITOR_DELAY_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables VDEL detector. VDEL detector compares the supply voltage against a pre-warning threshold voltage</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Brown Out Trap need to be enabled previously </dd></dl>

</div>
</div>
<a id="ga77c6ab2add788e4bd31eb563e0f8f8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77c6ab2add788e4bd31eb563e0f8f8b1">&#9670;&nbsp;</a></span>XMC_SCU_RESET_AssertMasterReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_RESET_AssertMasterReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Trigger device master reset.<br />
<br />
The API triggers master reset by setting the <em>MRSTEN</em> bit of <em>RSTCON</em> register. It also internally triggers system reset. Almost all the logics of the device are affected by this reset. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaa4dbbfd3a9346cc7eb84bda46d084607">XMC_SCU_RESET_EnableResetRequest()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga4bf9396e8b46be98f73999575d13bf6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bf9396e8b46be98f73999575d13bf6d">&#9670;&nbsp;</a></span>XMC_SCU_RESET_ClearDeviceResetReason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_RESET_ClearDeviceResetReason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the reset reason bits in the reset status register. <br />
<br />
Clearing of the reset status information in the <em>SCU_RSTSTAT</em> register via register bit <em>RSTCLR.RSCLR</em> is strongly recommended to ensure a clear indication of the cause of next reset.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3f779c81bdc29b44c644017a52aff300">XMC_SCU_RESET_GetDeviceResetReason()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gaa4dbbfd3a9346cc7eb84bda46d084607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4dbbfd3a9346cc7eb84bda46d084607">&#9670;&nbsp;</a></span>XMC_SCU_RESET_EnableResetRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_RESET_EnableResetRequest </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>Reset source to trigger the device reset.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga4988413b7da85ed020b8d1a8243e28aa">XMC_SCU_SYSTEM_RESET_REQUEST_t</a> to identify the reset source.<br />
 XMC_SCU_RESET_REQUEST_FLASH_ECC_ERROR- Reset when flash memory double bit error is detected.<br />
 XMC_SCU_RESET_REQUEST_CLOCK_LOSS- Reset when loss of clock is detected.<br />
 XMC_SCU_RESET_REQUEST_SRAM_PARITY_ERROR- Reset when SRAM parity error is detected.<br />
 XMC_SCU_RESET_REQUEST_USIC_SRAM_PARITY_ERROR- Reset when USIC0 SRAM parity error is detected.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures trigger for system reset from the selected source.<br />
<br />
The API configures the reset source specific bit in the <em>RSTCON</em> register. Multiple reset sources can be combined using <em>OR</em> operation. By enabling the reset using this API will not trigger the reset. The reset will happen when the configured source event is detected. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga77c6ab2add788e4bd31eb563e0f8f8b1">XMC_SCU_RESET_AssertMasterReset()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga3f779c81bdc29b44c644017a52aff300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f779c81bdc29b44c644017a52aff300">&#9670;&nbsp;</a></span>XMC_SCU_RESET_GetDeviceResetReason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_RESET_GetDeviceResetReason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Status representing the reason for device reset.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the value representing the reason for device reset.<br />
<br />
The return value is an encoded word, which can indicate multiple reasons for the last reset. Each bit position of the returned word is representative of a last reset cause. The returned value should be appropriately masked to check the cause of reset. The cause of the last reset gets automatically stored in the <em>SCU_RSTSTAT</em> register. The reset status shall be reset after each startup in order to ensure consistent source indication after the next reset. <b>Range:</b> The type <a class="el" href="group___s_c_u.html#gae01c08f5d524dadbc6e0c4128b348dc3">XMC_SCU_RESET_REASON_t</a> can be used to get the bit masks of the reset cause.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga4bf9396e8b46be98f73999575d13bf6d">XMC_SCU_RESET_ClearDeviceResetReason()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gaf5e684d3534fefaad8787c241f54c310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5e684d3534fefaad8787c241f54c310">&#9670;&nbsp;</a></span>XMC_SCU_SetBMI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_SetBMI </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>may be any of: <br />
 <a class="el" href="group___s_c_u.html#gaccc3853c66324f7c0f2ff6e5c260d38d">XMC_SCU_BMI_HWCFG_CAN_BSL</a> (only available for XMC1400 series with CAN Module)<br />
 <a class="el" href="group___s_c_u.html#ga2218430a09e0824a83c23c626ed1668b">XMC_SCU_BMI_HWCFG_CAN_BSLTO</a> (only available for XMC1400 series with CAN Module)<br />
 <a class="el" href="group___s_c_u.html#ga6ad45fc801302e2ce9583aba0ffe58e0">XMC_SCU_BMI_HWCFG_SBSL_CANOPEN</a> (only available for XMC1400 series with CAN Module)<br />
 <a class="el" href="group___s_c_u.html#ga7f00e1b1262b3eab4b98353a06673c3b">XMC_SCU_BMI_HWCFG_ASC_BSL<br />
</a> <a class="el" href="group___s_c_u.html#ga3ab345ab24ec81394d45deeb874f3d5d">XMC_SCU_BMI_HWCFG_UPM<br />
</a> <a class="el" href="group___s_c_u.html#ga397fae0a8dfbdfb975010cbb94a8bb42">XMC_SCU_BMI_HWCFG_UMD<br />
</a> <a class="el" href="group___s_c_u.html#gaf42b9eea5286aec14668d952527be70e">XMC_SCU_BMI_HWCFG_UMHAR<br />
</a> <a class="el" href="group___s_c_u.html#ga88de483723947ca91ce5d5bfd1b89a51">XMC_SCU_BMI_HWCFG_SSC_BSL<br />
</a> <a class="el" href="group___s_c_u.html#ga0d1b90b10b5672ffe1a3b38f7bbc81b8">XMC_SCU_BMI_HWCFG_ASC_BSLTO<br />
</a> <a class="el" href="group___s_c_u.html#ga442aa39ffc3bcc290964bf9c04a558ef">XMC_SCU_BMI_HWCFG_SSC_BSLTO<br />
</a> <a class="el" href="group___s_c_u.html#gacf41aeb0d9c158e1ae9bd34906ddab27">XMC_SCU_BMI_HWCFG_SBSL<br />
</a><br />
 optionally OR'd together with any of (only available for XMC1400 series): <br />
 <a class="el" href="group___s_c_u.html#ga56ed923f3d9fe179cec0b4c187d0d4c6">XMC_SCU_BMI_HWCFG_PINDIS</a> optionally OR'd together with any of: <br />
 <a class="el" href="group___s_c_u.html#ga8b090323ebddb3615f33e806b23b1d02">XMC_SCU_BMI_DAPTYP_SWD<br />
</a> <a class="el" href="group___s_c_u.html#gaf08ce8782ed3f2501f91d39847e55086">XMC_SCU_BMI_DAPTYP_SPD<br />
</a><br />
 optionally OR'd together with any of: <br />
 <a class="el" href="group___s_c_u.html#ga02558dc388806845c40f83ba2f8f87cd">XMC_SCU_BMI_DAPDIS_CHANNEL_0<br />
</a> <a class="el" href="group___s_c_u.html#ga4863740cd6d84afcfc0d01685f6d3afd">XMC_SCU_BMI_DAPDIS_CHANNEL_1<br />
</a><br />
 <div class="image">
<img src="xmc1000_debugif.png" alt="xmc1000_debugif.png"/>
</div>
 optionally OR'd together with any of (only available for XMC1400 series with CAN Module): <br />
 <a class="el" href="group___s_c_u.html#ga8eda1a0078fb1dc13593680dcc4c1886">XMC_SCU_BMI_CANCLK_DCO1<br />
</a> <a class="el" href="group___s_c_u.html#ga7cb50fbefee333f0aa9bb1a5d510d6e7">XMC_SCU_BMI_CANCLK_OSCHP<br />
</a><br />
</td></tr>
    <tr><td class="paramname">timeout</td><td>Only relevant if a start up mode is selected that uses timeout. The time-out duration is BSLTO*2664000 MCLK cycles, the supported time-out range is 0.3-5s (333...4995ms) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false only upon error, if OK the procedure triggers a reset and does not return to calling routine</dd></dl>
<dl class="section user"><dt>Description</dt><dd>This procedure initiates installation of a new BMI value. In particular, it can be used as well as to restore the state upon delivery for a device already in User Productive mode.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Switch to ASC Bootstrap Loader</span></div><div class="line"><a class="code" href="group___s_c_u.html#gaf5e684d3534fefaad8787c241f54c310">XMC_SCU_SetBMI</a>(<a class="code" href="group___s_c_u.html#ga7f00e1b1262b3eab4b98353a06673c3b">XMC_SCU_BMI_HWCFG_ASC_BSL</a>, 0);</div><div class="line"></div><div class="line"><span class="comment">// Switch to Debug user mode SWD1 (pins P1.3 and P1.2)</span></div><div class="line"><a class="code" href="group___s_c_u.html#gaf5e684d3534fefaad8787c241f54c310">XMC_SCU_SetBMI</a>(<a class="code" href="group___s_c_u.html#ga397fae0a8dfbdfb975010cbb94a8bb42">XMC_SCU_BMI_HWCFG_UMD</a> | <a class="code" href="group___s_c_u.html#ga8b090323ebddb3615f33e806b23b1d02">XMC_SCU_BMI_DAPTYP_SWD</a> | <a class="code" href="group___s_c_u.html#ga4863740cd6d84afcfc0d01685f6d3afd">XMC_SCU_BMI_DAPDIS_CHANNEL_1</a>, 0);</div></div><!-- fragment --> 
</div>
</div>
<a id="gac10ca2cd72477476ffe38a4818bcae4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac10ca2cd72477476ffe38a4818bcae4b">&#9670;&nbsp;</a></span>XMC_SCU_SetCcuTriggerHigh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_SetCcuTriggerHigh </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>trigger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>CCU slices to be triggered synchronously via software. The value is a bitmask of CCU slice bits in the register CCUCON. <br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga51850699f03c906a5fefcc4f04c6b2c1">XMC_SCU_CCU_TRIGGER_t</a> for bitmask of individual CCU slices. Multiple slices can be combined using <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Generates active edge(low to high) trigger for multiple CCU units at the same time.<br />
<br />
Before executing this API, all the required CCU timers should configure external start. The edge of the start signal should be selected as active edge. The input signal for the CCU slice should be selected as SCU input. The above mentioned configurations can be made using the CCU LLD API <a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig()</a>. CCU timer slice should be started using <a class="el" href="group___c_c_u4.html#ga9997bb59706a4034e3e3be33a4935a7c">XMC_CCU4_SLICE_StartTimer()</a> before triggering the timer using this API.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig()</a>, <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>, <a class="el" href="group___s_c_u.html#ga53300d587bbd03bc34c5a4396f5a34b9">XMC_SCU_SetCcuTriggerLow()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga53300d587bbd03bc34c5a4396f5a34b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53300d587bbd03bc34c5a4396f5a34b9">&#9670;&nbsp;</a></span>XMC_SCU_SetCcuTriggerLow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_SetCcuTriggerLow </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>trigger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>CCU slices to be triggered synchronously via software. The value is a bitmask of CCU slice bits in the register CCUCON. <br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#ga51850699f03c906a5fefcc4f04c6b2c1">XMC_SCU_CCU_TRIGGER_t</a> for bitmask of individual CCU slices. Multiple slices can be combined using <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Generates passive edge(high to low) trigger for multiple CCU units at the same time.<br />
<br />
Before executing this API, all the required CCU timers should configure external start. The edge of the start signal should be selected as passive edge. The input signal for the CCU slice should be selected as SCU input. The above mentioned configurations can be made using the CCU LLD API <a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig()</a>. CCU timer slice should be started using <a class="el" href="group___c_c_u4.html#ga9997bb59706a4034e3e3be33a4935a7c">XMC_CCU4_SLICE_StartTimer()</a> before triggering the timer using this API.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig()</a>, <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>, <a class="el" href="group___s_c_u.html#gac10ca2cd72477476ffe38a4818bcae4b">XMC_SCU_SetCcuTriggerHigh()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga6804b5ee7f0e08ee13d2863f1a35bdcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6804b5ee7f0e08ee13d2863f1a35bdcf">&#9670;&nbsp;</a></span>XMC_SCU_SetInterruptControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_SetInterruptControl </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>irq_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_c_u.html#gad54a1c90f3b35f4c49d62ac204678487">XMC_SCU_IRQCTRL_t</a>&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function selects service request source for a NVIC interrupt node. The XMC1400 series has up to 54 peripheral service requests. The Cortex M0 however has 32 interrupts available for peripherals. This function allows you to select which 32 peripheral requests of the 54 the CPU should react on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq_number</td><td>Interrupt number, 0 to 31 </td></tr>
    <tr><td class="paramname">source</td><td>Peripheral service request. See <a class="el" href="group___s_c_u.html#gad54a1c90f3b35f4c49d62ac204678487">XMC_SCU_IRQCTRL_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="ga0f600fa31f024ec9d8e0c17fc767772f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f600fa31f024ec9d8e0c17fc767772f">&#9670;&nbsp;</a></span>XMC_SCU_SetRawTempLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_SetRawTempLimits </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>lower_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>upper_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower_temp</td><td>Lower threshold value for the die temperature.<br />
 <b>Range:</b> 0 to 65535(16 bit unsigned value). </td></tr>
    <tr><td class="paramname">upper_temp</td><td>Upper threshold value for the die temperature.<br />
 <b>Range:</b> 0 to 65535(16 bit unsigned value).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Configures upper and lower thresholds of die temperature as raw digital values into temperature sensor.<br />
<br />
The API configures <em>ANATSEIH</em> and <em>ANATSEIL</em> registers for upper and lower die temperature threshold limits respectively.<br />
It is recommended to use following steps:<br />
<ul>
<li>Call <em>XMC_SCU_StopTempMeasurement</em> to stop temperature measurement if it was started previously.<br />
</li>
<li>Call <em>XMC_SCU_SetRawTempLimits</em> with desired lower and upper temperature threshold limit values.<br />
</li>
<li>Finally call <em>XMC_SCU_StartTempMeasurement</em> to start temperature measurement.<br />
 </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga5851b97d5f0830ba58eecc516a488db0">XMC_SCU_StopTempMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga3b00187ccda526f06802152ecf199fa4">XMC_SCU_StartTempMeasurement()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gacda844c46f28753e5698c9edf1da89c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacda844c46f28753e5698c9edf1da89c6">&#9670;&nbsp;</a></span>XMC_SCU_SetTempHighLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a> XMC_SCU_SetTempHighLimit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>Kelvin degree temperature higher compare limit in range [233,388] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_SCU_STATUS_t status of limit installation</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Set higher temperature compare limit. A high temperature interrupt (SCU_IRQ1) is triggered if Tchip &gt; limit and the event and interrupt are enabled. Alternatively <a class="el" href="group___s_c_u.html#ga5a0ad9c467d9549542d0f0275bae6314">XMC_SCU_HighTemperature()</a> can be used to check the status. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga5a0ad9c467d9549542d0f0275bae6314">XMC_SCU_HighTemperature()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga9075804b25596f546110b908fbcb7957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9075804b25596f546110b908fbcb7957">&#9670;&nbsp;</a></span>XMC_SCU_SetTempLowLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a> XMC_SCU_SetTempLowLimit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>Kelvin degree temperature lower compare limit in range [233,388] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_SCU_STATUS_t status of limit installation</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Set lower temperature compare limit. A low temperature interrupt (SCU_IRQ1) is triggered if Tchip &lt; limit and the event and interrupt are enabled. Alternatively <a class="el" href="group___s_c_u.html#ga8573534003ebf11fbaa49e331238fb86">XMC_SCU_LowTemperature()</a> can be used to check the status. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga8573534003ebf11fbaa49e331238fb86">XMC_SCU_LowTemperature()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga3b00187ccda526f06802152ecf199fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b00187ccda526f06802152ecf199fa4">&#9670;&nbsp;</a></span>XMC_SCU_StartTempMeasurement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_StartTempMeasurement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>XMC_SCU_STATUS_t Status of starting the temperature measurement.<br />
 <b>Range:</b> Use type <a class="el" href="group___s_c_u.html#gaff029b1575acc0712d494932d8ca6d60">XMC_SCU_STATUS_t</a> to identify the result.<br />
 XMC_SCU_STATUS_OK- Temperature measurement started successfully.<br />
 Always returns the above status.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Starts die temperature measurement using internal temperature sensor.<br />
<br />
The API, enables die temperature measurement and waits for about 10000 cycles until temperature measurement result is available on <em>SCU_ANALOG-&gt;ANATSEMON</em> bit fields.<br />
It is recommended to use following steps:<br />
<ul>
<li>Call <em>XMC_SCU_StopTempMeasurement</em> to stop temperature measurement if it was started previously.<br />
</li>
<li>Call <em>XMC_SCU_SetRawTempLimits</em> with desired lower and upper temperature threshold limit values if it is needed.<br />
</li>
<li>Call <em>XMC_SCU_StartTempMeasurement</em> to start temperature measurement.<br />
</li>
<li>Read die temperature value using <em>XMC_SCU_GetTemperature</em> API.<br />
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga5851b97d5f0830ba58eecc516a488db0">XMC_SCU_StopTempMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga0f600fa31f024ec9d8e0c17fc767772f">XMC_SCU_SetRawTempLimits()</a>, <a class="el" href="group___s_c_u.html#ga71c4f02eb6036f0d3a13af5e10bf56cc">XMC_SCU_GetTemperature()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga5851b97d5f0830ba58eecc516a488db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5851b97d5f0830ba58eecc516a488db0">&#9670;&nbsp;</a></span>XMC_SCU_StopTempMeasurement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_StopTempMeasurement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Stops the die temperature measurement.<br />
<br />
Die temperature measurement is stopped by disabling the sensor using <em>TSE_EN</em> bit of <em>ANATSECTRL</em> register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga3b00187ccda526f06802152ecf199fa4">XMC_SCU_StartTempMeasurement()</a>, <a class="el" href="group___s_c_u.html#ga0f600fa31f024ec9d8e0c17fc767772f">XMC_SCU_SetRawTempLimits()</a>, <a class="el" href="group___s_c_u.html#ga71c4f02eb6036f0d3a13af5e10bf56cc">XMC_SCU_GetTemperature()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gab79580e5b6decc4f6ecce14be9efe17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab79580e5b6decc4f6ecce14be9efe17d">&#9670;&nbsp;</a></span>XMC_SCU_SupplyMonitorInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_SupplyMonitorInit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___s_c_u___s_u_p_p_l_y_m_o_n_i_t_o_r__t.html">XMC_SCU_SUPPLYMONITOR_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to data structure consisting voltage monitoring block configuration.<br />
 <b>Range:</b> Use type <a class="el" href="struct_x_m_c___s_c_u___s_u_p_p_l_y_m_o_n_i_t_o_r__t.html">XMC_SCU_SUPPLYMONITOR_t</a> for detailed description of structure members.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Initializes power supply monitoring unit.<br />
<br />
Supply voltage monitoring block consist of 2 detectors namely External voltage detector (VDEL) and External brownout detector (BDE) in the EVR that are used to monitor the VDDP. <em>VDEL</em> detector compares the supply voltage against a pre-warning threshold voltage <em>ext_supply_threshold</em>. The threshold level is programmable via register <em>ANAVDEL.VDEL_SELECT</em>. An interrupt if enabled via <em>enable_prewarning_int</em>, will be triggered if a level below this threshold is detected and the flag, VDDPI, in SRRAW register bit is set. Similarly interrupts can be enabled for the events of VCLIP and prewarning, using the structure members, <em>enable_vclip_int</em> and <em>enable_prewarning_int</em>. The handlers for these interrupts have to be explicitly defined using the API <a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a>. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gaf60632360634a2f1be0f8af715c03dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf60632360634a2f1be0f8af715c03dea">&#9670;&nbsp;</a></span>XMC_SCU_UnlockProtectedBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_UnlockProtectedBits </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Unlocks access to protected bit fields of the SCU.<br />
<br />
The bit protection scheme prevents changing selected register bits by unauthorized code. Bit protection scheme can be temporarily(for 32 MCLK cycles) disabled by writing 000000C0H to <em>PASSWD</em> register. By writing this value, the API is setting the <em>MODE</em> bit field to bit protection disabled state. The API waits for the protection to be disabled after changing the <em>MODE</em>.<br />
User can change the values of the protected bit fields within 32 MCLK cycles. After 32 MCLK cycles the lock will be enabled automatically. List of Protected Register Bit Fields are mentioned below. <br />
<table class="doxtable">
<tr>
<td><em>Register</em>  </td><td><em>Bit</em> fields  </td></tr>
<tr>
<td>SCU_CLKCR  </td><td>FDIV, IDIV, PCLKSEL, RTCLKSEL  </td></tr>
<tr>
<td>SCU_CGATSET0  </td><td>All bits  </td></tr>
<tr>
<td>SCU_CGATCLR0  </td><td>All bits  </td></tr>
<tr>
<td>SCU_ANAOFFSET  </td><td>ADJL_OFFSET  </td></tr>
<tr>
<td>VADC0_ACCPROT0  </td><td>All bits  </td></tr>
<tr>
<td>VADC0_ACCPROT1  </td><td>All bits  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gad9ba5dce219ea8390f4aa9f7bc46aafe">XMC_SCU_LockProtectedBits()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>XMC Peripheral Library for XMC1000 Family</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
