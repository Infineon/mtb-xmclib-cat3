<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XMC Peripheral Library for XMC4000 Family: FLASH</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC4000 Family
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FLASH<div class="ingroups"><a class="el" href="group___x_m_clib.html">XMC Peripheral Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___f_l_a_s_h___b_m_i___s_t_r_i_n_g__t.html">XMC_FLASH_BMI_STRING_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga8df033b692c14fc7d3e2da10906100f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga8df033b692c14fc7d3e2da10906100f2">XMC_FLASH_BMI_VALID</a>&#160;&#160;&#160;(uint32_t)(0x1 &lt;&lt; 31)</td></tr>
<tr class="separator:ga8df033b692c14fc7d3e2da10906100f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00b2a643c63a3ce66dc6fd2fb9ba5508"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga00b2a643c63a3ce66dc6fd2fb9ba5508">XMC_FLASH_BYTES_PER_PAGE</a>&#160;&#160;&#160;(256UL)</td></tr>
<tr class="separator:ga00b2a643c63a3ce66dc6fd2fb9ba5508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bdfc650939db3a1a2f3b726a7d3dd65"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga6bdfc650939db3a1a2f3b726a7d3dd65">XMC_FLASH_BYTES_PER_UCB</a>&#160;&#160;&#160;(1024UL)</td></tr>
<tr class="separator:ga6bdfc650939db3a1a2f3b726a7d3dd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd791228246106acb5a4ef1e4e461a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gafbd791228246106acb5a4ef1e4e461a9">XMC_FLASH_PHY_SECTOR_0</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x00000UL)</td></tr>
<tr class="separator:gafbd791228246106acb5a4ef1e4e461a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e30d54d3370336f77feac2d57b110a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga45e30d54d3370336f77feac2d57b110a">XMC_FLASH_PHY_SECTOR_10</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x80000UL)</td></tr>
<tr class="separator:ga45e30d54d3370336f77feac2d57b110a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7dd723484e1e0e3360cc51ad0e308e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gad7dd723484e1e0e3360cc51ad0e308e4">XMC_FLASH_PHY_SECTOR_11</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0xC0000UL)</td></tr>
<tr class="separator:gad7dd723484e1e0e3360cc51ad0e308e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga370dcfbf663969ac3756656a3d49213d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga370dcfbf663969ac3756656a3d49213d">XMC_FLASH_PHY_SECTOR_12</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x100000UL)</td></tr>
<tr class="separator:ga370dcfbf663969ac3756656a3d49213d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb253cfe200cf1ca2d6e4c34a44fd0d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gadb253cfe200cf1ca2d6e4c34a44fd0d6">XMC_FLASH_PHY_SECTOR_13</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x140000UL)</td></tr>
<tr class="separator:gadb253cfe200cf1ca2d6e4c34a44fd0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf5fbc662ade44ac1bc4a9285c595e75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gadf5fbc662ade44ac1bc4a9285c595e75">XMC_FLASH_PHY_SECTOR_14</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x180000UL)</td></tr>
<tr class="separator:gadf5fbc662ade44ac1bc4a9285c595e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b7aec6b448fb88de839ca66c3d0e1f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga0b7aec6b448fb88de839ca66c3d0e1f5">XMC_FLASH_PHY_SECTOR_15</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x1C0000UL)</td></tr>
<tr class="separator:ga0b7aec6b448fb88de839ca66c3d0e1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b6e3af93c4317f421eac4cc799f10f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga0b6e3af93c4317f421eac4cc799f10f7">XMC_FLASH_PHY_SECTOR_4</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x10000UL)</td></tr>
<tr class="separator:ga0b6e3af93c4317f421eac4cc799f10f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac37d4f679fd2f43ed259c616a6fe08e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gac37d4f679fd2f43ed259c616a6fe08e6">XMC_FLASH_PHY_SECTOR_8</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x20000UL)</td></tr>
<tr class="separator:gac37d4f679fd2f43ed259c616a6fe08e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdc6738b38cbc3b2f203e92682f6f265"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gafdc6738b38cbc3b2f203e92682f6f265">XMC_FLASH_PHY_SECTOR_9</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x40000UL)</td></tr>
<tr class="separator:gafdc6738b38cbc3b2f203e92682f6f265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdbfbdab6a3d36ab2f9e1ee1d296666"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga7fdbfbdab6a3d36ab2f9e1ee1d296666">XMC_FLASH_SECTOR_0</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x00000UL)</td></tr>
<tr class="separator:ga7fdbfbdab6a3d36ab2f9e1ee1d296666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a3f75ecb1f70a0b0f2f2534e7743595"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga7a3f75ecb1f70a0b0f2f2534e7743595">XMC_FLASH_SECTOR_1</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x04000UL)</td></tr>
<tr class="separator:ga7a3f75ecb1f70a0b0f2f2534e7743595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2609331cf0c07d960289c90aa2540ef5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga2609331cf0c07d960289c90aa2540ef5">XMC_FLASH_SECTOR_10</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x80000UL)</td></tr>
<tr class="separator:ga2609331cf0c07d960289c90aa2540ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf27f7a69fc845c41cb2fadb29be3461c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gaf27f7a69fc845c41cb2fadb29be3461c">XMC_FLASH_SECTOR_11</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0xC0000UL)</td></tr>
<tr class="separator:gaf27f7a69fc845c41cb2fadb29be3461c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafedb23690cde72c6445364c917bdb4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gaafedb23690cde72c6445364c917bdb4c">XMC_FLASH_SECTOR_12</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x100000UL)</td></tr>
<tr class="separator:gaafedb23690cde72c6445364c917bdb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab30f8c17e561fa7dfebb97c274f5edd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gab30f8c17e561fa7dfebb97c274f5edd7">XMC_FLASH_SECTOR_13</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x140000UL)</td></tr>
<tr class="separator:gab30f8c17e561fa7dfebb97c274f5edd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2348a6f8c87a6c2a23dba200a3d1060"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gac2348a6f8c87a6c2a23dba200a3d1060">XMC_FLASH_SECTOR_14</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x180000UL)</td></tr>
<tr class="separator:gac2348a6f8c87a6c2a23dba200a3d1060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga446f520d18418bf9c97e351170ee8497"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga446f520d18418bf9c97e351170ee8497">XMC_FLASH_SECTOR_15</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x1C0000UL)</td></tr>
<tr class="separator:ga446f520d18418bf9c97e351170ee8497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24d9203529ee67a0385782a21746e355"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga24d9203529ee67a0385782a21746e355">XMC_FLASH_SECTOR_2</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x08000UL)</td></tr>
<tr class="separator:ga24d9203529ee67a0385782a21746e355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56cc0ee898652dedf49dca1e205b9ab6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga56cc0ee898652dedf49dca1e205b9ab6">XMC_FLASH_SECTOR_3</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x0C000UL)</td></tr>
<tr class="separator:ga56cc0ee898652dedf49dca1e205b9ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga213fa88eef76853c2fb28dc1d75c3943"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga213fa88eef76853c2fb28dc1d75c3943">XMC_FLASH_SECTOR_4</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x10000UL)</td></tr>
<tr class="separator:ga213fa88eef76853c2fb28dc1d75c3943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga981a5460f0ae8431f5211617d728d808"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga981a5460f0ae8431f5211617d728d808">XMC_FLASH_SECTOR_5</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x14000UL)</td></tr>
<tr class="separator:ga981a5460f0ae8431f5211617d728d808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e002ae0e153ca50cfa9275e45c93290"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga4e002ae0e153ca50cfa9275e45c93290">XMC_FLASH_SECTOR_6</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x18000UL)</td></tr>
<tr class="separator:ga4e002ae0e153ca50cfa9275e45c93290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77fc1d691d0724e4ba9130e50f706929"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga77fc1d691d0724e4ba9130e50f706929">XMC_FLASH_SECTOR_7</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x1C000UL)</td></tr>
<tr class="separator:ga77fc1d691d0724e4ba9130e50f706929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c38a3969c71b1e45b9aa670a125cd25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga9c38a3969c71b1e45b9aa670a125cd25">XMC_FLASH_SECTOR_8</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x20000UL)</td></tr>
<tr class="separator:ga9c38a3969c71b1e45b9aa670a125cd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0ad69cbc5554b96b9a7412069b9eb8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gaa0ad69cbc5554b96b9a7412069b9eb8f">XMC_FLASH_SECTOR_9</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x40000UL)</td></tr>
<tr class="separator:gaa0ad69cbc5554b96b9a7412069b9eb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9df78d7a8aca3cbf4c65ff5fd8be3149"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga9df78d7a8aca3cbf4c65ff5fd8be3149">XMC_FLASH_UCB0</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x0000UL)</td></tr>
<tr class="separator:ga9df78d7a8aca3cbf4c65ff5fd8be3149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45b304d0d3ac857cd573eeadb828fdbc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga45b304d0d3ac857cd573eeadb828fdbc">XMC_FLASH_UCB1</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x0400UL)</td></tr>
<tr class="separator:ga45b304d0d3ac857cd573eeadb828fdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d536c12335ec31ebb73bf67153c4f9b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga3d536c12335ec31ebb73bf67153c4f9b">XMC_FLASH_UCB2</a>&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x0800UL)</td></tr>
<tr class="separator:ga3d536c12335ec31ebb73bf67153c4f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95898df658a19493d8f4763d481cdd74"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a>&#160;&#160;&#160;(0x0C000000U)</td></tr>
<tr class="separator:ga95898df658a19493d8f4763d481cdd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8baf803359cd0c484bed4123ea4d8446"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga8baf803359cd0c484bed4123ea4d8446">XMC_FLASH_WORDS_PER_PAGE</a>&#160;&#160;&#160;(64UL)</td></tr>
<tr class="separator:ga8baf803359cd0c484bed4123ea4d8446"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga1366551fd3139133b486a1d77b4d8d42"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga1366551fd3139133b486a1d77b4d8d42">XMC_FLASH_BMI_t</a> </td></tr>
<tr class="separator:ga1366551fd3139133b486a1d77b4d8d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ef5e96ac5c0fd9dd006a9c3aead2a9d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga1ef5e96ac5c0fd9dd006a9c3aead2a9d">XMC_FLASH_EVENT_t</a> </td></tr>
<tr class="separator:ga1ef5e96ac5c0fd9dd006a9c3aead2a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffd9d28d3272304c791a90bac529a94e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gaffd9d28d3272304c791a90bac529a94e">XMC_FLASH_MARGIN_t</a> </td></tr>
<tr class="separator:gaffd9d28d3272304c791a90bac529a94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae606277a956ca47776797dc27ef58005"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gae606277a956ca47776797dc27ef58005">XMC_FLASH_PROTECTION_t</a> </td></tr>
<tr class="separator:gae606277a956ca47776797dc27ef58005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec69607b9daecffb4215faca73d02ebc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gaec69607b9daecffb4215faca73d02ebc">XMC_FLASH_STATUS_t</a> </td></tr>
<tr class="separator:gaec69607b9daecffb4215faca73d02ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab3972a9f18acaa900499351a4843ff38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gab3972a9f18acaa900499351a4843ff38">XMC_FLASH_ClearStatus</a> (void)</td></tr>
<tr class="separator:gab3972a9f18acaa900499351a4843ff38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc188832165a6d064bae5fb1cd4ecfb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gacc188832165a6d064bae5fb1cd4ecfb7">XMC_FLASH_ConfirmProtection</a> (uint8_t user)</td></tr>
<tr class="separator:gacc188832165a6d064bae5fb1cd4ecfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa6bd7da37dc5f4670a08aea375ec6e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gafa6bd7da37dc5f4670a08aea375ec6e7">XMC_FLASH_DisableDoubleBitErrorTrap</a> (void)</td></tr>
<tr class="separator:gafa6bd7da37dc5f4670a08aea375ec6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef58f59fcc0cb0100fe6c850bde4c13b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gaef58f59fcc0cb0100fe6c850bde4c13b">XMC_FLASH_DisableDynamicIdle</a> (void)</td></tr>
<tr class="separator:gaef58f59fcc0cb0100fe6c850bde4c13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga162346fadd0c8caacda1738259da404e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga162346fadd0c8caacda1738259da404e">XMC_FLASH_DisableEvent</a> (const uint32_t event_msk)</td></tr>
<tr class="separator:ga162346fadd0c8caacda1738259da404e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac41a20009e50458db00347f609f40d9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gac41a20009e50458db00347f609f40d9e">XMC_FLASH_DisableSleepRequest</a> (void)</td></tr>
<tr class="separator:gac41a20009e50458db00347f609f40d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b6ebc4477954855f3d6e6bf2b78adf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga0b6ebc4477954855f3d6e6bf2b78adf5">XMC_FLASH_DisableWaitStateForECC</a> (void)</td></tr>
<tr class="separator:ga0b6ebc4477954855f3d6e6bf2b78adf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79d8e7db7970cdb36b3afa19f2a7189e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga79d8e7db7970cdb36b3afa19f2a7189e">XMC_FLASH_EnableDoubleBitErrorTrap</a> (void)</td></tr>
<tr class="separator:ga79d8e7db7970cdb36b3afa19f2a7189e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3464c6cd99c4050f7a15f378a58c591a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga3464c6cd99c4050f7a15f378a58c591a">XMC_FLASH_EnableDynamicIdle</a> (void)</td></tr>
<tr class="separator:ga3464c6cd99c4050f7a15f378a58c591a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dae70005cbc3265b504a7232cc72b86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga2dae70005cbc3265b504a7232cc72b86">XMC_FLASH_EnableEvent</a> (const uint32_t event_msk)</td></tr>
<tr class="separator:ga2dae70005cbc3265b504a7232cc72b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1896130011c2e2890549ab78e1c163e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga1896130011c2e2890549ab78e1c163e3">XMC_FLASH_EnableSleepRequest</a> (void)</td></tr>
<tr class="separator:ga1896130011c2e2890549ab78e1c163e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37e503edebc301bce65025216b0ccdc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga37e503edebc301bce65025216b0ccdc5">XMC_FLASH_EnableWaitStateForECC</a> (void)</td></tr>
<tr class="separator:ga37e503edebc301bce65025216b0ccdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2544025231cb5f94cb289a344be0af44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga2544025231cb5f94cb289a344be0af44">XMC_FLASH_ErasePhysicalSector</a> (uint32_t *sector_start_address)</td></tr>
<tr class="separator:ga2544025231cb5f94cb289a344be0af44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29bb5d4f245ae9ed8d1655dff2dd8ec6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga29bb5d4f245ae9ed8d1655dff2dd8ec6">XMC_FLASH_EraseSector</a> (uint32_t *address)</td></tr>
<tr class="separator:ga29bb5d4f245ae9ed8d1655dff2dd8ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga052b03bb505d3e71ac4f7cf30304e75f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga052b03bb505d3e71ac4f7cf30304e75f">XMC_FLASH_EraseUCB</a> (uint32_t *ucb_sector_start_address)</td></tr>
<tr class="separator:ga052b03bb505d3e71ac4f7cf30304e75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50275a88263d4fdfb85261d352eac1d5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus</a> (void)</td></tr>
<tr class="separator:ga50275a88263d4fdfb85261d352eac1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3f342b734a41e4ca1925078d310cd79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gad3f342b734a41e4ca1925078d310cd79">XMC_FLASH_InstallBMI</a> (<a class="el" href="struct_x_m_c___f_l_a_s_h___b_m_i___s_t_r_i_n_g__t.html">XMC_FLASH_BMI_STRING_t</a> *const bmi_string)</td></tr>
<tr class="separator:gad3f342b734a41e4ca1925078d310cd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga422e95387a2c1a457f83bcc494c7ea92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga422e95387a2c1a457f83bcc494c7ea92">XMC_FLASH_InstallProtection</a> (uint8_t user, uint32_t protection_mask, uint32_t password_0, uint32_t password_1)</td></tr>
<tr class="separator:ga422e95387a2c1a457f83bcc494c7ea92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d687d0d1d5bdc9173d96c7619172cd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga7d687d0d1d5bdc9173d96c7619172cd8">XMC_FLASH_IsBusy</a> (void)</td></tr>
<tr class="separator:ga7d687d0d1d5bdc9173d96c7619172cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ba9c9992649eb6d84b03d2260efbe31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga7ba9c9992649eb6d84b03d2260efbe31">XMC_FLASH_ProgramPage</a> (uint32_t *address, const uint32_t *data)</td></tr>
<tr class="separator:ga7ba9c9992649eb6d84b03d2260efbe31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9e7f18e8a0d781cac832611f0abf9a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gab9e7f18e8a0d781cac832611f0abf9a2">XMC_FLASH_RepairPhysicalSector</a> (void)</td></tr>
<tr class="separator:gab9e7f18e8a0d781cac832611f0abf9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7d3212ef885aaf2540f8a4d8ba319c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gab7d3212ef885aaf2540f8a4d8ba319c1">XMC_FLASH_Reset</a> (void)</td></tr>
<tr class="separator:gab7d3212ef885aaf2540f8a4d8ba319c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab73556da929b0342c759d63eb3a8096e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gab73556da929b0342c759d63eb3a8096e">XMC_FLASH_ResumeProtection</a> (void)</td></tr>
<tr class="separator:gab73556da929b0342c759d63eb3a8096e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2a956b4b465cc67f6f84197f535835b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#gaf2a956b4b465cc67f6f84197f535835b">XMC_FLASH_SetMargin</a> (const <a class="el" href="group___f_l_a_s_h.html#gaffd9d28d3272304c791a90bac529a94e">XMC_FLASH_MARGIN_t</a> margin)</td></tr>
<tr class="separator:gaf2a956b4b465cc67f6f84197f535835b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ce7f5d950394593eace1b812cb791cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga3ce7f5d950394593eace1b812cb791cc">XMC_FLASH_SetWaitStates</a> (uint32_t num_wait_states)</td></tr>
<tr class="separator:ga3ce7f5d950394593eace1b812cb791cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7adc9bc3ddd27945282bfc576f5fec8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga7adc9bc3ddd27945282bfc576f5fec8b">XMC_FLASH_VerifyReadProtection</a> (uint32_t password_0, uint32_t password_1)</td></tr>
<tr class="separator:ga7adc9bc3ddd27945282bfc576f5fec8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80f6c3524cc7951802ec0c300414230e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga80f6c3524cc7951802ec0c300414230e">XMC_FLASH_VerifyWriteProtection</a> (uint32_t user, uint32_t protection_mask, uint32_t password_0, uint32_t password_1)</td></tr>
<tr class="separator:ga80f6c3524cc7951802ec0c300414230e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c9697994a5428b9613030ce2f8299f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga1c9697994a5428b9613030ce2f8299f6">XMC_PREFETCH_DisableInstructionBuffer</a> (void)</td></tr>
<tr class="separator:ga1c9697994a5428b9613030ce2f8299f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca38ea0c4e1defe0e9e84cc8be34a96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga4ca38ea0c4e1defe0e9e84cc8be34a96">XMC_PREFETCH_EnableInstructionBuffer</a> (void)</td></tr>
<tr class="separator:ga4ca38ea0c4e1defe0e9e84cc8be34a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d06fb96019945a9e19d18d9ec7b366d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h.html#ga0d06fb96019945a9e19d18d9ec7b366d">XMC_PREFETCH_InvalidateInstructionBuffer</a> (void)</td></tr>
<tr class="separator:ga0d06fb96019945a9e19d18d9ec7b366d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Flash is a non volatile memory module used to store instruction code or constant data. The flash low level driver provides support to the following functionalities of flash memory.<br />
 </p><ol>
<li>
Provides function to program a page. ( <a class="el" href="group___f_l_a_s_h.html#ga7ba9c9992649eb6d84b03d2260efbe31">XMC_FLASH_ProgramPage()</a> )<br />
 </li>
<li>
Provides functions to support read and write protection. ( <a class="el" href="group___f_l_a_s_h.html#ga422e95387a2c1a457f83bcc494c7ea92">XMC_FLASH_InstallProtection()</a>, <a class="el" href="group___f_l_a_s_h.html#gacc188832165a6d064bae5fb1cd4ecfb7">XMC_FLASH_ConfirmProtection()</a>, <a class="el" href="group___f_l_a_s_h.html#ga7adc9bc3ddd27945282bfc576f5fec8b">XMC_FLASH_VerifyReadProtection()</a>, <a class="el" href="group___f_l_a_s_h.html#ga80f6c3524cc7951802ec0c300414230e">XMC_FLASH_VerifyWriteProtection()</a> ) <br />
 </li>
<li>
Provides function to erase sector. ( <a class="el" href="group___f_l_a_s_h.html#ga29bb5d4f245ae9ed8d1655dff2dd8ec6">XMC_FLASH_EraseSector()</a> ) <br />
 </li>
</ol>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga8df033b692c14fc7d3e2da10906100f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8df033b692c14fc7d3e2da10906100f2">&#9670;&nbsp;</a></span>XMC_FLASH_BMI_VALID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_BMI_VALID&#160;&#160;&#160;(uint32_t)(0x1 &lt;&lt; 31)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is always 0 in UCB. The copy of this BMI word in DSRAM1 has this ?BMI Valid? bit set to 1 after SSW has validated the XOR checksum </p>

</div>
</div>
<a id="ga00b2a643c63a3ce66dc6fd2fb9ba5508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00b2a643c63a3ce66dc6fd2fb9ba5508">&#9670;&nbsp;</a></span>XMC_FLASH_BYTES_PER_PAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_BYTES_PER_PAGE&#160;&#160;&#160;(256UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of bytes in a page </p>

</div>
</div>
<a id="ga6bdfc650939db3a1a2f3b726a7d3dd65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bdfc650939db3a1a2f3b726a7d3dd65">&#9670;&nbsp;</a></span>XMC_FLASH_BYTES_PER_UCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_BYTES_PER_UCB&#160;&#160;&#160;(1024UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of bytes in a user configurable block Note : Total number of Sectors depends on the flash size of the controller. So while using these macros for flash operations ensure that sector is available, other may lead to flash error. </p>

</div>
</div>
<a id="gafbd791228246106acb5a4ef1e4e461a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbd791228246106acb5a4ef1e4e461a9">&#9670;&nbsp;</a></span>XMC_FLASH_PHY_SECTOR_0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_PHY_SECTOR_0&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x00000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of non cached physical sector0 </p>

</div>
</div>
<a id="ga45e30d54d3370336f77feac2d57b110a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45e30d54d3370336f77feac2d57b110a">&#9670;&nbsp;</a></span>XMC_FLASH_PHY_SECTOR_10</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_PHY_SECTOR_10&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x80000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of non cached physical sector10 </p>

</div>
</div>
<a id="gad7dd723484e1e0e3360cc51ad0e308e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7dd723484e1e0e3360cc51ad0e308e4">&#9670;&nbsp;</a></span>XMC_FLASH_PHY_SECTOR_11</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_PHY_SECTOR_11&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0xC0000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of non cached physical sector11 </p>

</div>
</div>
<a id="ga370dcfbf663969ac3756656a3d49213d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga370dcfbf663969ac3756656a3d49213d">&#9670;&nbsp;</a></span>XMC_FLASH_PHY_SECTOR_12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_PHY_SECTOR_12&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x100000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of non cached physical sector12 </p>

</div>
</div>
<a id="gadb253cfe200cf1ca2d6e4c34a44fd0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb253cfe200cf1ca2d6e4c34a44fd0d6">&#9670;&nbsp;</a></span>XMC_FLASH_PHY_SECTOR_13</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_PHY_SECTOR_13&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x140000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of non cached physical sector13 </p>

</div>
</div>
<a id="gadf5fbc662ade44ac1bc4a9285c595e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf5fbc662ade44ac1bc4a9285c595e75">&#9670;&nbsp;</a></span>XMC_FLASH_PHY_SECTOR_14</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_PHY_SECTOR_14&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x180000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of non cached physical sector14 </p>

</div>
</div>
<a id="ga0b7aec6b448fb88de839ca66c3d0e1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b7aec6b448fb88de839ca66c3d0e1f5">&#9670;&nbsp;</a></span>XMC_FLASH_PHY_SECTOR_15</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_PHY_SECTOR_15&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x1C0000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of non cached physical sector15 </p>

</div>
</div>
<a id="ga0b6e3af93c4317f421eac4cc799f10f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b6e3af93c4317f421eac4cc799f10f7">&#9670;&nbsp;</a></span>XMC_FLASH_PHY_SECTOR_4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_PHY_SECTOR_4&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x10000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of non cached physical sector4 </p>

</div>
</div>
<a id="gac37d4f679fd2f43ed259c616a6fe08e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac37d4f679fd2f43ed259c616a6fe08e6">&#9670;&nbsp;</a></span>XMC_FLASH_PHY_SECTOR_8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_PHY_SECTOR_8&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x20000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of non cached physical sector8 </p>

</div>
</div>
<a id="gafdc6738b38cbc3b2f203e92682f6f265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdc6738b38cbc3b2f203e92682f6f265">&#9670;&nbsp;</a></span>XMC_FLASH_PHY_SECTOR_9</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_PHY_SECTOR_9&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x40000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of non cached physical sector9 </p>

</div>
</div>
<a id="ga7fdbfbdab6a3d36ab2f9e1ee1d296666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fdbfbdab6a3d36ab2f9e1ee1d296666">&#9670;&nbsp;</a></span>XMC_FLASH_SECTOR_0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_SECTOR_0&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x00000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of sector0 </p>

</div>
</div>
<a id="ga7a3f75ecb1f70a0b0f2f2534e7743595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a3f75ecb1f70a0b0f2f2534e7743595">&#9670;&nbsp;</a></span>XMC_FLASH_SECTOR_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_SECTOR_1&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x04000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of sector1 </p>

</div>
</div>
<a id="ga2609331cf0c07d960289c90aa2540ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2609331cf0c07d960289c90aa2540ef5">&#9670;&nbsp;</a></span>XMC_FLASH_SECTOR_10</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_SECTOR_10&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x80000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of sector10 </p>

</div>
</div>
<a id="gaf27f7a69fc845c41cb2fadb29be3461c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf27f7a69fc845c41cb2fadb29be3461c">&#9670;&nbsp;</a></span>XMC_FLASH_SECTOR_11</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_SECTOR_11&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0xC0000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of sector11 </p>

</div>
</div>
<a id="gaafedb23690cde72c6445364c917bdb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafedb23690cde72c6445364c917bdb4c">&#9670;&nbsp;</a></span>XMC_FLASH_SECTOR_12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_SECTOR_12&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x100000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of sector12 </p>

</div>
</div>
<a id="gab30f8c17e561fa7dfebb97c274f5edd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab30f8c17e561fa7dfebb97c274f5edd7">&#9670;&nbsp;</a></span>XMC_FLASH_SECTOR_13</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_SECTOR_13&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x140000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of sector13 </p>

</div>
</div>
<a id="gac2348a6f8c87a6c2a23dba200a3d1060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2348a6f8c87a6c2a23dba200a3d1060">&#9670;&nbsp;</a></span>XMC_FLASH_SECTOR_14</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_SECTOR_14&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x180000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of sector14 </p>

</div>
</div>
<a id="ga446f520d18418bf9c97e351170ee8497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga446f520d18418bf9c97e351170ee8497">&#9670;&nbsp;</a></span>XMC_FLASH_SECTOR_15</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_SECTOR_15&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x1C0000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of sector15 </p>

</div>
</div>
<a id="ga24d9203529ee67a0385782a21746e355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24d9203529ee67a0385782a21746e355">&#9670;&nbsp;</a></span>XMC_FLASH_SECTOR_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_SECTOR_2&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x08000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of sector2 </p>

</div>
</div>
<a id="ga56cc0ee898652dedf49dca1e205b9ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56cc0ee898652dedf49dca1e205b9ab6">&#9670;&nbsp;</a></span>XMC_FLASH_SECTOR_3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_SECTOR_3&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x0C000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of sector3 </p>

</div>
</div>
<a id="ga213fa88eef76853c2fb28dc1d75c3943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga213fa88eef76853c2fb28dc1d75c3943">&#9670;&nbsp;</a></span>XMC_FLASH_SECTOR_4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_SECTOR_4&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x10000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of sector4 </p>

</div>
</div>
<a id="ga981a5460f0ae8431f5211617d728d808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga981a5460f0ae8431f5211617d728d808">&#9670;&nbsp;</a></span>XMC_FLASH_SECTOR_5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_SECTOR_5&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x14000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of sector5 </p>

</div>
</div>
<a id="ga4e002ae0e153ca50cfa9275e45c93290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e002ae0e153ca50cfa9275e45c93290">&#9670;&nbsp;</a></span>XMC_FLASH_SECTOR_6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_SECTOR_6&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x18000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of sector6 </p>

</div>
</div>
<a id="ga77fc1d691d0724e4ba9130e50f706929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77fc1d691d0724e4ba9130e50f706929">&#9670;&nbsp;</a></span>XMC_FLASH_SECTOR_7</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_SECTOR_7&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x1C000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of sector7 </p>

</div>
</div>
<a id="ga9c38a3969c71b1e45b9aa670a125cd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c38a3969c71b1e45b9aa670a125cd25">&#9670;&nbsp;</a></span>XMC_FLASH_SECTOR_8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_SECTOR_8&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x20000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of sector8 </p>

</div>
</div>
<a id="gaa0ad69cbc5554b96b9a7412069b9eb8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0ad69cbc5554b96b9a7412069b9eb8f">&#9670;&nbsp;</a></span>XMC_FLASH_SECTOR_9</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_SECTOR_9&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x40000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of sector9 </p>

</div>
</div>
<a id="ga9df78d7a8aca3cbf4c65ff5fd8be3149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9df78d7a8aca3cbf4c65ff5fd8be3149">&#9670;&nbsp;</a></span>XMC_FLASH_UCB0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_UCB0&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x0000UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of User Configurable Block 0 </p>

</div>
</div>
<a id="ga45b304d0d3ac857cd573eeadb828fdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45b304d0d3ac857cd573eeadb828fdbc">&#9670;&nbsp;</a></span>XMC_FLASH_UCB1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_UCB1&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x0400UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of User Configurable Block 1 </p>

</div>
</div>
<a id="ga3d536c12335ec31ebb73bf67153c4f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d536c12335ec31ebb73bf67153c4f9b">&#9670;&nbsp;</a></span>XMC_FLASH_UCB2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_UCB2&#160;&#160;&#160;(uint32_t *)(<a class="el" href="group___f_l_a_s_h.html#ga95898df658a19493d8f4763d481cdd74">XMC_FLASH_UNCACHED_BASE</a> + 0x0800UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starting address of User Configurable Block 2 </p>

</div>
</div>
<a id="ga95898df658a19493d8f4763d481cdd74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95898df658a19493d8f4763d481cdd74">&#9670;&nbsp;</a></span>XMC_FLASH_UNCACHED_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_UNCACHED_BASE&#160;&#160;&#160;(0x0C000000U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Non cached flash starting address of for XMC4 family of microcontrollers </p>

</div>
</div>
<a id="ga8baf803359cd0c484bed4123ea4d8446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8baf803359cd0c484bed4123ea4d8446">&#9670;&nbsp;</a></span>XMC_FLASH_WORDS_PER_PAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_FLASH_WORDS_PER_PAGE&#160;&#160;&#160;(64UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of words in a page (256 bytes / 4 bytes = 64 words) </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga1366551fd3139133b486a1d77b4d8d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1366551fd3139133b486a1d77b4d8d42">&#9670;&nbsp;</a></span>XMC_FLASH_BMI_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___f_l_a_s_h.html#ga1366551fd3139133b486a1d77b4d8d42">XMC_FLASH_BMI_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BMI Word configuration </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1366551fd3139133b486a1d77b4d8d42abbb1693373c731f763d37ceb0e1bf674"></a>XMC_FLASH_BMI_BOOT_MODE_NORMAL&#160;</td><td class="fielddoc"><p>Normal boot mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1366551fd3139133b486a1d77b4d8d42adf6131d927c1cf71943e2abb1d51d339"></a>XMC_FLASH_BMI_BOOT_MODE_ASC_BSL&#160;</td><td class="fielddoc"><p>ASC BSL boot mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1366551fd3139133b486a1d77b4d8d42a778b4775a1e6accf5f0be39154c1103e"></a>XMC_FLASH_BMI_BOOT_MODE_CAN_BSL&#160;</td><td class="fielddoc"><p>CAN BSL boot mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1366551fd3139133b486a1d77b4d8d42ae0e4b1336528c2d81912caeb28374557"></a>XMC_FLASH_BMI_BOOT_MODE_PSRAM&#160;</td><td class="fielddoc"><p>PSRAM boot mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1366551fd3139133b486a1d77b4d8d42a56b0b7b3716ab1744c540ab83f24338a"></a>XMC_FLASH_BMI_BOOT_MODE_ABM0&#160;</td><td class="fielddoc"><p>ABM0 boot mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1366551fd3139133b486a1d77b4d8d42a84d7c00d833a2ec35f9473df9bda2d6d"></a>XMC_FLASH_BMI_BOOT_MODE_ABM1&#160;</td><td class="fielddoc"><p>ABM1 boot mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1366551fd3139133b486a1d77b4d8d42a1146faab4b6aa91f3412f23db2782391"></a>XMC_FLASH_BMI_BOOT_MODE_FALLBACK_ABM&#160;</td><td class="fielddoc"><p>Fallback ABM boot mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1366551fd3139133b486a1d77b4d8d42a3c3ff1eda21cb0754dfee3f42379af2f"></a>XMC_FLASH_BMI_MAC_BIT_MSK&#160;</td><td class="fielddoc"><p>Valid MAC address part of BMI string </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1366551fd3139133b486a1d77b4d8d42a4437c123aa819a5ab87fd91d246675f4"></a>XMC_FLASH_BMI_IPV4_BIT_MSK&#160;</td><td class="fielddoc"><p>Ethernet IP extension contains a IPv4 address </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1366551fd3139133b486a1d77b4d8d42aab1e06ed980f84d5d55f941cc59b69db"></a>XMC_FLASH_BMI_IPV6_BIT_MSK&#160;</td><td class="fielddoc"><p>Ethernet IP extension contains a IPv6 address </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1366551fd3139133b486a1d77b4d8d42a38ef524861377d8afeb51d7009851e9b"></a>XMC_FLASH_BMI_USB_BIT_MAK&#160;</td><td class="fielddoc"><p>Valid USB Serial Number part of BMI string </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1366551fd3139133b486a1d77b4d8d42a290a7d9d757dfa13455c4a5e2c92b1f4"></a>XMC_FLASH_BMI_PAI_PSRAM_MSK&#160;</td><td class="fielddoc"><p>Parity of PSRAM to be initialized by SSW </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1366551fd3139133b486a1d77b4d8d42aca4d8ae117f949effa709bb725803853"></a>XMC_FLASH_BMI_PAI_DSRAM_MSK&#160;</td><td class="fielddoc"><p>Parity of DSRAM1 to be initialized by SSW </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1366551fd3139133b486a1d77b4d8d42a98dc0ae1c6ac29c23a7d99a2a7ac166d"></a>XMC_FLASH_BMI_PAI_CMSRAM_MSK&#160;</td><td class="fielddoc"><p>Parity of DSRAM-Comm to be initialized by SSW </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1366551fd3139133b486a1d77b4d8d42a93d7b29bcdfa62662a83e758d18533c1"></a>XMC_FLASH_BMI_SPEEDUP_BIT_MSK&#160;</td><td class="fielddoc"><p>Clock Tree of the device to be setup to maximum frequency </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1ef5e96ac5c0fd9dd006a9c3aead2a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ef5e96ac5c0fd9dd006a9c3aead2a9d">&#9670;&nbsp;</a></span>XMC_FLASH_EVENT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___f_l_a_s_h.html#ga1ef5e96ac5c0fd9dd006a9c3aead2a9d">XMC_FLASH_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides the options to select flash operational events </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1ef5e96ac5c0fd9dd006a9c3aead2a9da765f7514f0f46af80810c382eb5dda69"></a>XMC_FLASH_EVENT_VERIFY_AND_OPERATION_ERROR&#160;</td><td class="fielddoc"><p>Flash verify and operation error event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1ef5e96ac5c0fd9dd006a9c3aead2a9daabb0d284cf4ee822cd1308de5868f66e"></a>XMC_FLASH_EVENT_COMMAND_SEQUENCE_ERROR&#160;</td><td class="fielddoc"><p>Flash command sequence error event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1ef5e96ac5c0fd9dd006a9c3aead2a9dacc21e98f7b6d23bd95f25943d90383e5"></a>XMC_FLASH_EVENT_PROTECTION_ERROR&#160;</td><td class="fielddoc"><p>Flash protection error event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1ef5e96ac5c0fd9dd006a9c3aead2a9da99643fc53dbc584c991febfeb2f27d77"></a>XMC_FLASH_EVENT_SINGLE_BIT_ERROR&#160;</td><td class="fielddoc"><p>Flash single bit error event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1ef5e96ac5c0fd9dd006a9c3aead2a9daa7975867c112a894a1f218bf7c2c2df7"></a>XMC_FLASH_EVENT_DOUBLE_BIT_ERROR&#160;</td><td class="fielddoc"><p>Flash double bit error event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1ef5e96ac5c0fd9dd006a9c3aead2a9da2f73a0b673bb1a5c72acdcdf7bbe7f99"></a>XMC_FLASH_EVENT_END_OF_BUSY&#160;</td><td class="fielddoc"><p>Flash end of busy event </p>
</td></tr>
</table>

</div>
</div>
<a id="gaffd9d28d3272304c791a90bac529a94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffd9d28d3272304c791a90bac529a94e">&#9670;&nbsp;</a></span>XMC_FLASH_MARGIN_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___f_l_a_s_h.html#gaffd9d28d3272304c791a90bac529a94e">XMC_FLASH_MARGIN_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides the options to select flash margin read settings of the for quality assurance. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaffd9d28d3272304c791a90bac529a94ea7aec9640f05fa2142388db8a9fd55cf7"></a>XMC_FLASH_MARGIN_DEFAULT&#160;</td><td class="fielddoc"><p>Default margin </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaffd9d28d3272304c791a90bac529a94ea5ee18c0f9b1b3c11da7c96ef5fd51352"></a>XMC_FLASH_MARGIN_TIGHT0&#160;</td><td class="fielddoc"><p>Sub-optimal 0-bits are read as 1s </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaffd9d28d3272304c791a90bac529a94ea8cb0bf721908b33d31620f7f04283561"></a>XMC_FLASH_MARGIN_TIGHT1&#160;</td><td class="fielddoc"><p>Sub-optimal 1-bits are read as 0s </p>
</td></tr>
</table>

</div>
</div>
<a id="gae606277a956ca47776797dc27ef58005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae606277a956ca47776797dc27ef58005">&#9670;&nbsp;</a></span>XMC_FLASH_PROTECTION_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___f_l_a_s_h.html#gae606277a956ca47776797dc27ef58005">XMC_FLASH_PROTECTION_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides the options to select sectors for write protection and select global read protection. The members can be combined using 'OR' operator for multiple selection.<br />
 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae606277a956ca47776797dc27ef58005a1663e24791e00ae281d6320daa1c1892"></a>XMC_FLASH_PROTECTION_WRITE_SECTOR_0&#160;</td><td class="fielddoc"><p>Sector 0 write protection </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae606277a956ca47776797dc27ef58005ae31259e3609f522b8bf9ab4e486817f9"></a>XMC_FLASH_PROTECTION_WRITE_SECTOR_1&#160;</td><td class="fielddoc"><p>Sector 1 write protection </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae606277a956ca47776797dc27ef58005a9b1559d4a5fdd4345eab6a93b484cfeb"></a>XMC_FLASH_PROTECTION_WRITE_SECTOR_2&#160;</td><td class="fielddoc"><p>Sector 3 write protection </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae606277a956ca47776797dc27ef58005a9884dee5140d6db8989148165ddb032e"></a>XMC_FLASH_PROTECTION_WRITE_SECTOR_3&#160;</td><td class="fielddoc"><p>Sector 3 write protection </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae606277a956ca47776797dc27ef58005a9970bcac67028db2a1b502afe4b8805d"></a>XMC_FLASH_PROTECTION_WRITE_SECTOR_4&#160;</td><td class="fielddoc"><p>Sector 4 write protection </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae606277a956ca47776797dc27ef58005a6fb79d39a49798dd2dc9eae07ee7e2a6"></a>XMC_FLASH_PROTECTION_WRITE_SECTOR_5&#160;</td><td class="fielddoc"><p>Sector 5 write protection </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae606277a956ca47776797dc27ef58005abb4a8eacedb6224e03244346c9f88946"></a>XMC_FLASH_PROTECTION_WRITE_SECTOR_6&#160;</td><td class="fielddoc"><p>Sector 6 write protection </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae606277a956ca47776797dc27ef58005adfc3f466408d78456c8398230a6ba49a"></a>XMC_FLASH_PROTECTION_WRITE_SECTOR_7&#160;</td><td class="fielddoc"><p>Sector 7 write protection </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae606277a956ca47776797dc27ef58005adabc478c6e07ced73185bc97326b6bbb"></a>XMC_FLASH_PROTECTION_WRITE_SECTOR_8&#160;</td><td class="fielddoc"><p>Sector 8 write protection </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae606277a956ca47776797dc27ef58005a747303e64c4c929f0ef8844e365db3aa"></a>XMC_FLASH_PROTECTION_WRITE_SECTOR_9&#160;</td><td class="fielddoc"><p>Sector 9 write protection </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae606277a956ca47776797dc27ef58005af1559407d12d4c93f13d345605fc5a9e"></a>XMC_FLASH_PROTECTION_WRITE_SECTORS_10_11&#160;</td><td class="fielddoc"><p>Sector 10 and 11 write protection </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae606277a956ca47776797dc27ef58005a3df58c1042abb3f226e182c779072b84"></a>XMC_FLASH_PROTECTION_WRITE_SECTORS_12_13&#160;</td><td class="fielddoc"><p>Sector 12 and 13 write protection </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae606277a956ca47776797dc27ef58005a931fc39b6a596655efc4b345bc66058e"></a>XMC_FLASH_PROTECTION_WRITE_SECTORS_14_15&#160;</td><td class="fielddoc"><p>Sector 14 and 15 write protection </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae606277a956ca47776797dc27ef58005ac78bee539a1ccfcdf1ee233b816caebb"></a>XMC_FLASH_PROTECTION_READ_GLOBAL&#160;</td><td class="fielddoc"><p>Global read protection (Applicable for UserLevel0 alone) </p>
</td></tr>
</table>

</div>
</div>
<a id="gaec69607b9daecffb4215faca73d02ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec69607b9daecffb4215faca73d02ebc">&#9670;&nbsp;</a></span>XMC_FLASH_STATUS_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___f_l_a_s_h.html#gaec69607b9daecffb4215faca73d02ebc">XMC_FLASH_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the return status of the API. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebca083aba939fe424ed79247a2c2ae27807"></a>XMC_FLASH_STATUS_OK&#160;</td><td class="fielddoc"><p>Operation completed successfully </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebcaf9f87eda000da5d7cb50aed5d8d58835"></a>XMC_FLASH_STATUS_BUSY&#160;</td><td class="fielddoc"><p>API cannot proceed since FLASH is busy </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebca2289eb8689a968bb06312b9195d2b5fa"></a>XMC_FLASH_STATUS_PROGRAMMING_STATE&#160;</td><td class="fielddoc"><p>Write page is in progress or finished </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebcaeb9c445227882f04f216d00438b19dfd"></a>XMC_FLASH_STATUS_ERASE_STATE&#160;</td><td class="fielddoc"><p>Erase page is in progress or finished </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebcadec0232699def4bfbb4f90b2bca88138"></a>XMC_FLASH_STATUS_PAGE_MODE&#160;</td><td class="fielddoc"><p>Flash is in page mode. Assembly buffer of PFLASH is in use </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebca0142ae5fc1eae7cac1be0ade8bd00cd3"></a>XMC_FLASH_STATUS_OPERATION_ERROR&#160;</td><td class="fielddoc"><p>Flash Operation aborted </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebca7e13a567f1472675a3e5f992a31d85d9"></a>XMC_FLASH_STATUS_COMMAND_SEQUENCE_ERROR&#160;</td><td class="fielddoc"><p>Improper address or Invalid state machine operation </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebca55d56b8c85fb2c9c75165cc5a6f652ed"></a>XMC_FLASH_STATUS_PROTECTION_ERROR&#160;</td><td class="fielddoc"><p>Flash operation addressing the locked sector </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebca08a42bcbb1dca5725a8ea4e278d79b04"></a>XMC_FLASH_STATUS_SINGLE_BIT_ERROR_AND_CORRECTION&#160;</td><td class="fielddoc"><p>Single bit error detected and corrected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebcaba69345c05a5ebbe7ccde6542f5c563d"></a>XMC_FLASH_STATUS_DOUBLE_BIT_ERROR&#160;</td><td class="fielddoc"><p>Multiple bit error occurred </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebca0dae24d8fe1a1a42fd41f3f4aaec0f5b"></a>XMC_FLASH_STATUS_PROTECTION_INSTALLED&#160;</td><td class="fielddoc"><p>Confirmation of the read or/and write protection is successful </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebcae865d837ad4de00b8983e618fa8a9f30"></a>XMC_FLASH_STATUS_READ_PROTECTION_INSTALLED&#160;</td><td class="fielddoc"><p>Confirmation of read and global write protection is successful for user-0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebcad96f3622c9ad118d5584c666c4e85625"></a>XMC_FLASH_STATUS_READ_PROTECTION_DISABLED_STATE&#160;</td><td class="fielddoc"><p>Read or/and write protection is temporarily disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebca0729822671955abd996616fa2dc8b0fd"></a>XMC_FLASH_STATUS_WRITE_PROTECTION_INSTALLED_UCB0&#160;</td><td class="fielddoc"><p>Sector write protection is installed for user-0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebcaec87a55907526c95742614dcd1fb3e27"></a>XMC_FLASH_STATUS_WRITE_PROTECTION_INSTALLED_UCB1&#160;</td><td class="fielddoc"><p>Sector write protection is installed for user-1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebca4c2459b0b694eaa1759d6272e37b58ee"></a>XMC_FLASH_STATUS_WRITE_PROTECTION_INSTALLED_UCB2&#160;</td><td class="fielddoc"><p>Sector OTP protection is installed for user-2 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebcab499e5b14d26eb2fc7e6e4d183366585"></a>XMC_FLASH_STATUS_WRITE_PROTECTION_DISABLED_UCB0&#160;</td><td class="fielddoc"><p>Sector write protection is disabled for user-0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebcaa43cf8dec78af854b2e25d15e4555eaf"></a>XMC_FLASH_STATUS_WRITE_PROTECTION_DISABLED_UCB1&#160;</td><td class="fielddoc"><p>Sector write protection is disabled for user-1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebcaac366f040e019a43084cac0959b51ce1"></a>XMC_FLASH_STATUS_SLEEP_MODE&#160;</td><td class="fielddoc"><p>Indicates flash in sleep mode or not </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaec69607b9daecffb4215faca73d02ebca1bb4dde4b92f4e55b5f4ca9c8a7066f0"></a>XMC_FLASH_STATUS_VERIFY_ERROR&#160;</td><td class="fielddoc"><p>Write verification and Erase verification error occurred </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab3972a9f18acaa900499351a4843ff38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3972a9f18acaa900499351a4843ff38">&#9670;&nbsp;</a></span>XMC_FLASH_ClearStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_ClearStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Clears the previous error status by reseting the FSR status register.<br />
<br />
 Call this API before starting any flash programming / erase related APIs to ensure all previous errors are cleared.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a id="gacc188832165a6d064bae5fb1cd4ecfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc188832165a6d064bae5fb1cd4ecfb7">&#9670;&nbsp;</a></span>XMC_FLASH_ConfirmProtection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_ConfirmProtection </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>ID number of the user configuration block (UCB).<br />
 Range: [0 to 2]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Confirms the protection, so that sectors specified under <em>user</em> configurable block are locked forever.<br />
<br />
 The protection shall be installed by calling <a class="el" href="group___f_l_a_s_h.html#ga422e95387a2c1a457f83bcc494c7ea92">XMC_FLASH_InstallProtection()</a> before calling this API. The confirmation starts by issuing the page mode entry command followed by the load page command. The load page command issues the confirmation protection command for the sectors on which the protection installation was done. It also loads the specified passwords <em>password0</em> and <em>password1</em> respectively. Finally, it issues the confirm protection command for the specified <em>user</em> configuration block so that the sectors will be protected forever.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga422e95387a2c1a457f83bcc494c7ea92">XMC_FLASH_InstallProtection()</a><br />
 </dd></dl>

</div>
</div>
<a id="gafa6bd7da37dc5f4670a08aea375ec6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa6bd7da37dc5f4670a08aea375ec6e7">&#9670;&nbsp;</a></span>XMC_FLASH_DisableDoubleBitErrorTrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_DisableDoubleBitErrorTrap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the trap generation for double bit error by clearing MARP register bit TRAPDIS.<br />
<br />
 The double-bit error trap can be disabled for margin checks and also redirected to an error interrupt. Any time during the execution the double bit error trap can be enabled back by calling <a class="el" href="group___f_l_a_s_h.html#ga79d8e7db7970cdb36b3afa19f2a7189e">XMC_FLASH_EnableDoubleBitErrorTrap()</a> API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaef58f59fcc0cb0100fe6c850bde4c13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef58f59fcc0cb0100fe6c850bde4c13b">&#9670;&nbsp;</a></span>XMC_FLASH_DisableDynamicIdle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_DisableDynamicIdle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables dynamic idle mode feature.<br />
<br />
 It resets the FCON register IDLE bit to disable this feature. Hence normal flash read operation is selected.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga3464c6cd99c4050f7a15f378a58c591a">XMC_FLASH_EnableDynamicIdle()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga162346fadd0c8caacda1738259da404e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga162346fadd0c8caacda1738259da404e">&#9670;&nbsp;</a></span>XMC_FLASH_DisableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_DisableEvent </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event_msk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_msk</td><td>ORed values of <a class="el" href="group___f_l_a_s_h.html#ga1ef5e96ac5c0fd9dd006a9c3aead2a9d">XMC_FLASH_EVENT_t</a> enumeration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the particular flash events as specified in the input parameter.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga2dae70005cbc3265b504a7232cc72b86">XMC_FLASH_EnableEvent()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gac41a20009e50458db00347f609f40d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac41a20009e50458db00347f609f40d9e">&#9670;&nbsp;</a></span>XMC_FLASH_DisableSleepRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_DisableSleepRequest </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Wake-up the PFLASH from sleep.<br />
<br />
 Wakes-up from sleep is done by clearing the bit FCON.SLEEP, if selected via this bit, or wake-up is initiated by releasing the external sleep signal from SCU.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>fCPU must be equal or above 1 MHz when wake-up request is triggered.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga1896130011c2e2890549ab78e1c163e3">XMC_FLASH_EnableSleepRequest()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga0b6ebc4477954855f3d6e6bf2b78adf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b6ebc4477954855f3d6e6bf2b78adf5">&#9670;&nbsp;</a></span>XMC_FLASH_DisableWaitStateForECC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_DisableWaitStateForECC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the wait state for error correction.<br />
<br />
 Removes additional wait state for ECC by resetting WSECPF bit of FCON register.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga37e503edebc301bce65025216b0ccdc5">XMC_FLASH_EnableWaitStateForECC()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga79d8e7db7970cdb36b3afa19f2a7189e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79d8e7db7970cdb36b3afa19f2a7189e">&#9670;&nbsp;</a></span>XMC_FLASH_EnableDoubleBitErrorTrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_EnableDoubleBitErrorTrap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables double bit error trap.<br />
<br />
. It enables by setting MARP register bit TRAPDIS.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga3464c6cd99c4050f7a15f378a58c591a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3464c6cd99c4050f7a15f378a58c591a">&#9670;&nbsp;</a></span>XMC_FLASH_EnableDynamicIdle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_EnableDynamicIdle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables dynamic idle mode feature to save power.<br />
<br />
 It switches off the PFLASH read path when no read access is pending. Hence power is saved marginally. This slightly reduces the flash read performance because static pre-fetching is disabled.It sets the FCON register IDLE bit to enable this feature.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#gaef58f59fcc0cb0100fe6c850bde4c13b">XMC_FLASH_DisableDynamicIdle()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga2dae70005cbc3265b504a7232cc72b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dae70005cbc3265b504a7232cc72b86">&#9670;&nbsp;</a></span>XMC_FLASH_EnableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_EnableEvent </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event_msk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_msk</td><td>ORed values of <a class="el" href="group___f_l_a_s_h.html#ga1ef5e96ac5c0fd9dd006a9c3aead2a9d">XMC_FLASH_EVENT_t</a> enumeration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the particular flash events as specified in the input parameter.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga162346fadd0c8caacda1738259da404e">XMC_FLASH_DisableEvent()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga1896130011c2e2890549ab78e1c163e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1896130011c2e2890549ab78e1c163e3">&#9670;&nbsp;</a></span>XMC_FLASH_EnableSleepRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_EnableSleepRequest </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables sleep mode of the PFLASH.<br />
<br />
 Sleep mode is enabled by setting the bit FCON.SLEEP.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>fCPU must be equal or above 1 MHz when wake-up request is triggered.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#gac41a20009e50458db00347f609f40d9e">XMC_FLASH_DisableSleepRequest()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga37e503edebc301bce65025216b0ccdc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37e503edebc301bce65025216b0ccdc5">&#9670;&nbsp;</a></span>XMC_FLASH_EnableWaitStateForECC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_EnableWaitStateForECC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the wait state for error correction.process, It enables one additional wait state for ECC by setting WSECPF bit of FCON register.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga0b6ebc4477954855f3d6e6bf2b78adf5">XMC_FLASH_DisableWaitStateForECC()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga2544025231cb5f94cb289a344be0af44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2544025231cb5f94cb289a344be0af44">&#9670;&nbsp;</a></span>XMC_FLASH_ErasePhysicalSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_ErasePhysicalSector </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>sector_start_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sector_start_address</td><td>Pointer to the starting address of physical sector. Use XMC_FLASH_SECTOR_x MACRO defined in <a class="el" href="xmc4__flash_8h.html">xmc4_flash.h</a> file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Erases the physical sector "PSA".<br />
<br />
 If "PSA" does not point to base address of a correct sector or an unavailable sector, it returns SQER.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga29bb5d4f245ae9ed8d1655dff2dd8ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29bb5d4f245ae9ed8d1655dff2dd8ec6">&#9670;&nbsp;</a></span>XMC_FLASH_EraseSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_EraseSector </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Pointer to the starting address of the page to be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Erases a sector associated with the specified <em>address</em>.<br />
<br />
 Before erase, it clears the error status bits inside FSR status register. Issues the erase sector command sequence with the specified starting <em>address</em> to start flash erase process. Call <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a> API after calling this API, to verify the erase operation.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga052b03bb505d3e71ac4f7cf30304e75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga052b03bb505d3e71ac4f7cf30304e75f">&#9670;&nbsp;</a></span>XMC_FLASH_EraseUCB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_EraseUCB </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ucb_sector_start_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ucb_sector_start_address</td><td>Pointer to the starting address of physical sector. Use XMC_FLASH_UCBx MACRO defined in <a class="el" href="xmc4__flash_8h.html">xmc4_flash.h</a> file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>The addressed user configuration block ?UCB? is erased.<br />
<br />
Erases UCB whose startting address specified in the input parameter <em>ucb_sector_start_address</em>. When the UCB has an active write protection or the Flash module has an active global read protection the execution fails and PROER is set. The command fails with SQER when <em>ucb_sector_start_address</em> is not the start address of a valid UCB. Call <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus</a> API after this API to verify the erase was proper ot not.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga50275a88263d4fdfb85261d352eac1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50275a88263d4fdfb85261d352eac1d5">&#9670;&nbsp;</a></span>XMC_FLASH_GetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_FLASH_GetStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t Status of the previous flash operation.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Informs the status of flash by reading the FSR register.<br />
<br />
 It indicates the error status such as PFOPER, SQER, PROER, PFDBER, ORIER, VER errors as well as the current flash state. After calling the flash read/write/erase operation related APIs, call this API to verify flash status. The return value of this API shall be checked against the members of <a class="el" href="group___f_l_a_s_h.html#gaec69607b9daecffb4215faca73d02ebc">XMC_FLASH_STATUS_t</a> enumeration to get the relevant status.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a id="gad3f342b734a41e4ca1925078d310cd79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3f342b734a41e4ca1925078d310cd79">&#9670;&nbsp;</a></span>XMC_FLASH_InstallBMI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_InstallBMI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___f_l_a_s_h___b_m_i___s_t_r_i_n_g__t.html">XMC_FLASH_BMI_STRING_t</a> *const&#160;</td>
          <td class="paramname"><em>bmi_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bmi_string</td><td>BMI string configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>BMI provides a provision for end user to customize boot sequence. A 32 bit BMI word describes a set of activities that must be performed by SSW. BMI word along with associated parameters is known as the BMI string. The function calculates the XOR checksum of the BMI String. Before calling this function the UCB2 should be erased.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga052b03bb505d3e71ac4f7cf30304e75f">XMC_FLASH_EraseUCB()</a> </dd></dl>

</div>
</div>
<a id="ga422e95387a2c1a457f83bcc494c7ea92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga422e95387a2c1a457f83bcc494c7ea92">&#9670;&nbsp;</a></span>XMC_FLASH_InstallProtection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_InstallProtection </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>protection_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>password_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>password_1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>ID number of the user configuration block (UCB).<br />
 Range: [0 to 2]</td></tr>
    <tr><td class="paramname">protection_mask</td><td>ORed values of <a class="el" href="group___f_l_a_s_h.html#gae606277a956ca47776797dc27ef58005">XMC_FLASH_PROTECTION_t</a> enum type, for which sectors the protection has to be enabled. </td></tr>
    <tr><td class="paramname">password_0</td><td>First password for protection.<br />
 Range: [0 to 4294967295] </td></tr>
    <tr><td class="paramname">password_1</td><td>Second password for protection.<br />
 Range: [0 to 4294967295]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Installs the global read and sector write protection.<br />
<br />
 The installation starts by issuing the page mode entry command followed by the load page command. The load page command mode loads the required sectors intended for protection specified in <em>protection_mask</em>. It also loads the specified passwords <em>password0</em> and <em>password1</em> respectively. Finally, it issues the write page command for the specified <em>user</em> configuration block. Calling <a class="el" href="group___f_l_a_s_h.html#gacc188832165a6d064bae5fb1cd4ecfb7">XMC_FLASH_ConfirmProtection()</a> after this API completes the protection process by freezing the sectors forever.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#gacc188832165a6d064bae5fb1cd4ecfb7">XMC_FLASH_ConfirmProtection()</a><br />
 <a class="el" href="group___f_l_a_s_h.html#ga7adc9bc3ddd27945282bfc576f5fec8b">XMC_FLASH_VerifyReadProtection()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga7d687d0d1d5bdc9173d96c7619172cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d687d0d1d5bdc9173d96c7619172cd8">&#9670;&nbsp;</a></span>XMC_FLASH_IsBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_FLASH_IsBusy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if flash is in busy state else returns <em>false</em>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Checks whether flash is in busy state or not.<br />
<br />
 It is checked by calling the <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a> API internally. Refer <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a> for more details.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga7ba9c9992649eb6d84b03d2260efbe31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ba9c9992649eb6d84b03d2260efbe31">&#9670;&nbsp;</a></span>XMC_FLASH_ProgramPage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_ProgramPage </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Pointer to the starting address of flash page from where the programming starts. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the source address where targeted data is located.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Programs a single flash page associated with the specified <em>address</em>.<br />
<br />
 XMC4000 flash can be programmed with a granularity of 256 bytes page using this API. Before entering into page write process, it clears the error status bits inside status register. It starts the write process by issuing the page mode command followed by the load page command which loads the targeted <em>data</em> blocks into internal assembly buffer. Finally, it issues the write page command which programs the <em>data</em> into flash. Call <a class="el" href="group___f_l_a_s_h.html#ga50275a88263d4fdfb85261d352eac1d5">XMC_FLASH_GetStatus()</a> API after calling this API, to verify the programming operation.<br />
 </dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Flash will be busy state during write is ongoing, hence no operations allowed until it completes.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a id="gab9e7f18e8a0d781cac832611f0abf9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9e7f18e8a0d781cac832611f0abf9a2">&#9670;&nbsp;</a></span>XMC_FLASH_RepairPhysicalSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_RepairPhysicalSector </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Repairs the physical sector "PS4".<br />
<br />
For selected devices, Erase Physical Sector can also be used for Sector Soft Repair, depending on the configuration of PROCON1.PSR. This command sequence is required to run an EEPROM emulation algorithm that cycles the logical sectors S4..S7 of PS4. This command sequence repairs the corrupted logical sectors inside the physical sector due to interrupted erase operation.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a id="gab7d3212ef885aaf2540f8a4d8ba319c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7d3212ef885aaf2540f8a4d8ba319c1">&#9670;&nbsp;</a></span>XMC_FLASH_Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_Reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Resets the command interpreter to its initial state.<br />
<br />
Reset to Read can cancel every command sequence before its last command cycle has been received. All error flags gets cleared by calling this API. </dd></dl>
<dl class="section user"><dt>Note:</dt><dd>todo</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a id="gab73556da929b0342c759d63eb3a8096e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab73556da929b0342c759d63eb3a8096e">&#9670;&nbsp;</a></span>XMC_FLASH_ResumeProtection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_ResumeProtection </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Resumes flash protection as it was configured before.<br />
<br />
It clears all the disable proection status flags FSR.WPRODISx and FSR.RPRODIS. But FSR.WPRODISx is not cleared when corresponding UCBx is not in the ?confirmed? state.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaf2a956b4b465cc67f6f84197f535835b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2a956b4b465cc67f6f84197f535835b">&#9670;&nbsp;</a></span>XMC_FLASH_SetMargin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_SetMargin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___f_l_a_s_h.html#gaffd9d28d3272304c791a90bac529a94e">XMC_FLASH_MARGIN_t</a>&#160;</td>
          <td class="paramname"><em>margin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">margin</td><td>PFLASH margin selection. Use type <a class="el" href="group___f_l_a_s_h.html#gaffd9d28d3272304c791a90bac529a94e">XMC_FLASH_MARGIN_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the read margin levels for checking the healthiness of flash data.<br />
<br />
 Configures the margin field of MARP MARP register with the specified <em>margin</em> level. It changes the margin levels for read operations to find problematic array bits.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga3ce7f5d950394593eace1b812cb791cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ce7f5d950394593eace1b812cb791cc">&#9670;&nbsp;</a></span>XMC_FLASH_SetWaitStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_FLASH_SetWaitStates </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_wait_states</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_wait_states</td><td>number of wait states for initial read access<br />
 Range: [0 to 15]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the number of wait states for initial flash read access.<br />
<br />
 Depending on the configured <em>num_wait_states</em> value into FCON resister <em>WSPFLASH</em> field, the read performance gets optimized . The wait cycles for the flash read access must be configured based on the CPU frequency (fCPU), in relation to the flash access time (<em>ta</em>) defined. The access time formula (<em>WSPFLASH</em> x (<em><em><em>1</em> /</em> fCPU</em>) <em>&gt;=</em> <em>ta</em>) applies only for the values <em><em><em>num_wait_states</em> &gt;0</em>.</em> </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga7adc9bc3ddd27945282bfc576f5fec8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7adc9bc3ddd27945282bfc576f5fec8b">&#9670;&nbsp;</a></span>XMC_FLASH_VerifyReadProtection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_FLASH_VerifyReadProtection </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>password_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>password_1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password_0</td><td>First password used for protection.<br />
 Range: [0 to 4294967295] </td></tr>
    <tr><td class="paramname">password_1</td><td>Second password used for protection.<br />
 Range: [0 to 4294967295]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if read protection installed properly else returns <em>false</em>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Verifies sector read protection is properly installed or not.<br />
<br />
 Before entering into verify read protection process, it clears the error status bits inside status register. It temporarily disables the protection with passwords <em>password0</em> and <em>password1</em> respectively. It reads the FSR register and verifies the protection state. Resumption of read protection after disablement is achieved by XMC_FLASH_ResumeProtection or until next reset.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga422e95387a2c1a457f83bcc494c7ea92">XMC_FLASH_InstallProtection()</a><br />
 <a class="el" href="group___f_l_a_s_h.html#ga80f6c3524cc7951802ec0c300414230e">XMC_FLASH_VerifyWriteProtection()</a><br />
 <a class="el" href="group___f_l_a_s_h.html#gab73556da929b0342c759d63eb3a8096e">XMC_FLASH_ResumeProtection()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga80f6c3524cc7951802ec0c300414230e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80f6c3524cc7951802ec0c300414230e">&#9670;&nbsp;</a></span>XMC_FLASH_VerifyWriteProtection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_FLASH_VerifyWriteProtection </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>protection_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>password_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>password_1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>ID number of the user configuration block (UCB).<br />
 Range: [0 to 2]</td></tr>
    <tr><td class="paramname">protection_mask</td><td>ORed values of <a class="el" href="group___f_l_a_s_h.html#gae606277a956ca47776797dc27ef58005">XMC_FLASH_PROTECTION_t</a> enum type, for which sectors the protection has to be verified. </td></tr>
    <tr><td class="paramname">password_0</td><td>First password used for protection.<br />
 Range: [0 to 4294967295] </td></tr>
    <tr><td class="paramname">password_1</td><td>Second password used for protection.<br />
 Range: [0 to 4294967295]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if write protection installed properly else returns <em>false</em>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Verifies sector read protection is properly installed or not.<br />
<br />
 Before entering into verify read protection process, it clears the error status bits inside status register. It temporarily disables the protection with passwords <em>password0</em> and <em>password1</em> respectively for the intended sectors specified in <em>protection_mask</em>. It reads the FSR register and verifies the write protection state. Resumption of write protection after disablement is achieved by XMC_FLASH_ResumeProtection or until next reset.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___f_l_a_s_h.html#ga422e95387a2c1a457f83bcc494c7ea92">XMC_FLASH_InstallProtection()</a><br />
 <a class="el" href="group___f_l_a_s_h.html#ga7adc9bc3ddd27945282bfc576f5fec8b">XMC_FLASH_VerifyReadProtection()</a><br />
 <a class="el" href="group___f_l_a_s_h.html#gab73556da929b0342c759d63eb3a8096e">XMC_FLASH_ResumeProtection()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga1c9697994a5428b9613030ce2f8299f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c9697994a5428b9613030ce2f8299f6">&#9670;&nbsp;</a></span>XMC_PREFETCH_DisableInstructionBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_PREFETCH_DisableInstructionBuffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Bypasses the instruction buffer for cacheable accesses, by setting the register bit PREF_PCON.IBYP.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga4ca38ea0c4e1defe0e9e84cc8be34a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ca38ea0c4e1defe0e9e84cc8be34a96">&#9670;&nbsp;</a></span>XMC_PREFETCH_EnableInstructionBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_PREFETCH_EnableInstructionBuffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the cacheable accesses to use the instruction buffer by resetting the register bit PREF_PCON.IBYP.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga0d06fb96019945a9e19d18d9ec7b366d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d06fb96019945a9e19d18d9ec7b366d">&#9670;&nbsp;</a></span>XMC_PREFETCH_InvalidateInstructionBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_PREFETCH_InvalidateInstructionBuffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Invalidates the instruction buffer by setting PREF_PCON register bit IINV.<br />
<br />
 After system reset, the instruction buffer is automatically invalidated.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>The complete invalidation operation is performed in a single cycle.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 15 2020 05:49:23 for XMC Peripheral Library for XMC4000 Family by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
