<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XMC Peripheral Library for XMC4000 Family: WDT</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC4000 Family
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">WDT<div class="ingroups"><a class="el" href="group___x_m_clib.html">XMC Peripheral Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___w_d_t___c_o_n_f_i_g__t.html">XMC_WDT_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaed390fe9732c725c40c562096aab71cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gaed390fe9732c725c40c562096aab71cd">XMC_WDT_DEBUG_MODE_t</a> </td></tr>
<tr class="separator:gaed390fe9732c725c40c562096aab71cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8feb4ab4b16a18837346cb43436aa47"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gaf8feb4ab4b16a18837346cb43436aa47">XMC_WDT_MODE_t</a> </td></tr>
<tr class="separator:gaf8feb4ab4b16a18837346cb43436aa47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaec9decd4cc72b82083a1459282f0e601"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gaec9decd4cc72b82083a1459282f0e601">XMC_WDT_ClearAlarm</a> (void)</td></tr>
<tr class="separator:gaec9decd4cc72b82083a1459282f0e601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac46f3f30e3afdc70f673ad61184adf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gaac46f3f30e3afdc70f673ad61184adf6">XMC_WDT_Disable</a> (void)</td></tr>
<tr class="separator:gaac46f3f30e3afdc70f673ad61184adf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6e290c84927a63f326245e1d50bfe18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gaf6e290c84927a63f326245e1d50bfe18">XMC_WDT_Enable</a> (void)</td></tr>
<tr class="separator:gaf6e290c84927a63f326245e1d50bfe18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f47993615bd96ac1c564832826bb5e0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#ga9f47993615bd96ac1c564832826bb5e0">XMC_WDT_GetCounter</a> (void)</td></tr>
<tr class="separator:ga9f47993615bd96ac1c564832826bb5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e875ad3a51f991024fc826dd309d62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#ga44e875ad3a51f991024fc826dd309d62">XMC_WDT_Init</a> (const <a class="el" href="struct_x_m_c___w_d_t___c_o_n_f_i_g__t.html">XMC_WDT_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga44e875ad3a51f991024fc826dd309d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ce909e8a079938c30259381a993d316"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#ga5ce909e8a079938c30259381a993d316">XMC_WDT_Service</a> (void)</td></tr>
<tr class="separator:ga5ce909e8a079938c30259381a993d316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ee071622fac49ddd071a0070bf6c788"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#ga5ee071622fac49ddd071a0070bf6c788">XMC_WDT_SetDebugMode</a> (const <a class="el" href="group___w_d_t.html#gaed390fe9732c725c40c562096aab71cd">XMC_WDT_DEBUG_MODE_t</a> debug_mode)</td></tr>
<tr class="separator:ga5ee071622fac49ddd071a0070bf6c788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4355fd0cb98afd500dc5184f1f636206"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#ga4355fd0cb98afd500dc5184f1f636206">XMC_WDT_SetMode</a> (<a class="el" href="group___w_d_t.html#gaf8feb4ab4b16a18837346cb43436aa47">XMC_WDT_MODE_t</a> mode)</td></tr>
<tr class="separator:ga4355fd0cb98afd500dc5184f1f636206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafde760e88485be382c54241129718c1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gafde760e88485be382c54241129718c1a">XMC_WDT_SetServicePulseWidth</a> (uint8_t service_pulse_width)</td></tr>
<tr class="separator:gafde760e88485be382c54241129718c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30ba72a44f3383261020301cf17bcd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gaf30ba72a44f3383261020301cf17bcd6">XMC_WDT_SetWindowBounds</a> (uint32_t lower_bound, uint32_t upper_bound)</td></tr>
<tr class="separator:gaf30ba72a44f3383261020301cf17bcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01935f7e01dcc6697efe642d64e0053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gad01935f7e01dcc6697efe642d64e0053">XMC_WDT_Start</a> (void)</td></tr>
<tr class="separator:gad01935f7e01dcc6697efe642d64e0053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabc4465fb821a3e6e778503fc2f59bfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___w_d_t.html#gaabc4465fb821a3e6e778503fc2f59bfe">XMC_WDT_Stop</a> (void)</td></tr>
<tr class="separator:gaabc4465fb821a3e6e778503fc2f59bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The watchdog unit (WDT) improves the system integrity, by triggering the system reset request to bring the system back from the unresponsive state to normal operation.</p>
<p>This LLD provides the Configuration structure <a class="el" href="struct_x_m_c___w_d_t___c_o_n_f_i_g__t.html">XMC_WDT_CONFIG_t</a> and initialization function <a class="el" href="group___w_d_t.html#ga44e875ad3a51f991024fc826dd309d62">XMC_WDT_Init()</a>.<br />
It can be used to:</p><ol type="1">
<li>Start or Stop the watchdog timer. (<a class="el" href="group___w_d_t.html#gad01935f7e01dcc6697efe642d64e0053">XMC_WDT_Start()</a> and <a class="el" href="group___w_d_t.html#gaabc4465fb821a3e6e778503fc2f59bfe">XMC_WDT_Stop()</a>)</li>
<li>Service the watchdog timer. (<a class="el" href="group___w_d_t.html#ga5ce909e8a079938c30259381a993d316">XMC_WDT_Service()</a>)</li>
<li>Configure the service window upper bound and lower bound timing values. (<a class="el" href="group___w_d_t.html#gaf30ba72a44f3383261020301cf17bcd6">XMC_WDT_SetWindowBounds()</a>)</li>
<li>Enable the generation of the pre-warning event for the first overflow of the timer. (<a class="el" href="group___w_d_t.html#ga4355fd0cb98afd500dc5184f1f636206">XMC_WDT_SetMode()</a>)</li>
<li>Clear the pre-warning alarm event. It is mandatory to clear the flag during pre-warning alarm ISR, to stop generating reset request for the second overflow of the timer. (<a class="el" href="group___w_d_t.html#gaec9decd4cc72b82083a1459282f0e601">XMC_WDT_ClearAlarm()</a>)</li>
<li>Suspend the watchdog timer during Debug HALT mode. (<a class="el" href="group___w_d_t.html#ga5ee071622fac49ddd071a0070bf6c788">XMC_WDT_SetDebugMode()</a>)</li>
<li>Configure service indication pulse width.(<a class="el" href="group___w_d_t.html#gafde760e88485be382c54241129718c1a">XMC_WDT_SetServicePulseWidth()</a>) </li>
</ol>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaed390fe9732c725c40c562096aab71cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed390fe9732c725c40c562096aab71cd">&#9670;&nbsp;</a></span>XMC_WDT_DEBUG_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___w_d_t.html#gaed390fe9732c725c40c562096aab71cd">XMC_WDT_DEBUG_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines debug behaviour of watchdog when the CPU enters HALT mode. Use type XMC_WDT_DEBUG_MODE_t for this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaed390fe9732c725c40c562096aab71cdabc342504a908273ced690963f2fc555c"></a>XMC_WDT_DEBUG_MODE_STOP&#160;</td><td class="fielddoc"><p>Watchdog counter is paused during debug halt. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed390fe9732c725c40c562096aab71cda0b4c94db55d751206f8aca156afc20c8"></a>XMC_WDT_DEBUG_MODE_RUN&#160;</td><td class="fielddoc"><p>Watchdog counter is not paused during debug halt. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf8feb4ab4b16a18837346cb43436aa47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8feb4ab4b16a18837346cb43436aa47">&#9670;&nbsp;</a></span>XMC_WDT_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___w_d_t.html#gaf8feb4ab4b16a18837346cb43436aa47">XMC_WDT_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines working modes for watchdog. Use type XMC_WDT_MODE_t for this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf8feb4ab4b16a18837346cb43436aa47ada83aa5589e602344357133806fc1bba"></a>XMC_WDT_MODE_TIMEOUT&#160;</td><td class="fielddoc"><p>Generates reset request as soon as the timer overflow occurs. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf8feb4ab4b16a18837346cb43436aa47a2abe0ec0da13065c293da0400e2c0e99"></a>XMC_WDT_MODE_PREWARNING&#160;</td><td class="fielddoc"><p>Generates an alarm event for the first overflow. And reset request after subsequent overflow, if not serviced after first overflow. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaec9decd4cc72b82083a1459282f0e601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec9decd4cc72b82083a1459282f0e601">&#9670;&nbsp;</a></span>XMC_WDT_ClearAlarm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_WDT_ClearAlarm </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Clears pre-warning alarm by setting ALMC bit in WDTCLR register.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>In pre-warning mode, first overflow of the timer upper window bound fires the pre-warning alarm. <a class="el" href="group___w_d_t.html#gaec9decd4cc72b82083a1459282f0e601">XMC_WDT_ClearAlarm()</a> must be invoked to clear the alarm alarm. After clearing of the alarm, watchdog timer must be serviced within valid time window. Otherwise watchdog timer triggers the reset request up on crossing the upper bound value in a subsequent cycle.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___w_d_t.html#ga5ce909e8a079938c30259381a993d316">XMC_WDT_Service()</a>, <a class="el" href="group___w_d_t.html#ga4355fd0cb98afd500dc5184f1f636206">XMC_WDT_SetMode()</a> </dd></dl>

</div>
</div>
<a id="gaac46f3f30e3afdc70f673ad61184adf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac46f3f30e3afdc70f673ad61184adf6">&#9670;&nbsp;</a></span>XMC_WDT_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_WDT_Disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the clock and resets watchdog timer.<br />
 </dd></dl>
<dl class="section user"><dt>Note:</dt><dd><ol type="1">
<li>Resets the registers with default values. So <a class="el" href="group___w_d_t.html#ga44e875ad3a51f991024fc826dd309d62">XMC_WDT_Init()</a> has to be invoked again to configure the watchdog. </li>
</ol>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___w_d_t.html#gaf6e290c84927a63f326245e1d50bfe18">XMC_WDT_Enable()</a> </dd></dl>

</div>
</div>
<a id="gaf6e290c84927a63f326245e1d50bfe18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6e290c84927a63f326245e1d50bfe18">&#9670;&nbsp;</a></span>XMC_WDT_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_WDT_Enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables watchdog clock and releases watchdog reset.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>This API is invoked by <a class="el" href="group___w_d_t.html#ga44e875ad3a51f991024fc826dd309d62">XMC_WDT_Init()</a> and therefore no need to call it explicitly during watchdog initialization sequence. Invoke this API to enable watchdog once again if the watchdog is disabled by invoking <a class="el" href="group___w_d_t.html#gaac46f3f30e3afdc70f673ad61184adf6">XMC_WDT_Disable()</a>.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd><ol type="1">
<li>It is required to configure the watchdog, again after invoking <a class="el" href="group___w_d_t.html#gaac46f3f30e3afdc70f673ad61184adf6">XMC_WDT_Disable()</a>. Since all the registers are reset with default values. </li>
</ol>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___w_d_t.html#ga44e875ad3a51f991024fc826dd309d62">XMC_WDT_Init()</a>, <a class="el" href="group___w_d_t.html#gaac46f3f30e3afdc70f673ad61184adf6">XMC_WDT_Disable()</a> </dd></dl>

</div>
</div>
<a id="ga9f47993615bd96ac1c564832826bb5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f47993615bd96ac1c564832826bb5e0">&#9670;&nbsp;</a></span>XMC_WDT_GetCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_WDT_GetCounter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t Current count value of watchdog timer register (TIM). Range: [0H to FFFFFFFFH]</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Reads current count of timer register (TIM).<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Invoke this API before servicing or feeding the watchdog to check whether count is between lower and upper window bounds.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___w_d_t.html#ga5ce909e8a079938c30259381a993d316">XMC_WDT_Service()</a> </dd></dl>

</div>
</div>
<a id="ga44e875ad3a51f991024fc826dd309d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44e875ad3a51f991024fc826dd309d62">&#9670;&nbsp;</a></span>XMC_WDT_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_WDT_Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___w_d_t___c_o_n_f_i_g__t.html">XMC_WDT_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>pointer to a constant watchdog configuration data structure. Refer data structure <a class="el" href="struct_x_m_c___w_d_t___c_o_n_f_i_g__t.html">XMC_WDT_CONFIG_t</a> for detail.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initializes and configures watchdog with configuration data pointed by <em>config</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>It invokes <a class="el" href="group___w_d_t.html#gaf6e290c84927a63f326245e1d50bfe18">XMC_WDT_Enable()</a> to enable clock and release reset. Then configures the lower and upper window bounds, working mode (timeout/pre-warning), debug behaviour and service request indication pulse width.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd><ol type="1">
<li>With out invoking this <a class="el" href="group___w_d_t.html#ga44e875ad3a51f991024fc826dd309d62">XMC_WDT_Init()</a> or <a class="el" href="group___w_d_t.html#gaf6e290c84927a63f326245e1d50bfe18">XMC_WDT_Enable()</a>, invocation of other APIs like <a class="el" href="group___w_d_t.html#gaf30ba72a44f3383261020301cf17bcd6">XMC_WDT_SetWindowBounds()</a>, <a class="el" href="group___w_d_t.html#ga4355fd0cb98afd500dc5184f1f636206">XMC_WDT_SetMode()</a>, <a class="el" href="group___w_d_t.html#gafde760e88485be382c54241129718c1a">XMC_WDT_SetServicePulseWidth()</a>, <a class="el" href="group___w_d_t.html#ga5ee071622fac49ddd071a0070bf6c788">XMC_WDT_SetDebugMode()</a>, <a class="el" href="group___w_d_t.html#gad01935f7e01dcc6697efe642d64e0053">XMC_WDT_Start()</a>, <a class="el" href="group___w_d_t.html#ga9f47993615bd96ac1c564832826bb5e0">XMC_WDT_GetCounter()</a>, <a class="el" href="group___w_d_t.html#ga5ce909e8a079938c30259381a993d316">XMC_WDT_Service()</a>, <a class="el" href="group___w_d_t.html#gaec9decd4cc72b82083a1459282f0e601">XMC_WDT_ClearAlarm()</a> has no affect. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="ga5ce909e8a079938c30259381a993d316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ce909e8a079938c30259381a993d316">&#9670;&nbsp;</a></span>XMC_WDT_Service()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_WDT_Service </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Services or feeds the watchdog by writing the Magic word in SRV register.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Service watchdog when count value of watchdog timer is between lower and upper window bounds. Successful servicing will reset watchdog timer (TIM register) to 0H and generate service indication pulse.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd><ol type="1">
<li>invoking this API when count value of watchdog timer is less than window lower bound results wrong servicing and immediately triggers reset request.</li>
</ol>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___w_d_t.html#ga9f47993615bd96ac1c564832826bb5e0">XMC_WDT_GetCounter()</a>, <a class="el" href="group___w_d_t.html#gaf30ba72a44f3383261020301cf17bcd6">XMC_WDT_SetWindowBounds()</a>, <a class="el" href="group___w_d_t.html#gafde760e88485be382c54241129718c1a">XMC_WDT_SetServicePulseWidth()</a> </dd></dl>

</div>
</div>
<a id="ga5ee071622fac49ddd071a0070bf6c788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ee071622fac49ddd071a0070bf6c788">&#9670;&nbsp;</a></span>XMC_WDT_SetDebugMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_WDT_SetDebugMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___w_d_t.html#gaed390fe9732c725c40c562096aab71cd">XMC_WDT_DEBUG_MODE_t</a>&#160;</td>
          <td class="paramname"><em>debug_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">debug_mode</td><td>running state of watchdog during debug halt mode. Refer <a class="el" href="group___w_d_t.html#gaed390fe9732c725c40c562096aab71cd">XMC_WDT_DEBUG_MODE_t</a> for valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets debug behaviour of watchdog by modifying DSP bit of CTR register.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Depending upon DSP bit, the watchdog timer stops when CPU is in HALT mode. The debug behaviour is initially set as XMC_WDT_DEBUG_MODE_STOP during initialization in <a class="el" href="group___w_d_t.html#ga44e875ad3a51f991024fc826dd309d62">XMC_WDT_Init()</a>. Invoke this API to change the debug behaviour as needed later in the program. </dd></dl>

</div>
</div>
<a id="ga4355fd0cb98afd500dc5184f1f636206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4355fd0cb98afd500dc5184f1f636206">&#9670;&nbsp;</a></span>XMC_WDT_SetMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_WDT_SetMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t.html#gaf8feb4ab4b16a18837346cb43436aa47">XMC_WDT_MODE_t</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>is one of the working modes of the watchdog timer, i.e timeout or pre-warning. Refer <a class="el" href="group___w_d_t.html#gaf8feb4ab4b16a18837346cb43436aa47">XMC_WDT_MODE_t</a> for valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets watchdog working mode (timeout or pre-warning) by updating PRE bit of CTR register.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>The working mode is set during initialization in <a class="el" href="group___w_d_t.html#ga44e875ad3a51f991024fc826dd309d62">XMC_WDT_Init()</a>. Invoke this API to alter the mode as needed later in the program. </dd></dl>

</div>
</div>
<a id="gafde760e88485be382c54241129718c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafde760e88485be382c54241129718c1a">&#9670;&nbsp;</a></span>XMC_WDT_SetServicePulseWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_WDT_SetServicePulseWidth </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>service_pulse_width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_pulse_width</td><td>specifies Service indication pulse width in terms of fwdt. Range: [0H â€“ FFH]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets service indication pulse width by updating SPW bit field of CTR register.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>The service indication pulse (with width service_pulse_width + 1 in fwdt cycles) is generated on successful servicing or feeding of watchdog. The pulse width is initially set during initialization in <a class="el" href="group___w_d_t.html#ga44e875ad3a51f991024fc826dd309d62">XMC_WDT_Init()</a>. Invoke this API to alter the width as needed later in the program. </dd></dl>

</div>
</div>
<a id="gaf30ba72a44f3383261020301cf17bcd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf30ba72a44f3383261020301cf17bcd6">&#9670;&nbsp;</a></span>XMC_WDT_SetWindowBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_WDT_SetWindowBounds </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower_bound</td><td>specifies watchdog window lower bound in terms of watchdog clock (fWDT) cycles. Range: [0H to FFFFFFFFH]. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>specifies watchdog window upper bound in terms of watchdog clock (fWDT) cycles. Range: [0H to FFFFFFFFH].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets watchdog window lower and upper bounds by updating WLB and WUB registers.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Window lower and upper bounds are set during initialization in <a class="el" href="group___w_d_t.html#ga44e875ad3a51f991024fc826dd309d62">XMC_WDT_Init()</a>. Invoke this API to alter the values as needed later in the program. This upper bound and lower bound can be calculated by using the below formula<br />
 upper_bound or lower_bound = desired_boundary_time(sec) * fwdt(hz)</dd></dl>
<dl class="section user"><dt>Note:</dt><dd><ol type="1">
<li>Always ensure that upper_bound is greater than the lower_bound value. If not, whenever timer crosses the upper_bound value it triggers the reset(wdt_rst_req) of the controller. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="gad01935f7e01dcc6697efe642d64e0053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad01935f7e01dcc6697efe642d64e0053">&#9670;&nbsp;</a></span>XMC_WDT_Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_WDT_Start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Start the watchdog timer by setting ENB bit of CTR register.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Invoke this API to start the watchdog after initialization, or to resume the watchdog when paused by invoking <a class="el" href="group___w_d_t.html#gaabc4465fb821a3e6e778503fc2f59bfe">XMC_WDT_Stop()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___w_d_t.html#ga44e875ad3a51f991024fc826dd309d62">XMC_WDT_Init()</a>, <a class="el" href="group___w_d_t.html#gaabc4465fb821a3e6e778503fc2f59bfe">XMC_WDT_Stop()</a> </dd></dl>

</div>
</div>
<a id="gaabc4465fb821a3e6e778503fc2f59bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabc4465fb821a3e6e778503fc2f59bfe">&#9670;&nbsp;</a></span>XMC_WDT_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_WDT_Stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Pauses watchdog timer by resetting ENB bit of CTR register.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Invoke this API to pause the watchdog as needed in the program e.g. debugging through software control.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___w_d_t.html#ga44e875ad3a51f991024fc826dd309d62">XMC_WDT_Init()</a>, <a class="el" href="group___w_d_t.html#gaabc4465fb821a3e6e778503fc2f59bfe">XMC_WDT_Stop()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 15 2020 05:49:23 for XMC Peripheral Library for XMC4000 Family by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
