<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XMC Peripheral Library for XMC4000 Family: Inter IC Sound (IIS)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC4000 Family</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___i2_s.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Inter IC Sound (IIS)</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___i2_s___c_h___c_o_n_f_i_g__t.html">XMC_I2S_CH_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaca9db6d0386bd723e662653ce19620b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gaca9db6d0386bd723e662653ce19620b2">XMC_I2S0_CH0</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a></td></tr>
<tr class="separator:gaca9db6d0386bd723e662653ce19620b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7222d2a24ef59d2ab98f270c6d634d22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga7222d2a24ef59d2ab98f270c6d634d22">XMC_I2S0_CH1</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a></td></tr>
<tr class="separator:ga7222d2a24ef59d2ab98f270c6d634d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66e6fc510d71d8e8cd1fb249dd574749"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga66e6fc510d71d8e8cd1fb249dd574749">XMC_I2S1_CH0</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab3012ea0f6b1dddc5b1c05425e15c4a1">XMC_USIC1_CH0</a></td></tr>
<tr class="separator:ga66e6fc510d71d8e8cd1fb249dd574749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a744cb1b509dffe39efccde9de1fe8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga39a744cb1b509dffe39efccde9de1fe8">XMC_I2S1_CH1</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga8892cec48c6246ff3e470178e4273f99">XMC_USIC1_CH1</a></td></tr>
<tr class="separator:ga39a744cb1b509dffe39efccde9de1fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2052bed13ae87be6b83ee0e2d3697118"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga2052bed13ae87be6b83ee0e2d3697118">XMC_I2S2_CH0</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab79d676f4efb3235bd3d8c977b83b1cf">XMC_USIC2_CH0</a></td></tr>
<tr class="separator:ga2052bed13ae87be6b83ee0e2d3697118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dbf4e63749d2f645a8160712666e618"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga1dbf4e63749d2f645a8160712666e618">XMC_I2S2_CH1</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a></td></tr>
<tr class="separator:ga1dbf4e63749d2f645a8160712666e618"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaab7c4e8e4aa32520307fd34c387a9ee1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gaab7c4e8e4aa32520307fd34c387a9ee1">XMC_I2S_CH_ClearStatusFlag</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t flag)</td></tr>
<tr class="separator:gaab7c4e8e4aa32520307fd34c387a9ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga791fd46fa82e2c4a87eca3ff2e543813"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga791fd46fa82e2c4a87eca3ff2e543813">XMC_I2S_CH_ConfigureShiftClockOutput</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_s.html#ga6cf990895c6ccc01ceaf11c028ad35cc">XMC_I2S_CH_BRG_SHIFT_CLOCK_OUTPUT_t</a> clock_output)</td></tr>
<tr class="separator:ga791fd46fa82e2c4a87eca3ff2e543813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e90979653181ee8ca36366322368d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga84e90979653181ee8ca36366322368d5">XMC_I2S_CH_DisableDataTransmission</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga84e90979653181ee8ca36366322368d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac731fe4fbd6e50a8e0b0a8819d30ed56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gac731fe4fbd6e50a8e0b0a8819d30ed56">XMC_I2S_CH_DisableDelayCompensation</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gac731fe4fbd6e50a8e0b0a8819d30ed56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga624bd3292e9b6ea3bb41689d41fadb27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga624bd3292e9b6ea3bb41689d41fadb27">XMC_I2S_CH_DisableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:ga624bd3292e9b6ea3bb41689d41fadb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad442af0346273424ef742ccd3abe40dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gad442af0346273424ef742ccd3abe40dd">XMC_I2S_CH_DisableInputInversion</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:gad442af0346273424ef742ccd3abe40dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafca8077849ed95bc45949481d3110659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gafca8077849ed95bc45949481d3110659">XMC_I2S_CH_DisableMasterClock</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gafca8077849ed95bc45949481d3110659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefff3825c713fe5b9926d2c9f3936430"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gaefff3825c713fe5b9926d2c9f3936430">XMC_I2S_CH_EnableDataTransmission</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gaefff3825c713fe5b9926d2c9f3936430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6484a12dcff80b2055d1b986e8cba28d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga6484a12dcff80b2055d1b986e8cba28d">XMC_I2S_CH_EnableDelayCompensation</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga6484a12dcff80b2055d1b986e8cba28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd5f7a8841af9489527611acdfa1bd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga3dd5f7a8841af9489527611acdfa1bd4">XMC_I2S_CH_EnableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:ga3dd5f7a8841af9489527611acdfa1bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cfdd666f14a7897c24a7e79660179b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga3cfdd666f14a7897c24a7e79660179b5">XMC_I2S_CH_EnableInputInversion</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga3cfdd666f14a7897c24a7e79660179b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99608c0251e3b153d1f71b49350d5c0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga99608c0251e3b153d1f71b49350d5c0c">XMC_I2S_CH_EnableMasterClock</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga99608c0251e3b153d1f71b49350d5c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4302cec4acffcd49bc2178b1b98afcb4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga4302cec4acffcd49bc2178b1b98afcb4">XMC_I2S_CH_GetReceivedData</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga4302cec4acffcd49bc2178b1b98afcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ea6d90429a2ac4de4bbe1db35a7087c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga8ea6d90429a2ac4de4bbe1db35a7087c">XMC_I2S_CH_GetStatusFlag</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga8ea6d90429a2ac4de4bbe1db35a7087c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b4b3f64ebe0ab20c359f6184e923d98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga9b4b3f64ebe0ab20c359f6184e923d98">XMC_I2S_CH_Init</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="struct_x_m_c___i2_s___c_h___c_o_n_f_i_g__t.html">XMC_I2S_CH_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga9b4b3f64ebe0ab20c359f6184e923d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab82202f0981b705a15ab7ed80ddc6b09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gab82202f0981b705a15ab7ed80ddc6b09">XMC_I2S_CH_InitEx</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="struct_x_m_c___i2_s___c_h___c_o_n_f_i_g__t.html">XMC_I2S_CH_CONFIG_t</a> *const config, bool init_brg)</td></tr>
<tr class="separator:gab82202f0981b705a15ab7ed80ddc6b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c7bd3c147219fce76f9c1c61b21898a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga1c7bd3c147219fce76f9c1c61b21898a">XMC_I2S_CH_Receive</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_s.html#ga8e7a5c82ca942de7450cfba67907aa22">XMC_I2S_CH_CHANNEL_t</a> channel_number)</td></tr>
<tr class="separator:ga1c7bd3c147219fce76f9c1c61b21898a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd9b940110725dee4580f570f54028ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gafd9b940110725dee4580f570f54028ab">XMC_I2S_CH_SelectInterruptNodePointer</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_s.html#gaa876770c9147fa5b0ca79b5bbd755ce9">XMC_I2S_CH_INTERRUPT_NODE_POINTER_t</a> interrupt_node, const uint32_t service_request)</td></tr>
<tr class="separator:gafd9b940110725dee4580f570f54028ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff2473a1c092b6cbb61c9996086c2ea9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_s.html#gad79d76187d3de45ba4d8ec7f17989a20">XMC_I2S_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gaff2473a1c092b6cbb61c9996086c2ea9">XMC_I2S_CH_SetBaudrate</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t rate)</td></tr>
<tr class="separator:gaff2473a1c092b6cbb61c9996086c2ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga429db55541512a3a9c61a1f1655a1ee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_s.html#gad79d76187d3de45ba4d8ec7f17989a20">XMC_I2S_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga429db55541512a3a9c61a1f1655a1ee0">XMC_I2S_CH_SetBaudrateEx</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t rate, bool normal_divider_mode)</td></tr>
<tr class="separator:ga429db55541512a3a9c61a1f1655a1ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga365e507fce74d7a9d1f02a00b8db9223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga365e507fce74d7a9d1f02a00b8db9223">XMC_I2S_CH_SetBitOrderLsbFirst</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga365e507fce74d7a9d1f02a00b8db9223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33a3c6090697d5df5038b3c1b5ed1c13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga33a3c6090697d5df5038b3c1b5ed1c13">XMC_I2S_CH_SetBitOrderMsbFirst</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga33a3c6090697d5df5038b3c1b5ed1c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf411f00a4585150d33d3259dfc785ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gacf411f00a4585150d33d3259dfc785ca">XMC_I2S_CH_SetFrameLength</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t frame_length)</td></tr>
<tr class="separator:gacf411f00a4585150d33d3259dfc785ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32572b75a2b528238622cfa91da6239f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga32572b75a2b528238622cfa91da6239f">XMC_I2S_CH_SetInputSource</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a> input, const uint8_t source)</td></tr>
<tr class="separator:ga32572b75a2b528238622cfa91da6239f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8af8cb0639aeede0ab9faead5fa7f55c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga8af8cb0639aeede0ab9faead5fa7f55c">XMC_I2S_CH_SetInterruptNodePointer</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t service_request)</td></tr>
<tr class="separator:ga8af8cb0639aeede0ab9faead5fa7f55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb2198a50935a491a48686d85b53f0bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#gabb2198a50935a491a48686d85b53f0bf">XMC_I2S_CH_SetSystemWordLength</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, uint32_t sclk_cycles_system_word_length)</td></tr>
<tr class="separator:gabb2198a50935a491a48686d85b53f0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55da8db55309c3afb4d9c6f238aeb240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga55da8db55309c3afb4d9c6f238aeb240">XMC_I2S_CH_SetWordLength</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t word_length)</td></tr>
<tr class="separator:ga55da8db55309c3afb4d9c6f238aeb240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga398df3f0a83ceee1c0b2891c6f551da5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga398df3f0a83ceee1c0b2891c6f551da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fab03647f2593b60365e39463fe5cb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_s.html#gad79d76187d3de45ba4d8ec7f17989a20">XMC_I2S_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga1fab03647f2593b60365e39463fe5cb5">XMC_I2S_CH_Stop</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga1fab03647f2593b60365e39463fe5cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga961ec248ea914b53a1e7595f4a0e8d01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga961ec248ea914b53a1e7595f4a0e8d01">XMC_I2S_CH_Transmit</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t data, const <a class="el" href="group___i2_s.html#ga8e7a5c82ca942de7450cfba67907aa22">XMC_I2S_CH_CHANNEL_t</a> channel_number)</td></tr>
<tr class="separator:ga961ec248ea914b53a1e7595f4a0e8d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4332db9df7ffbb91a633d94a05897ac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga4332db9df7ffbb91a633d94a05897ac4">XMC_I2S_CH_TriggerServiceRequest</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t service_request_line)</td></tr>
<tr class="separator:ga4332db9df7ffbb91a633d94a05897ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga356145e003922d6ef50f7aab6a14afe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_s.html#ga356145e003922d6ef50f7aab6a14afe9">XMC_I2S_CH_WordAddressSignalPolarity</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_s.html#gaf06d8ef70b2f776bd0e3f4a4860b6dd4">XMC_I2S_CH_WA_POLARITY_t</a> wa_inversion)</td></tr>
<tr class="separator:ga356145e003922d6ef50f7aab6a14afe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>USIC IIS Features: <br />
 </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaca9db6d0386bd723e662653ce19620b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca9db6d0386bd723e662653ce19620b2">&#9670;&nbsp;</a></span>XMC_I2S0_CH0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2S0_CH0&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC0 channel 0 base address </p>

</div>
</div>
<a id="ga7222d2a24ef59d2ab98f270c6d634d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7222d2a24ef59d2ab98f270c6d634d22">&#9670;&nbsp;</a></span>XMC_I2S0_CH1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2S0_CH1&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC0 channel 1 base address </p>

</div>
</div>
<a id="ga66e6fc510d71d8e8cd1fb249dd574749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66e6fc510d71d8e8cd1fb249dd574749">&#9670;&nbsp;</a></span>XMC_I2S1_CH0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2S1_CH0&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab3012ea0f6b1dddc5b1c05425e15c4a1">XMC_USIC1_CH0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC1 channel 0 base address </p>

</div>
</div>
<a id="ga39a744cb1b509dffe39efccde9de1fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39a744cb1b509dffe39efccde9de1fe8">&#9670;&nbsp;</a></span>XMC_I2S1_CH1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2S1_CH1&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga8892cec48c6246ff3e470178e4273f99">XMC_USIC1_CH1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC1 channel 1 base address </p>

</div>
</div>
<a id="ga2052bed13ae87be6b83ee0e2d3697118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2052bed13ae87be6b83ee0e2d3697118">&#9670;&nbsp;</a></span>XMC_I2S2_CH0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2S2_CH0&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab79d676f4efb3235bd3d8c977b83b1cf">XMC_USIC2_CH0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC2 channel 0 base address </p>

</div>
</div>
<a id="ga1dbf4e63749d2f645a8160712666e618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dbf4e63749d2f645a8160712666e618">&#9670;&nbsp;</a></span>XMC_I2S2_CH1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2S2_CH1&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC2 channel 1 base address </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga6cf990895c6ccc01ceaf11c028ad35cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cf990895c6ccc01ceaf11c028ad35cc">&#9670;&nbsp;</a></span>XMC_I2S_CH_BRG_SHIFT_CLOCK_OUTPUT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#ga6cf990895c6ccc01ceaf11c028ad35cc">XMC_I2S_CH_BRG_SHIFT_CLOCK_OUTPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2S Baudrate Generator shift clock output. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6cf990895c6ccc01ceaf11c028ad35ccacd7860ed986e8121655856927aa72deb"></a>XMC_I2S_CH_BRG_SHIFT_CLOCK_OUTPUT_SCLK&#160;</td><td class="fielddoc"><p>Baudrate Generator shift clock output: SCLK </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6cf990895c6ccc01ceaf11c028ad35cca7a8efe245ea1426c808d9d07b8cb392d"></a>XMC_I2S_CH_BRG_SHIFT_CLOCK_OUTPUT_DX1&#160;</td><td class="fielddoc"><p>Clock obtained as input from master: DX1 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga21a01621957ee4befb0742623b7deaf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21a01621957ee4befb0742623b7deaf8">&#9670;&nbsp;</a></span>XMC_I2S_CH_BUS_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#ga21a01621957ee4befb0742623b7deaf8">XMC_I2S_CH_BUS_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the I2S bus mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga21a01621957ee4befb0742623b7deaf8ac94943f0fe50ea5db0ba76b0e7164ac9"></a>XMC_I2S_CH_BUS_MODE_MASTER&#160;</td><td class="fielddoc"><p>I2S Master </p>
</td></tr>
<tr><td class="fieldname"><a id="gga21a01621957ee4befb0742623b7deaf8a482da8c823c483b895a4c1d35b969372"></a>XMC_I2S_CH_BUS_MODE_SLAVE&#160;</td><td class="fielddoc"><p>I2S Slave </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8e7a5c82ca942de7450cfba67907aa22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e7a5c82ca942de7450cfba67907aa22">&#9670;&nbsp;</a></span>XMC_I2S_CH_CHANNEL_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#ga8e7a5c82ca942de7450cfba67907aa22">XMC_I2S_CH_CHANNEL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the Polarity of the WA in the SELO output lines in relation to the internal WA signal. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8e7a5c82ca942de7450cfba67907aa22a9884bce0586ebf037f9fad4c576b6af9"></a>XMC_I2S_CH_CHANNEL_1_LEFT&#160;</td><td class="fielddoc"><p>Channel 1 (left) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8e7a5c82ca942de7450cfba67907aa22a8aa09ec1ebaa2f86cd923b3c5a22967c"></a>XMC_I2S_CH_CHANNEL_2_RIGHT&#160;</td><td class="fielddoc"><p>Channel 2 (right) </p>
</td></tr>
</table>

</div>
</div>
<a id="ga0519dc913371e5e1b2fb93602e8af7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0519dc913371e5e1b2fb93602e8af7eb">&#9670;&nbsp;</a></span>XMC_I2S_CH_EVENT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#ga0519dc913371e5e1b2fb93602e8af7eb">XMC_I2S_CH_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2S events. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0519dc913371e5e1b2fb93602e8af7eba6f555796d0e490cdb8bb21ca6668e9bf"></a>XMC_I2S_CH_EVENT_RECEIVE_START&#160;</td><td class="fielddoc"><p>Receive start event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0519dc913371e5e1b2fb93602e8af7eba2ec499d4478e0288bc8f36fa122760ff"></a>XMC_I2S_CH_EVENT_DATA_LOST&#160;</td><td class="fielddoc"><p>Data lost event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0519dc913371e5e1b2fb93602e8af7eba1c415b086e85445c3b20f60befc35e64"></a>XMC_I2S_CH_EVENT_TRANSMIT_SHIFT&#160;</td><td class="fielddoc"><p>Transmit shift event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0519dc913371e5e1b2fb93602e8af7ebae050d22d0c6670c83a7b3938445f3ca4"></a>XMC_I2S_CH_EVENT_TRANSMIT_BUFFER&#160;</td><td class="fielddoc"><p>Transmit buffer event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0519dc913371e5e1b2fb93602e8af7eba103fe11c9572f6b4f5416a7203cae51f"></a>XMC_I2S_CH_EVENT_STANDARD_RECEIVE&#160;</td><td class="fielddoc"><p>Receive event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0519dc913371e5e1b2fb93602e8af7eba451277b6303c2d2fe97f3160d73811c6"></a>XMC_I2S_CH_EVENT_ALTERNATIVE_RECEIVE&#160;</td><td class="fielddoc"><p>Alternate receive event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0519dc913371e5e1b2fb93602e8af7eba5f773a997f74338bff7f899bf84e31da"></a>XMC_I2S_CH_EVENT_BAUD_RATE_GENERATOR&#160;</td><td class="fielddoc"><p>Baudrate generator event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0519dc913371e5e1b2fb93602e8af7eba6f2c0491e36b530b7f0f372c0e0562c1"></a>XMC_I2S_CH_EVENT_WA_FALLING_EDGE&#160;</td><td class="fielddoc"><p>WA falling edge event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0519dc913371e5e1b2fb93602e8af7eba22b218a082c9d70ce83289158ff66501"></a>XMC_I2S_CH_EVENT_WA_RISING_EDGE&#160;</td><td class="fielddoc"><p>WA rising edge event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0519dc913371e5e1b2fb93602e8af7eba7cc0ddea3695a17c27747b418e7b16a1"></a>XMC_I2S_CH_EVENT_WA_GENERATION_END&#160;</td><td class="fielddoc"><p>END event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0519dc913371e5e1b2fb93602e8af7ebaeec8987e03c66150a84fc0ca021330d1"></a>XMC_I2S_CH_EVENT_DX2TIEN_ACTIVATED&#160;</td><td class="fielddoc"><p>WA input signal transition event </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf92c3536e625729aefc26a87ca915fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf92c3536e625729aefc26a87ca915fa1">&#9670;&nbsp;</a></span>XMC_I2S_CH_INPUT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2S input stage selection. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf92c3536e625729aefc26a87ca915fa1a1f1c8603d2a16dd28d10fc20e07e0f23"></a>XMC_I2S_CH_INPUT_DIN0&#160;</td><td class="fielddoc"><p>Data input stage 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf92c3536e625729aefc26a87ca915fa1aa489eba5dd199e2763f913d9cd182ad0"></a>XMC_I2S_CH_INPUT_SLAVE_SCLKIN&#160;</td><td class="fielddoc"><p>Clock input stage </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf92c3536e625729aefc26a87ca915fa1aa2078ff62f39e669f5d7359edc2daa10"></a>XMC_I2S_CH_INPUT_SLAVE_WA&#160;</td><td class="fielddoc"><p>WA input stage </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf92c3536e625729aefc26a87ca915fa1a5185333fb09982c55cb169c274486b63"></a>XMC_I2S_CH_INPUT_DIN1&#160;</td><td class="fielddoc"><p>Data input stage 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf92c3536e625729aefc26a87ca915fa1a42fbab05215695e05b455624d9b18823"></a>XMC_I2S_CH_INPUT_DIN2&#160;</td><td class="fielddoc"><p>Data input stage 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf92c3536e625729aefc26a87ca915fa1a2f5da0034674287460fcd83cf7512660"></a>XMC_I2S_CH_INPUT_DIN3&#160;</td><td class="fielddoc"><p>Data input stage 3 </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa876770c9147fa5b0ca79b5bbd755ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa876770c9147fa5b0ca79b5bbd755ce9">&#9670;&nbsp;</a></span>XMC_I2S_CH_INTERRUPT_NODE_POINTER_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#gaa876770c9147fa5b0ca79b5bbd755ce9">XMC_I2S_CH_INTERRUPT_NODE_POINTER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2S channel interrupt node pointers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa876770c9147fa5b0ca79b5bbd755ce9ac00bde3addfb72171f5bd0607fc0426c"></a>XMC_I2S_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT&#160;</td><td class="fielddoc"><p>Node pointer for transmit shift interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa876770c9147fa5b0ca79b5bbd755ce9a57e6d7b8a3d66799258e3ded542a872c"></a>XMC_I2S_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER&#160;</td><td class="fielddoc"><p>Node pointer for transmit buffer interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa876770c9147fa5b0ca79b5bbd755ce9a5675f33e9565e0b87dc10342e3b541ac"></a>XMC_I2S_CH_INTERRUPT_NODE_POINTER_RECEIVE&#160;</td><td class="fielddoc"><p>Node pointer for receive interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa876770c9147fa5b0ca79b5bbd755ce9a9a3f8e7dcd7d67904c74d12b399921f1"></a>XMC_I2S_CH_INTERRUPT_NODE_POINTER_ALTERNATE_RECEIVE&#160;</td><td class="fielddoc"><p>Node pointer for alternate receive interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa876770c9147fa5b0ca79b5bbd755ce9ac8250779e4d8ccf20d17d66421c46660"></a>XMC_I2S_CH_INTERRUPT_NODE_POINTER_PROTOCOL&#160;</td><td class="fielddoc"><p>Node pointer for protocol related interrupts </p>
</td></tr>
</table>

</div>
</div>
<a id="ga86eb677be3865bdf0545767e8818d7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86eb677be3865bdf0545767e8818d7ea">&#9670;&nbsp;</a></span>XMC_I2S_CH_STATUS_FLAG_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#ga86eb677be3865bdf0545767e8818d7ea">XMC_I2S_CH_STATUS_FLAG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2S status flag. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga86eb677be3865bdf0545767e8818d7eaa47a2558d7b0bde69cded893a1fe0078e"></a>XMC_I2S_CH_STATUS_FLAG_WORD_ADDRESS&#160;</td><td class="fielddoc"><p>Word Address status </p>
</td></tr>
<tr><td class="fieldname"><a id="gga86eb677be3865bdf0545767e8818d7eaa202a435971e4df1ebd791b861d727758"></a>XMC_I2S_CH_STATUS_FLAG_DX2S&#160;</td><td class="fielddoc"><p>Status of WA input(DX2) signal </p>
</td></tr>
<tr><td class="fieldname"><a id="gga86eb677be3865bdf0545767e8818d7eaab1530782132d2cf834660a322df93135"></a>XMC_I2S_CH_STATUS_FLAG_DX2T_EVENT_DETECTED&#160;</td><td class="fielddoc"><p>Status for WA input signal transition </p>
</td></tr>
<tr><td class="fieldname"><a id="gga86eb677be3865bdf0545767e8818d7eaa1441fa1c8f4a37644132dc5933293ec7"></a>XMC_I2S_CH_STATUS_FLAG_WA_FALLING_EDGE_EVENT&#160;</td><td class="fielddoc"><p>Falling edge of the WA output signal has been generated </p>
</td></tr>
<tr><td class="fieldname"><a id="gga86eb677be3865bdf0545767e8818d7eaa6a427d736c2dc6e7ab6c29818284c21f"></a>XMC_I2S_CH_STATUS_FLAG_WA_RISING_EDGE_EVENT&#160;</td><td class="fielddoc"><p>Rising edge of the WA output signal has been generated </p>
</td></tr>
<tr><td class="fieldname"><a id="gga86eb677be3865bdf0545767e8818d7eaaf54ccb4a544ffa1218f043e1cbbda580"></a>XMC_I2S_CH_STATUS_FLAG_WA_GENERATION_END&#160;</td><td class="fielddoc"><p>The WA generation has ended </p>
</td></tr>
<tr><td class="fieldname"><a id="gga86eb677be3865bdf0545767e8818d7eaa3afcb8e827cc2c2feed7d6cca2f6ed0f"></a>XMC_I2S_CH_STATUS_FLAG_RECEIVER_START_INDICATION&#160;</td><td class="fielddoc"><p>Receive start indication status </p>
</td></tr>
<tr><td class="fieldname"><a id="gga86eb677be3865bdf0545767e8818d7eaa2c33679c1d063d0705c837accd1eb368"></a>XMC_I2S_CH_STATUS_FLAG_DATA_LOST_INDICATION&#160;</td><td class="fielddoc"><p>Data lost indication status </p>
</td></tr>
<tr><td class="fieldname"><a id="gga86eb677be3865bdf0545767e8818d7eaad1d427bdbccec03368967c462e2c5a07"></a>XMC_I2S_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION&#160;</td><td class="fielddoc"><p>Transmit shift indication status </p>
</td></tr>
<tr><td class="fieldname"><a id="gga86eb677be3865bdf0545767e8818d7eaa681237dd41b82191e802ae34223f4d6d"></a>XMC_I2S_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION&#160;</td><td class="fielddoc"><p>Transmit buffer indication status </p>
</td></tr>
<tr><td class="fieldname"><a id="gga86eb677be3865bdf0545767e8818d7eaace4b8f986d8321f8c6d3596c63a29640"></a>XMC_I2S_CH_STATUS_FLAG_RECEIVE_INDICATION&#160;</td><td class="fielddoc"><p>Receive indication status </p>
</td></tr>
<tr><td class="fieldname"><a id="gga86eb677be3865bdf0545767e8818d7eaaf4bb61d7a7b20500af6662cc7a1f8053"></a>XMC_I2S_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION&#160;</td><td class="fielddoc"><p>Alternate receive indication status </p>
</td></tr>
<tr><td class="fieldname"><a id="gga86eb677be3865bdf0545767e8818d7eaa5892fcb5ffa53ea6361d0ad145be183e"></a>XMC_I2S_CH_STATUS_FLAG_BAUD_RATE_GENERATOR_INDICATION&#160;</td><td class="fielddoc"><p>Baud rate generator indication status </p>
</td></tr>
</table>

</div>
</div>
<a id="gad79d76187d3de45ba4d8ec7f17989a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad79d76187d3de45ba4d8ec7f17989a20">&#9670;&nbsp;</a></span>XMC_I2S_CH_STATUS_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#gad79d76187d3de45ba4d8ec7f17989a20">XMC_I2S_CH_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2S Status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad79d76187d3de45ba4d8ec7f17989a20aefa3783742bd11437e465de7cf19b9d0"></a>XMC_I2S_CH_STATUS_OK&#160;</td><td class="fielddoc"><p>Status OK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad79d76187d3de45ba4d8ec7f17989a20a274f43657b1d0d60d6a4a3979025f6f0"></a>XMC_I2S_CH_STATUS_ERROR&#160;</td><td class="fielddoc"><p>Status ERROR </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad79d76187d3de45ba4d8ec7f17989a20ad630d122134df50be10aaa7aeb01cf80"></a>XMC_I2S_CH_STATUS_BUSY&#160;</td><td class="fielddoc"><p>Status BUSY </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf06d8ef70b2f776bd0e3f4a4860b6dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf06d8ef70b2f776bd0e3f4a4860b6dd4">&#9670;&nbsp;</a></span>XMC_I2S_CH_WA_POLARITY_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_s.html#gaf06d8ef70b2f776bd0e3f4a4860b6dd4">XMC_I2S_CH_WA_POLARITY_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the Polarity of the WA in the SELO output lines in relation to the internal WA signal. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf06d8ef70b2f776bd0e3f4a4860b6dd4aad9792a6807914460708783fca529b97"></a>XMC_I2S_CH_WA_POLARITY_DIRECT&#160;</td><td class="fielddoc"><p>The SELO outputs have the same polarity as the WA signal (active high) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf06d8ef70b2f776bd0e3f4a4860b6dd4aee02f33af07c1e12c1feea0b77d4c1eb"></a>XMC_I2S_CH_WA_POLARITY_INVERTED&#160;</td><td class="fielddoc"><p>The SELO outputs have the inverted polarity to the WA signal (active low) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaab7c4e8e4aa32520307fd34c387a9ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab7c4e8e4aa32520307fd34c387a9ee1">&#9670;&nbsp;</a></span>XMC_I2S_CH_ClearStatusFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_ClearStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">flag</td><td>Protocol event status to be cleared for detection of next occurence. Refer @ XMC_I2S_CH_STATUS_FLAG_t for valid values. <b>OR</b> combinations of these enum item can be used as input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Clears the events specified, by setting PSCR register.<br />
<br />
During communication the events occurred have to be cleared to detect their next occurence.<br />
e.g: During transmission Transmit buffer event occurs to indicating data word transfer has started. This event has to be cleared after transmission of each data word. Otherwise next event cannot be recognized.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga8ea6d90429a2ac4de4bbe1db35a7087c">XMC_I2S_CH_GetStatusFlag()</a> </dd></dl>

</div>
</div>
<a id="ga791fd46fa82e2c4a87eca3ff2e543813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga791fd46fa82e2c4a87eca3ff2e543813">&#9670;&nbsp;</a></span>XMC_I2S_CH_ConfigureShiftClockOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_ConfigureShiftClockOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_s.html#ga6cf990895c6ccc01ceaf11c028ad35cc">XMC_I2S_CH_BRG_SHIFT_CLOCK_OUTPUT_t</a>&#160;</td>
          <td class="paramname"><em>clock_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">clock_output</td><td>shift clock source.<br />
 Refer <a class="el" href="group___i2_s.html#ga6cf990895c6ccc01ceaf11c028ad35cc">XMC_I2S_CH_BRG_SHIFT_CLOCK_OUTPUT_t</a> for valid inputs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the shift clock source by setting BRG.SCLKOSEL.<br />
<br />
In Master mode operation, shift clock is generated by the internal baud rate generator. This SCLK is made available for external slave devices by SCLKOUT signal.<br />
In Slave mode, the signal is received from the external master. So the DX1(input) stage has to be connected to input.<br />
</dd></dl>

</div>
</div>
<a id="ga84e90979653181ee8ca36366322368d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84e90979653181ee8ca36366322368d5">&#9670;&nbsp;</a></span>XMC_I2S_CH_DisableDataTransmission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_DisableDataTransmission </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_s.html#gaca9db6d0386bd723e662653ce19620b2">XMC_I2S0_CH0</a>, <a class="el" href="group___i2_s.html#ga7222d2a24ef59d2ab98f270c6d634d22">XMC_I2S0_CH1</a>,<a class="el" href="group___i2_s.html#ga66e6fc510d71d8e8cd1fb249dd574749">XMC_I2S1_CH0</a>,<a class="el" href="group___i2_s.html#ga39a744cb1b509dffe39efccde9de1fe8">XMC_I2S1_CH1</a>,<a class="el" href="group___i2_s.html#ga2052bed13ae87be6b83ee0e2d3697118">XMC_I2S2_CH0</a>,<a class="el" href="group___i2_s.html#ga1dbf4e63749d2f645a8160712666e618">XMC_I2S2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of I2S1 and I2S2 depends on device selection </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disable data transmission.<br />
<br />
Use this function in combination with <a class="el" href="group___i2_s.html#gaefff3825c713fe5b9926d2c9f3936430">XMC_I2S_CH_EnableDataTransmission()</a> to fill the FIFO and send the FIFO content without gaps in the transmission. FIFO is filled using <a class="el" href="group___u_s_i_c.html#gae96e9afeaefe2585b687e36f6227727f">XMC_USIC_CH_TXFIFO_PutData()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#gaefff3825c713fe5b9926d2c9f3936430">XMC_I2S_CH_EnableDataTransmission()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gac731fe4fbd6e50a8e0b0a8819d30ed56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac731fe4fbd6e50a8e0b0a8819d30ed56">&#9670;&nbsp;</a></span>XMC_I2S_CH_DisableDelayCompensation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_DisableDelayCompensation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_s.html#gaca9db6d0386bd723e662653ce19620b2">XMC_I2S0_CH0</a>, <a class="el" href="group___i2_s.html#ga7222d2a24ef59d2ab98f270c6d634d22">XMC_I2S0_CH1</a>,<a class="el" href="group___i2_s.html#ga66e6fc510d71d8e8cd1fb249dd574749">XMC_I2S1_CH0</a>,<a class="el" href="group___i2_s.html#ga39a744cb1b509dffe39efccde9de1fe8">XMC_I2S1_CH1</a>,<a class="el" href="group___i2_s.html#ga2052bed13ae87be6b83ee0e2d3697118">XMC_I2S2_CH0</a>,<a class="el" href="group___i2_s.html#ga1dbf4e63749d2f645a8160712666e618">XMC_I2S2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of I2S1 and I2S2 depends on device selection </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables delay compensation.. <br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga6484a12dcff80b2055d1b986e8cba28d">XMC_I2S_CH_EnableDelayCompensation()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga624bd3292e9b6ea3bb41689d41fadb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga624bd3292e9b6ea3bb41689d41fadb27">&#9670;&nbsp;</a></span>XMC_I2S_CH_DisableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_DisableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">event</td><td>Protocol events which have to be disabled. Refer @ XMC_I2S_CH_EVENT_t for valid values. <b>OR</b> combinations of these enum item can be used as input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the I2S protocol specific events, by configuring PCR register.<br />
<br />
After disabling the events, <a class="el" href="group___i2_s.html#ga3dd5f7a8841af9489527611acdfa1bd4">XMC_I2S_CH_EnableEvent()</a> has to be invoked to re-enable the events.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga3dd5f7a8841af9489527611acdfa1bd4">XMC_I2S_CH_EnableEvent()</a> </dd></dl>

</div>
</div>
<a id="gad442af0346273424ef742ccd3abe40dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad442af0346273424ef742ccd3abe40dd">&#9670;&nbsp;</a></span>XMC_I2S_CH_DisableInputInversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_DisableInputInversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">input</td><td>I2S channel input stage.<br />
 Refer <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a> for valid inputs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the polarity inversion of input data signal, by clearing DXyCR.DPOL(where y = <em>input</em>).<br />
<br />
Resets the input data polarity. Invoke <a class="el" href="group___i2_s.html#ga3cfdd666f14a7897c24a7e79660179b5">XMC_I2S_CH_EnableInputInversion()</a> to apply inversion.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga3cfdd666f14a7897c24a7e79660179b5">XMC_I2S_CH_EnableInputInversion()</a> </dd></dl>

</div>
</div>
<a id="gafca8077849ed95bc45949481d3110659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafca8077849ed95bc45949481d3110659">&#9670;&nbsp;</a></span>XMC_I2S_CH_DisableMasterClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_DisableMasterClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the generation of Master clock by clearing PCR.MCLK bit.<br />
<br />
This clock can be enabled by invoking <a class="el" href="group___i2_s.html#ga99608c0251e3b153d1f71b49350d5c0c">XMC_I2S_CH_EnableMasterClock()</a> as needed in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga99608c0251e3b153d1f71b49350d5c0c">XMC_I2S_CH_EnableMasterClock()</a> </dd></dl>

</div>
</div>
<a id="gaefff3825c713fe5b9926d2c9f3936430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefff3825c713fe5b9926d2c9f3936430">&#9670;&nbsp;</a></span>XMC_I2S_CH_EnableDataTransmission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_EnableDataTransmission </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_s.html#gaca9db6d0386bd723e662653ce19620b2">XMC_I2S0_CH0</a>, <a class="el" href="group___i2_s.html#ga7222d2a24ef59d2ab98f270c6d634d22">XMC_I2S0_CH1</a>,<a class="el" href="group___i2_s.html#ga66e6fc510d71d8e8cd1fb249dd574749">XMC_I2S1_CH0</a>,<a class="el" href="group___i2_s.html#ga39a744cb1b509dffe39efccde9de1fe8">XMC_I2S1_CH1</a>,<a class="el" href="group___i2_s.html#ga2052bed13ae87be6b83ee0e2d3697118">XMC_I2S2_CH0</a>,<a class="el" href="group___i2_s.html#ga1dbf4e63749d2f645a8160712666e618">XMC_I2S2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of I2S1 and I2S2 depends on device selection </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enable data transmission.<br />
<br />
Use this function in combination with <a class="el" href="group___i2_s.html#ga84e90979653181ee8ca36366322368d5">XMC_I2S_CH_DisableDataTransmission()</a> to fill the FIFO and send the FIFO content without gaps in the transmission. FIFO is filled using <a class="el" href="group___u_s_i_c.html#gae96e9afeaefe2585b687e36f6227727f">XMC_USIC_CH_TXFIFO_PutData()</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you need more control over the start of transmission use <a class="el" href="group___u_s_i_c.html#ga3b02352ba5e94e8f79751dea304084e0">XMC_USIC_CH_SetStartTransmisionMode()</a></dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga84e90979653181ee8ca36366322368d5">XMC_I2S_CH_DisableDataTransmission()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga6484a12dcff80b2055d1b986e8cba28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6484a12dcff80b2055d1b986e8cba28d">&#9670;&nbsp;</a></span>XMC_I2S_CH_EnableDelayCompensation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_EnableDelayCompensation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_s.html#gaca9db6d0386bd723e662653ce19620b2">XMC_I2S0_CH0</a>, <a class="el" href="group___i2_s.html#ga7222d2a24ef59d2ab98f270c6d634d22">XMC_I2S0_CH1</a>,<a class="el" href="group___i2_s.html#ga66e6fc510d71d8e8cd1fb249dd574749">XMC_I2S1_CH0</a>,<a class="el" href="group___i2_s.html#ga39a744cb1b509dffe39efccde9de1fe8">XMC_I2S1_CH1</a>,<a class="el" href="group___i2_s.html#ga2052bed13ae87be6b83ee0e2d3697118">XMC_I2S2_CH0</a>,<a class="el" href="group___i2_s.html#ga1dbf4e63749d2f645a8160712666e618">XMC_I2S2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of I2S1 and I2S2 depends on device selection </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables delay compensation. <br />
<br />
 Delay compensation can be applied to the receive path. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#gac731fe4fbd6e50a8e0b0a8819d30ed56">XMC_I2S_CH_DisableDelayCompensation()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga3dd5f7a8841af9489527611acdfa1bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dd5f7a8841af9489527611acdfa1bd4">&#9670;&nbsp;</a></span>XMC_I2S_CH_EnableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_EnableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">event</td><td>Protocol events which have to be enabled. Refer @ XMC_I2S_CH_EVENT_t for valid values. <b>OR</b> combinations of these enum items can be used as input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the I2S protocol specific events, by configuring PCR register.<br />
<br />
Events can be enabled as needed using <a class="el" href="group___i2_s.html#ga3dd5f7a8841af9489527611acdfa1bd4">XMC_I2S_CH_EnableEvent()</a>. <a class="el" href="group___i2_s.html#ga624bd3292e9b6ea3bb41689d41fadb27">XMC_I2S_CH_DisableEvent()</a> can be used to disable the events.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga624bd3292e9b6ea3bb41689d41fadb27">XMC_I2S_CH_DisableEvent()</a> </dd></dl>

</div>
</div>
<a id="ga3cfdd666f14a7897c24a7e79660179b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cfdd666f14a7897c24a7e79660179b5">&#9670;&nbsp;</a></span>XMC_I2S_CH_EnableInputInversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_EnableInputInversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">input</td><td>I2S channel input stage.<br />
 Refer <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a> for valid inputs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the polarity inversion of input data signal, by setting DXyCR.DPOL(where y = <em>input</em>).<br />
<br />
This is not set in <a class="el" href="group___i2_s.html#ga9b4b3f64ebe0ab20c359f6184e923d98">XMC_I2S_CH_Init()</a>. Invoke <a class="el" href="group___i2_s.html#ga3cfdd666f14a7897c24a7e79660179b5">XMC_I2S_CH_EnableInputInversion()</a> as needed later in the program. To disable the inversion <a class="el" href="group___i2_s.html#gad442af0346273424ef742ccd3abe40dd">XMC_I2S_CH_DisableInputInversion()</a> can be invoked.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#gad442af0346273424ef742ccd3abe40dd">XMC_I2S_CH_DisableInputInversion()</a> </dd></dl>

</div>
</div>
<a id="ga99608c0251e3b153d1f71b49350d5c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99608c0251e3b153d1f71b49350d5c0c">&#9670;&nbsp;</a></span>XMC_I2S_CH_EnableMasterClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_EnableMasterClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the generation of Master clock by setting PCR.MCLK bit.<br />
<br />
This clock can be used as a clock reference for external devices. This is not enabled during initialization in <a class="el" href="group___i2_s.html#ga9b4b3f64ebe0ab20c359f6184e923d98">XMC_I2S_CH_Init()</a>. Invoke <a class="el" href="group___i2_s.html#ga99608c0251e3b153d1f71b49350d5c0c">XMC_I2S_CH_EnableMasterClock()</a> to enable as needed in the program, or if it is disabled by <a class="el" href="group___i2_s.html#gafca8077849ed95bc45949481d3110659">XMC_I2S_CH_DisableMasterClock()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#gafca8077849ed95bc45949481d3110659">XMC_I2S_CH_DisableMasterClock()</a> </dd></dl>

</div>
</div>
<a id="ga4302cec4acffcd49bc2178b1b98afcb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4302cec4acffcd49bc2178b1b98afcb4">&#9670;&nbsp;</a></span>XMC_I2S_CH_GetReceivedData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XMC_I2S_CH_GetReceivedData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t Data read from the receive buffer.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Reads data from the receive buffer based on the FIFO selection.<br />
<br />
Invocation of <a class="el" href="group___i2_s.html#ga1c7bd3c147219fce76f9c1c61b21898a">XMC_I2S_CH_Receive()</a> receives the data and place it into receive buffer. After receiving the data <a class="el" href="group___i2_s.html#ga4302cec4acffcd49bc2178b1b98afcb4">XMC_I2S_CH_GetReceivedData()</a> can be used to read the data from the buffer.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga1c7bd3c147219fce76f9c1c61b21898a">XMC_I2S_CH_Receive()</a> </dd></dl>

</div>
</div>
<a id="ga8ea6d90429a2ac4de4bbe1db35a7087c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ea6d90429a2ac4de4bbe1db35a7087c">&#9670;&nbsp;</a></span>XMC_I2S_CH_GetStatusFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_I2S_CH_GetStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t Status of I2S protocol events.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the status of the events, by reading PSR register.<br />
<br />
This indicates the status of the all the events, for I2S communication.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#gaab7c4e8e4aa32520307fd34c387a9ee1">XMC_I2S_CH_ClearStatusFlag()</a> </dd></dl>

</div>
</div>
<a id="ga9b4b3f64ebe0ab20c359f6184e923d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b4b3f64ebe0ab20c359f6184e923d98">&#9670;&nbsp;</a></span>XMC_I2S_CH_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___i2_s___c_h___c_o_n_f_i_g__t.html">XMC_I2S_CH_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_s.html#gaca9db6d0386bd723e662653ce19620b2">XMC_I2S0_CH0</a>, XMC_I2S0_CH1,XMC_I2S1_CH0, XMC_I2S1_CH1,XMC_I2S2_CH0, XMC_I2S2_CH1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of I2S1 and I2S2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Constant pointer to I2S configuration structure of type <a class="el" href="struct_x_m_c___i2_s___c_h___c_o_n_f_i_g__t.html">XMC_I2S_CH_CONFIG_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_I2S_CH_STATUS_t Status of initializing the USIC channel for I2S protocol.<br />
 <b>Range:</b> <a class="el" href="group___i2_s.html#ggad79d76187d3de45ba4d8ec7f17989a20aefa3783742bd11437e465de7cf19b9d0">XMC_I2S_CH_STATUS_OK</a> if initialization is successful.<br />
 <a class="el" href="group___i2_s.html#ggad79d76187d3de45ba4d8ec7f17989a20a274f43657b1d0d60d6a4a3979025f6f0">XMC_I2S_CH_STATUS_ERROR</a> if configuration of baudrate failed.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Initializes the USIC channel for I2S protocol.<br />
<br />
During the initialization, USIC channel is enabled and baudrate is configured. After each change of the WA signal, a complete data frame is intended to be transferred (frame length &lt;= system word length). The number of data bits transferred after a change of signal WA is defined by config-&gt;frame_length. A data frame can consist of several data words with a data word length defined by config-&gt;data_bits. The changes of signal WA define the system word length as the number of SCLK cycles between two changes of WA. The system word length is set by default to the frame length defined by config-&gt;frame_length.</dd></dl>
<p><a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start()</a> should be invoked after the initialization to enable the channel.</p>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start()</a>, <a class="el" href="group___i2_s.html#ga1fab03647f2593b60365e39463fe5cb5">XMC_I2S_CH_Stop()</a>, <a class="el" href="group___i2_s.html#ga961ec248ea914b53a1e7595f4a0e8d01">XMC_I2S_CH_Transmit()</a>, <a class="el" href="group___i2_s.html#gabb2198a50935a491a48686d85b53f0bf">XMC_I2S_CH_SetSystemWordLength()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gab82202f0981b705a15ab7ed80ddc6b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab82202f0981b705a15ab7ed80ddc6b09">&#9670;&nbsp;</a></span>XMC_I2S_CH_InitEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_InitEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___i2_s___c_h___c_o_n_f_i_g__t.html">XMC_I2S_CH_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init_brg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_s.html#gaca9db6d0386bd723e662653ce19620b2">XMC_I2S0_CH0</a>, XMC_I2S0_CH1,XMC_I2S1_CH0, XMC_I2S1_CH1,XMC_I2S2_CH0, XMC_I2S2_CH1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of I2S1 and I2S2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Constant pointer to I2S configuration structure of type <a class="el" href="struct_x_m_c___i2_s___c_h___c_o_n_f_i_g__t.html">XMC_I2S_CH_CONFIG_t</a>. </td></tr>
    <tr><td class="paramname">init_brg</td><td>Selects if the baudrate generator should be configured automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_I2S_CH_STATUS_t Status of initializing the USIC channel for I2S protocol.<br />
 <b>Range:</b> <a class="el" href="group___i2_s.html#ggad79d76187d3de45ba4d8ec7f17989a20aefa3783742bd11437e465de7cf19b9d0">XMC_I2S_CH_STATUS_OK</a> if initialization is successful.<br />
 <a class="el" href="group___i2_s.html#ggad79d76187d3de45ba4d8ec7f17989a20a274f43657b1d0d60d6a4a3979025f6f0">XMC_I2S_CH_STATUS_ERROR</a> if configuration of baudrate failed.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Initializes the USIC channel for I2S protocol.<br />
<br />
During the initialization, USIC channel is enabled and baudrate is configured. After each change of the WA signal, a complete data frame is intended to be transferred (frame length &lt;= system word length). The number of data bits transferred after a change of signal WA is defined by config-&gt;frame_length. A data frame can consist of several data words with a data word length defined by config-&gt;data_bits. The changes of signal WA define the system word length as the number of SCLK cycles between two changes of WA. The system word length is set by default to the frame length defined by config-&gt;frame_length.</dd></dl>
<p><a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start()</a> should be invoked after the initialization to enable the channel.</p>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start()</a>, <a class="el" href="group___i2_s.html#ga1fab03647f2593b60365e39463fe5cb5">XMC_I2S_CH_Stop()</a>, <a class="el" href="group___i2_s.html#ga961ec248ea914b53a1e7595f4a0e8d01">XMC_I2S_CH_Transmit()</a>, <a class="el" href="group___i2_s.html#gabb2198a50935a491a48686d85b53f0bf">XMC_I2S_CH_SetSystemWordLength()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga1c7bd3c147219fce76f9c1c61b21898a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c7bd3c147219fce76f9c1c61b21898a">&#9670;&nbsp;</a></span>XMC_I2S_CH_Receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_Receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_s.html#ga8e7a5c82ca942de7450cfba67907aa22">XMC_I2S_CH_CHANNEL_t</a>&#160;</td>
          <td class="paramname"><em>channel_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">channel_number</td><td>Communication output channel of the I2S, based on this mode TCI(Transmit control information)is updated.<br />
 Refer <a class="el" href="group___i2_s.html#ga8e7a5c82ca942de7450cfba67907aa22">XMC_I2S_CH_CHANNEL_t</a> for valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Transmits a dummy data(FFFFH) to provide clock for slave and receives the data from the slave.<br />
<br />
<a class="el" href="group___i2_s.html#ga1c7bd3c147219fce76f9c1c61b21898a">XMC_I2S_CH_Receive()</a> receives the data and places it into buffer based on the FIFO selection. After reception of data <a class="el" href="group___i2_s.html#ga4302cec4acffcd49bc2178b1b98afcb4">XMC_I2S_CH_GetReceivedData()</a> can be invoked to read the data from the buffers.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga4302cec4acffcd49bc2178b1b98afcb4">XMC_I2S_CH_GetReceivedData()</a> </dd></dl>

</div>
</div>
<a id="gafd9b940110725dee4580f570f54028ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd9b940110725dee4580f570f54028ab">&#9670;&nbsp;</a></span>XMC_I2S_CH_SelectInterruptNodePointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_SelectInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_s.html#gaa876770c9147fa5b0ca79b5bbd755ce9">XMC_I2S_CH_INTERRUPT_NODE_POINTER_t</a>&#160;</td>
          <td class="paramname"><em>interrupt_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_s.html#gaca9db6d0386bd723e662653ce19620b2">XMC_I2S0_CH0</a>, <a class="el" href="group___i2_s.html#ga7222d2a24ef59d2ab98f270c6d634d22">XMC_I2S0_CH1</a>,<a class="el" href="group___i2_s.html#ga66e6fc510d71d8e8cd1fb249dd574749">XMC_I2S1_CH0</a>,<a class="el" href="group___i2_s.html#ga39a744cb1b509dffe39efccde9de1fe8">XMC_I2S1_CH1</a>,<a class="el" href="group___i2_s.html#ga2052bed13ae87be6b83ee0e2d3697118">XMC_I2S2_CH0</a>,<a class="el" href="group___i2_s.html#ga1dbf4e63749d2f645a8160712666e618">XMC_I2S2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of I2S1 and I2S2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interrupt_node</td><td>Interrupt node pointer to be configured. <br />
 <b>Range:</b> <a class="el" href="group___i2_s.html#ggaa876770c9147fa5b0ca79b5bbd755ce9ac00bde3addfb72171f5bd0607fc0426c">XMC_I2S_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT</a>, <a class="el" href="group___i2_s.html#ggaa876770c9147fa5b0ca79b5bbd755ce9a57e6d7b8a3d66799258e3ded542a872c">XMC_I2S_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER</a> etc. </td></tr>
    <tr><td class="paramname">service_request</td><td>Service request number.<br />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the interrupt node for USIC channel events. <br />
<br />
For an event to generate interrupt, node pointer should be configured with service request(SR0, SR1..SR5). The NVIC node gets linked to the interrupt event by doing so.<br />
 Note: NVIC node should be separately enabled to generate the interrupt.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga3dd5f7a8841af9489527611acdfa1bd4">XMC_I2S_CH_EnableEvent()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gaff2473a1c092b6cbb61c9996086c2ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff2473a1c092b6cbb61c9996086c2ea9">&#9670;&nbsp;</a></span>XMC_I2S_CH_SetBaudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_s.html#gad79d76187d3de45ba4d8ec7f17989a20">XMC_I2S_CH_STATUS_t</a> XMC_I2S_CH_SetBaudrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">rate</td><td>Bus speed in bits per second</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_I2S_CH_STATUS_t Status of the I2S driver after the request for setting baudrate is processed. <br />
 XMC_I2S_CH_STATUS_OK- If the baudrate is successfully changed. <br />
 XMC_I2S_CH_STATUS_ERROR- If the new baudrate value is out of range.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the bus speed in bits per second</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga9b4b3f64ebe0ab20c359f6184e923d98">XMC_I2S_CH_Init()</a>, <a class="el" href="group___i2_s.html#ga1fab03647f2593b60365e39463fe5cb5">XMC_I2S_CH_Stop()</a> </dd></dl>

</div>
</div>
<a id="ga429db55541512a3a9c61a1f1655a1ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga429db55541512a3a9c61a1f1655a1ee0">&#9670;&nbsp;</a></span>XMC_I2S_CH_SetBaudrateEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_s.html#gad79d76187d3de45ba4d8ec7f17989a20">XMC_I2S_CH_STATUS_t</a> XMC_I2S_CH_SetBaudrateEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normal_divider_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">rate</td><td>Bus speed in bits per second </td></tr>
    <tr><td class="paramname">normal_divider_mode</td><td>Selects normal divider mode for baudrate generator instead of default fractional divider decreasing jitter at cost of frequency selection</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_I2S_CH_STATUS_t Status of the I2S driver after the request for setting baudrate is processed. <br />
 XMC_I2S_CH_STATUS_OK- If the baudrate is successfully changed. <br />
 XMC_I2S_CH_STATUS_ERROR- If the new baudrate value is out of range.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the bus speed in bits per second</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga9b4b3f64ebe0ab20c359f6184e923d98">XMC_I2S_CH_Init()</a>, <a class="el" href="group___i2_s.html#ga1fab03647f2593b60365e39463fe5cb5">XMC_I2S_CH_Stop()</a> </dd></dl>

</div>
</div>
<a id="ga365e507fce74d7a9d1f02a00b8db9223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga365e507fce74d7a9d1f02a00b8db9223">&#9670;&nbsp;</a></span>XMC_I2S_CH_SetBitOrderLsbFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_SetBitOrderLsbFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Set the order of data transfer from LSB to MSB, by clearing SCTR.SDIR bit.<br />
<br />
This is typically based on the slave settings. Invoke <a class="el" href="group___i2_s.html#ga365e507fce74d7a9d1f02a00b8db9223">XMC_I2S_CH_SetBitOrderLsbFirst()</a> to set direction as needed in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga33a3c6090697d5df5038b3c1b5ed1c13">XMC_I2S_CH_SetBitOrderMsbFirst()</a> </dd></dl>

</div>
</div>
<a id="ga33a3c6090697d5df5038b3c1b5ed1c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33a3c6090697d5df5038b3c1b5ed1c13">&#9670;&nbsp;</a></span>XMC_I2S_CH_SetBitOrderMsbFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_SetBitOrderMsbFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Set the order of data transfer from MSB to LSB, by setting SCTR.SDIR bit.<br />
<br />
This is typically based on the slave settings. This is not set during <a class="el" href="group___i2_s.html#ga9b4b3f64ebe0ab20c359f6184e923d98">XMC_I2S_CH_Init()</a>. Invoke <a class="el" href="group___i2_s.html#ga33a3c6090697d5df5038b3c1b5ed1c13">XMC_I2S_CH_SetBitOrderMsbFirst()</a> to set direction as needed in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga365e507fce74d7a9d1f02a00b8db9223">XMC_I2S_CH_SetBitOrderLsbFirst()</a> </dd></dl>

</div>
</div>
<a id="gacf411f00a4585150d33d3259dfc785ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf411f00a4585150d33d3259dfc785ca">&#9670;&nbsp;</a></span>XMC_I2S_CH_SetFrameLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_SetFrameLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>frame_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">frame_length</td><td>Number of bits in a frame. <br />
 <b>Range:</b> 1 to 64.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Define the data frame length.<br />
<br />
Set the number of bits to be serially transmitted in a frame. The frame length should be multiples of word length.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gabb9d02b8388a03cd28190c976cdb8b78">XMC_USIC_CH_SetWordLength()</a> </dd></dl>

</div>
</div>
<a id="ga32572b75a2b528238622cfa91da6239f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32572b75a2b528238622cfa91da6239f">&#9670;&nbsp;</a></span>XMC_I2S_CH_SetInputSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_SetInputSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">input</td><td>I2S channel input stage.<br />
 Refer <a class="el" href="group___i2_s.html#gaf92c3536e625729aefc26a87ca915fa1">XMC_I2S_CH_INPUT_t</a> for valid values </td></tr>
    <tr><td class="paramname">source</td><td>Input source select for the input stage. Range : [0 to 7]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Selects the data source for I2S input stage, by configuring DXCR.DSEL bits.<br />
<br />
Selects the input data signal source among DXnA, DXnB.. DXnG for the input stage. The API can be used for all the input stages like DX0CR, DX1CR etc. This is not done during initialization. This has to be configured before starting the I2S communication. </dd></dl>

</div>
</div>
<a id="ga8af8cb0639aeede0ab9faead5fa7f55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8af8cb0639aeede0ab9faead5fa7f55c">&#9670;&nbsp;</a></span>XMC_I2S_CH_SetInterruptNodePointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_SetInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">service_request</td><td>Service request number. Range: [0 to 5]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the interrupt node for I2S channel events.<br />
<br />
For an event to generate interrupt, node pointer should be configured with service request(SR0, SR1..SR5). The NVIC node gets linked to the interrupt event by doing so. This is not configured in <a class="el" href="group___i2_s.html#ga9b4b3f64ebe0ab20c359f6184e923d98">XMC_I2S_CH_Init()</a> during initialization.</dd></dl>
<dl class="section user"><dt>Note::</dt><dd><ol type="1">
<li>NVIC node should be separately enabled to generate the interrupt.</li>
</ol>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga6f9467a0f290d65f7292b45cc29e32b4">XMC_USIC_CH_EnableEvent()</a> </dd></dl>

</div>
</div>
<a id="gabb2198a50935a491a48686d85b53f0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb2198a50935a491a48686d85b53f0bf">&#9670;&nbsp;</a></span>XMC_I2S_CH_SetSystemWordLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_SetSystemWordLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sclk_cycles_system_word_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">sclk_cycles_system_word_length</td><td>system word length in terms of sclk clock cycles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the system word length by setting BRG.DCTQ bit field.<br />
<br />
This value has to be always higher than 1U and lower than the data with (SCTR.FLE) </dd></dl>

</div>
</div>
<a id="ga55da8db55309c3afb4d9c6f238aeb240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55da8db55309c3afb4d9c6f238aeb240">&#9670;&nbsp;</a></span>XMC_I2S_CH_SetWordLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_SetWordLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>word_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">word_length</td><td>Number of bits to be configured for a data word. <br />
 <b>Range:</b> 1 to 16.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Defines the data word length.<br />
<br />
Sets the number of bits to represent a data word. Frame length should be a multiple of word length.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#gacf411f00a4585150d33d3259dfc785ca">XMC_I2S_CH_SetFrameLength()</a> </dd></dl>

</div>
</div>
<a id="ga398df3f0a83ceee1c0b2891c6f551da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga398df3f0a83ceee1c0b2891c6f551da5">&#9670;&nbsp;</a></span>XMC_I2S_CH_Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Set the selected USIC channel to operate in I2S mode, by setting CCR.MODE bits.<br />
<br />
It should be executed after <a class="el" href="group___i2_s.html#ga9b4b3f64ebe0ab20c359f6184e923d98">XMC_I2S_CH_Init()</a> during initialization. By invoking <a class="el" href="group___i2_s.html#ga1fab03647f2593b60365e39463fe5cb5">XMC_I2S_CH_Stop()</a>, the MODE is set to IDLE state. Call <a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start()</a> to set the I2S mode again, as needed later in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga9b4b3f64ebe0ab20c359f6184e923d98">XMC_I2S_CH_Init()</a>, <a class="el" href="group___i2_s.html#ga1fab03647f2593b60365e39463fe5cb5">XMC_I2S_CH_Stop()</a> </dd></dl>

</div>
</div>
<a id="ga1fab03647f2593b60365e39463fe5cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fab03647f2593b60365e39463fe5cb5">&#9670;&nbsp;</a></span>XMC_I2S_CH_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_s.html#gad79d76187d3de45ba4d8ec7f17989a20">XMC_I2S_CH_STATUS_t</a> XMC_I2S_CH_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_I2S_CH_STATUS_t Status of the I2S driver after the request for stopping is processed. <br />
 XMC_I2S_CH_STATUS_OK- If the USIC channel is successfully put to IDLE mode. <br />
 XMC_I2S_CH_STATUS_BUSY- If the USIC channel is busy transmitting data.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Set the selected I2S channel to IDLE mode, by clearing CCR.MODE bits.<br />
<br />
After calling XMC_I2S_CH_Stop, channel is IDLE mode. So no communication is supported. <a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start()</a> has to be invoked to start the communication again.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga398df3f0a83ceee1c0b2891c6f551da5">XMC_I2S_CH_Start()</a> </dd></dl>

</div>
</div>
<a id="ga961ec248ea914b53a1e7595f4a0e8d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga961ec248ea914b53a1e7595f4a0e8d01">&#9670;&nbsp;</a></span>XMC_I2S_CH_Transmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_Transmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_s.html#ga8e7a5c82ca942de7450cfba67907aa22">XMC_I2S_CH_CHANNEL_t</a>&#160;</td>
          <td class="paramname"><em>channel_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">data</td><td>Data to be transmitted </td></tr>
    <tr><td class="paramname">channel_number</td><td>Communication output channel of the I2S, based on this channel selection TCI(Transmit control information)is updated.<br />
 Refer <a class="el" href="group___i2_s.html#ga8e7a5c82ca942de7450cfba67907aa22">XMC_I2S_CH_CHANNEL_t</a> for valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Puts the data into FIFO, if FIFO mode is enabled or else into standard buffer, by setting the proper mode.<br />
<br />
TCI(Transmit Control Information) allows dynamic control of output channel during data transfers. To support this auto update, TCSR.WAMD(Automatic WA mode) will be enabled during the initialization using <a class="el" href="group___i2_s.html#ga9b4b3f64ebe0ab20c359f6184e923d98">XMC_I2S_CH_Init()</a> for all modes.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#ga1c7bd3c147219fce76f9c1c61b21898a">XMC_I2S_CH_Receive()</a> </dd></dl>

</div>
</div>
<a id="ga4332db9df7ffbb91a633d94a05897ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4332db9df7ffbb91a633d94a05897ac4">&#9670;&nbsp;</a></span>XMC_I2S_CH_TriggerServiceRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_TriggerServiceRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>service_request_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_s.html#gaca9db6d0386bd723e662653ce19620b2">XMC_I2S0_CH0</a>, <a class="el" href="group___i2_s.html#ga7222d2a24ef59d2ab98f270c6d634d22">XMC_I2S0_CH1</a>,<a class="el" href="group___i2_s.html#ga66e6fc510d71d8e8cd1fb249dd574749">XMC_I2S1_CH0</a>,<a class="el" href="group___i2_s.html#ga39a744cb1b509dffe39efccde9de1fe8">XMC_I2S1_CH1</a>,<a class="el" href="group___i2_s.html#ga2052bed13ae87be6b83ee0e2d3697118">XMC_I2S2_CH0</a>,<a class="el" href="group___i2_s.html#ga1dbf4e63749d2f645a8160712666e618">XMC_I2S2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of I2S1 and I2S2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_request_line</td><td>service request number of the event to be triggered. <br />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Trigger a I2S interrupt service request.<br />
<br />
When the I2S service request is triggered, the NVIC interrupt associated with it will be generated if enabled.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_s.html#gafd9b940110725dee4580f570f54028ab">XMC_I2S_CH_SelectInterruptNodePointer()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga356145e003922d6ef50f7aab6a14afe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga356145e003922d6ef50f7aab6a14afe9">&#9670;&nbsp;</a></span>XMC_I2S_CH_WordAddressSignalPolarity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2S_CH_WordAddressSignalPolarity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_s.html#gaf06d8ef70b2f776bd0e3f4a4860b6dd4">XMC_I2S_CH_WA_POLARITY_t</a>&#160;</td>
          <td class="paramname"><em>wa_inversion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address. </td></tr>
    <tr><td class="paramname">wa_inversion</td><td>Polarity of the word address signal.<br />
 Refer <a class="el" href="group___i2_s.html#gaf06d8ef70b2f776bd0e3f4a4860b6dd4">XMC_I2S_CH_WA_POLARITY_t</a> for valid values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Set the polarity of the word address signal, by configuring PCR.SELINV bit.<br />
<br />
Normally WA signal is active low level signal. This is configured in <a class="el" href="group___i2_s.html#ga9b4b3f64ebe0ab20c359f6184e923d98">XMC_I2S_CH_Init()</a> during initialization. Invoke <a class="el" href="group___i2_s.html#ga356145e003922d6ef50f7aab6a14afe9">XMC_I2S_CH_WordAddressSignalPolarity()</a> with desired settings as needed later in the program. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>XMC Peripheral Library for XMC4000 Family</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
