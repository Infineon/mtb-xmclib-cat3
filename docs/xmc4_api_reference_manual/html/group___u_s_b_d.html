<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XMC Peripheral Library for XMC4000 Family: Universal Serial Bus Device (USBD)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC4000 Family</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___u_s_b_d.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Universal Serial Bus Device (USBD)</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___u_s_b_d___c_a_p_a_b_i_l_i_t_i_e_s__t.html">XMC_USBD_CAPABILITIES_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___u_s_b_d___d_e_v_i_c_e__t.html">XMC_USBD_DEVICE_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___u_s_b_d___d_r_i_v_e_r__t.html">XMC_USBD_DRIVER_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___u_s_b_d___e_p__t.html">XMC_USBD_EP_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___u_s_b_d___s_t_a_t_e__t.html">XMC_USBD_STATE_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___u_s_b_d__t.html">XMC_USBD_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab1c802f6c9e96e1f7da3f74322c208e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gab1c802f6c9e96e1f7da3f74322c208e8">XMC_USBD_ENDPOINT_DIRECTION_MASK</a>&#160;&#160;&#160;(0x80U)</td></tr>
<tr class="separator:gab1c802f6c9e96e1f7da3f74322c208e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8037eaa900c5d1a0ae001af59ccdd265"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga8037eaa900c5d1a0ae001af59ccdd265">XMC_USBD_ENDPOINT_MAX_PACKET_SIZE_MASK</a>&#160;&#160;&#160;(0x07FFU)</td></tr>
<tr class="separator:ga8037eaa900c5d1a0ae001af59ccdd265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga525dd0b1bf8605bfea203b042ca6b108"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga525dd0b1bf8605bfea203b042ca6b108">XMC_USBD_ENDPOINT_NUMBER_MASK</a>&#160;&#160;&#160;(0x0FU)</td></tr>
<tr class="separator:ga525dd0b1bf8605bfea203b042ca6b108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45f97d1784301af706011ec194b7051e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga45f97d1784301af706011ec194b7051e">XMC_USBD_EP_DIR_MASK</a>&#160;&#160;&#160;(0x80U)</td></tr>
<tr class="separator:ga45f97d1784301af706011ec194b7051e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57c582d9481a38d6d13ff06c9f4556a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga57c582d9481a38d6d13ff06c9f4556a0">XMC_USBD_EP_NUM_MASK</a>&#160;&#160;&#160;(0x0FU)</td></tr>
<tr class="separator:ga57c582d9481a38d6d13ff06c9f4556a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa5e2795ac35096a761782612ca72e56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gafa5e2795ac35096a761782612ca72e56">XMC_USBD_MAX_FIFO_SIZE</a>&#160;&#160;&#160;(2048U)</td></tr>
<tr class="separator:gafa5e2795ac35096a761782612ca72e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa793a8df254ec8724b62d3cb4d9e80db"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gaa793a8df254ec8724b62d3cb4d9e80db">XMC_USBD_MAX_PACKET_SIZE</a>&#160;&#160;&#160;(64U)</td></tr>
<tr class="separator:gaa793a8df254ec8724b62d3cb4d9e80db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31089a0a781ac70ae6f1445847ab2683"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga31089a0a781ac70ae6f1445847ab2683">XMC_USBD_MAX_TRANSFER_SIZE_EP0</a>&#160;&#160;&#160;(64U)</td></tr>
<tr class="separator:ga31089a0a781ac70ae6f1445847ab2683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d76d3b99600addc55f489000ff9d23d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga4d76d3b99600addc55f489000ff9d23d">XMC_USBD_NUM_EPS</a>&#160;&#160;&#160;(7U)</td></tr>
<tr class="separator:ga4d76d3b99600addc55f489000ff9d23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af1761f07df3a8bb43b6ee8070f92e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga4af1761f07df3a8bb43b6ee8070f92e9">XMC_USBD_NUM_TX_FIFOS</a>&#160;&#160;&#160;(7U)</td></tr>
<tr class="separator:ga4af1761f07df3a8bb43b6ee8070f92e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga658b3523c9a1a6bfd7a40ea57b1aa7a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga658b3523c9a1a6bfd7a40ea57b1aa7a2">XMC_USBD_SETUP_COUNT</a>&#160;&#160;&#160;(3U)</td></tr>
<tr class="separator:ga658b3523c9a1a6bfd7a40ea57b1aa7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d351b5fc9b8b32dac88369e7d7a4e25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga4d351b5fc9b8b32dac88369e7d7a4e25">XMC_USBD_SETUP_SIZE</a>&#160;&#160;&#160;(8U)</td></tr>
<tr class="separator:ga4d351b5fc9b8b32dac88369e7d7a4e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdb39ab4197b13b6363b14181f081e3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gacdb39ab4197b13b6363b14181f081e3f">XMC_USBD_SPEED_FULL</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="separator:gacdb39ab4197b13b6363b14181f081e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4d1be41d2cd37f5c9367b75a91a517d6"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga4d1be41d2cd37f5c9367b75a91a517d6">XMC_USBD_SignalDeviceEvent_t</a>) (<a class="el" href="group___u_s_b_d.html#gaab5d22fa8b9bbf4d4295ee761ca1150c">XMC_USBD_EVENT_t</a> event)</td></tr>
<tr class="separator:ga4d1be41d2cd37f5c9367b75a91a517d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52dd28acc7e2e09a7d3a48c136f1ecdb"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga52dd28acc7e2e09a7d3a48c136f1ecdb">XMC_USBD_SignalEndpointEvent_t</a>) (uint8_t ep_addr, <a class="el" href="group___u_s_b_d.html#ga6af185b470e216aeb9f5a8f57934c523">XMC_USBD_EP_EVENT_t</a> ep_event)</td></tr>
<tr class="separator:ga52dd28acc7e2e09a7d3a48c136f1ecdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae7245a0620a6bb5fe8249380d14b284c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gae7245a0620a6bb5fe8249380d14b284c">XMC_USBD_ENDPOINT_TYPE_t</a> </td></tr>
<tr class="separator:gae7245a0620a6bb5fe8249380d14b284c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6af185b470e216aeb9f5a8f57934c523"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga6af185b470e216aeb9f5a8f57934c523">XMC_USBD_EP_EVENT_t</a> </td></tr>
<tr class="separator:ga6af185b470e216aeb9f5a8f57934c523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9d04ab6e275df9194533711f3f2fffe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gae9d04ab6e275df9194533711f3f2fffe">XMC_USBD_EVENT_IN_EP_t</a> </td></tr>
<tr class="separator:gae9d04ab6e275df9194533711f3f2fffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae670af5d633ceb13ed361390c49c2128"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gae670af5d633ceb13ed361390c49c2128">XMC_USBD_EVENT_OUT_EP_t</a> </td></tr>
<tr class="separator:gae670af5d633ceb13ed361390c49c2128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab5d22fa8b9bbf4d4295ee761ca1150c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gaab5d22fa8b9bbf4d4295ee761ca1150c">XMC_USBD_EVENT_t</a> </td></tr>
<tr class="separator:gaab5d22fa8b9bbf4d4295ee761ca1150c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2c56426dd4ecb5da943eab0cf08e13"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gaef2c56426dd4ecb5da943eab0cf08e13">XMC_USBD_GRXSTS_PKTSTS_t</a> </td></tr>
<tr class="separator:gaef2c56426dd4ecb5da943eab0cf08e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7e7d0502c559923da7e324160c527a7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gaa7e7d0502c559923da7e324160c527a7">XMC_USBD_MAX_NUM_EPS_t</a> </td></tr>
<tr class="separator:gaa7e7d0502c559923da7e324160c527a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1983ea285c683f63ee535552d9d2ec1e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga1983ea285c683f63ee535552d9d2ec1e">XMC_USBD_SET_ADDRESS_STAGE_t</a> </td></tr>
<tr class="separator:ga1983ea285c683f63ee535552d9d2ec1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ed7a439225ce1a0b56349cf914b8cda"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a> </td></tr>
<tr class="separator:ga2ed7a439225ce1a0b56349cf914b8cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a7468fe227f852bd4835ae2723d7db"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gac1a7468fe227f852bd4835ae2723d7db">XMC_USBD_TRANSFER_MODE_t</a> </td></tr>
<tr class="separator:gac1a7468fe227f852bd4835ae2723d7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0f50121054da395d3685c6ad9ecb0a56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga0f50121054da395d3685c6ad9ecb0a56">XMC_USBD_ClearEvent</a> (<a class="el" href="group___u_s_b_d.html#gaab5d22fa8b9bbf4d4295ee761ca1150c">XMC_USBD_EVENT_t</a> event)</td></tr>
<tr class="separator:ga0f50121054da395d3685c6ad9ecb0a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5f99dc34a65ebd0dd4d5686632702e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gaf5f99dc34a65ebd0dd4d5686632702e7">XMC_USBD_ClearEventINEP</a> (uint32_t event, uint8_t ep_num)</td></tr>
<tr class="separator:gaf5f99dc34a65ebd0dd4d5686632702e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaef35f7f883268c95e15e8849bf3530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gadaef35f7f883268c95e15e8849bf3530">XMC_USBD_ClearEventOUTEP</a> (uint32_t event, uint8_t ep_num)</td></tr>
<tr class="separator:gadaef35f7f883268c95e15e8849bf3530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a46af80a2ac68076e8d82d0b7967613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga5a46af80a2ac68076e8d82d0b7967613">XMC_USBD_DeviceConnect</a> (void)</td></tr>
<tr class="separator:ga5a46af80a2ac68076e8d82d0b7967613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b341bdd4b66740230bda3f94d49052e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga7b341bdd4b66740230bda3f94d49052e">XMC_USBD_DeviceDisconnect</a> (void)</td></tr>
<tr class="separator:ga7b341bdd4b66740230bda3f94d49052e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42cdb3dc1b05ec18cf8687ea88c7c175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_m_c___u_s_b_d___s_t_a_t_e__t.html">XMC_USBD_STATE_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga42cdb3dc1b05ec18cf8687ea88c7c175">XMC_USBD_DeviceGetState</a> (const <a class="el" href="struct_x_m_c___u_s_b_d__t.html">XMC_USBD_t</a> *const obj)</td></tr>
<tr class="separator:ga42cdb3dc1b05ec18cf8687ea88c7c175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cb810be749bfd8e8c733a6e17bd5388"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga0cb810be749bfd8e8c733a6e17bd5388">XMC_USBD_DeviceSetAddress</a> (uint8_t address, <a class="el" href="group___u_s_b_d.html#ga1983ea285c683f63ee535552d9d2ec1e">XMC_USBD_SET_ADDRESS_STAGE_t</a> stage)</td></tr>
<tr class="separator:ga0cb810be749bfd8e8c733a6e17bd5388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c28d84f9afe864fb9dc0e253137ae54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga1c28d84f9afe864fb9dc0e253137ae54">XMC_USBD_Disable</a> (void)</td></tr>
<tr class="separator:ga1c28d84f9afe864fb9dc0e253137ae54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga755920b85d839979d699894e98c13b69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga755920b85d839979d699894e98c13b69">XMC_USBD_Enable</a> (void)</td></tr>
<tr class="separator:ga755920b85d839979d699894e98c13b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaec2e039f617fdbaa50acb34061c5056"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gaaec2e039f617fdbaa50acb34061c5056">XMC_USBD_EnableEventINEP</a> (uint32_t event)</td></tr>
<tr class="separator:gaaec2e039f617fdbaa50acb34061c5056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga215e0c7a10299d26c9f91c6ad06866f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga215e0c7a10299d26c9f91c6ad06866f6">XMC_USBD_EnableEventOUTEP</a> (uint32_t event)</td></tr>
<tr class="separator:ga215e0c7a10299d26c9f91c6ad06866f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga685e20ab2777c403ae1e3463d47f2d53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga685e20ab2777c403ae1e3463d47f2d53">XMC_USBD_EndpointAbort</a> (uint8_t ep_addr)</td></tr>
<tr class="separator:ga685e20ab2777c403ae1e3463d47f2d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ec7cf807c281084ab7022c23617bdcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga1ec7cf807c281084ab7022c23617bdcb">XMC_USBD_EndpointConfigure</a> (uint8_t ep_addr, <a class="el" href="group___u_s_b_d.html#gae7245a0620a6bb5fe8249380d14b284c">XMC_USBD_ENDPOINT_TYPE_t</a> ep_type, uint16_t ep_max_packet_size)</td></tr>
<tr class="separator:ga1ec7cf807c281084ab7022c23617bdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd364e0fd03285bde32bc6359e6bc218"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gafd364e0fd03285bde32bc6359e6bc218">XMC_USBD_EndpointRead</a> (const uint8_t ep_addr, uint8_t *buffer, uint32_t length)</td></tr>
<tr class="separator:gafd364e0fd03285bde32bc6359e6bc218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18f4cb810289187a885e6f04659bc335"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga18f4cb810289187a885e6f04659bc335">XMC_USBD_EndpointReadStart</a> (const uint8_t ep_addr, uint32_t size)</td></tr>
<tr class="separator:ga18f4cb810289187a885e6f04659bc335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b54b58df01ada8156d8449129778f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga6b54b58df01ada8156d8449129778f05">XMC_USBD_EndpointStall</a> (uint8_t ep_addr, bool stall)</td></tr>
<tr class="separator:ga6b54b58df01ada8156d8449129778f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7903550b9130e811d39b55936174cc36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga7903550b9130e811d39b55936174cc36">XMC_USBD_EndpointUnconfigure</a> (uint8_t ep_addr)</td></tr>
<tr class="separator:ga7903550b9130e811d39b55936174cc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27d8052980544dc78f56462fc7c157ba"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga27d8052980544dc78f56462fc7c157ba">XMC_USBD_EndpointWrite</a> (const uint8_t ep_addr, const uint8_t *buffer, uint32_t length)</td></tr>
<tr class="separator:ga27d8052980544dc78f56462fc7c157ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26113550391be8fc0e2678fe0e6e85ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_m_c___u_s_b_d___c_a_p_a_b_i_l_i_t_i_e_s__t.html">XMC_USBD_CAPABILITIES_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga26113550391be8fc0e2678fe0e6e85ff">XMC_USBD_GetCapabilities</a> (void)</td></tr>
<tr class="separator:ga26113550391be8fc0e2678fe0e6e85ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9648d66a9f092562ca5da8754f5ac0"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gace9648d66a9f092562ca5da8754f5ac0">XMC_USBD_GetFrameNumber</a> (void)</td></tr>
<tr class="separator:gace9648d66a9f092562ca5da8754f5ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad24c323055e8e5014835159867878c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gaad24c323055e8e5014835159867878c1">XMC_USBD_Init</a> (<a class="el" href="struct_x_m_c___u_s_b_d__t.html">XMC_USBD_t</a> *obj)</td></tr>
<tr class="separator:gaad24c323055e8e5014835159867878c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga275780df6f1b3acf50c4c51151d228b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga275780df6f1b3acf50c4c51151d228b8">XMC_USBD_IRQHandler</a> (const <a class="el" href="struct_x_m_c___u_s_b_d__t.html">XMC_USBD_t</a> *const obj)</td></tr>
<tr class="separator:ga275780df6f1b3acf50c4c51151d228b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac958c928fc573f39b30126ac2e2828d7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#gac958c928fc573f39b30126ac2e2828d7">XMC_USBD_IsEnumDone</a> (void)</td></tr>
<tr class="separator:gac958c928fc573f39b30126ac2e2828d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21f8d8e728cce37ff9d4898acb2e62cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga21f8d8e728cce37ff9d4898acb2e62cf">XMC_USBD_Uninitialize</a> (void)</td></tr>
<tr class="separator:ga21f8d8e728cce37ff9d4898acb2e62cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga24b0d090ba036e032aba146ca34fc035"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_x_m_c___u_s_b_d___d_r_i_v_e_r__t.html">XMC_USBD_DRIVER_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga24b0d090ba036e032aba146ca34fc035">Driver_USBD0</a></td></tr>
<tr class="separator:ga24b0d090ba036e032aba146ca34fc035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga407e973323123c34ea9c9c04b6899992"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_m_c___u_s_b_d___d_e_v_i_c_e__t.html">XMC_USBD_DEVICE_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_s_b_d.html#ga407e973323123c34ea9c9c04b6899992">xmc_device</a></td></tr>
<tr class="separator:ga407e973323123c34ea9c9c04b6899992"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The USBD is the device driver for the USB0 hardware module on XMC4000 family of microcontrollers. The USB0 module can be used to establish a USB interface between outside world and XMC4000 family of controllers. The USB module includes the following features in device mode:</p><ol type="1">
<li>Complies with the USB 2.0 Specification.</li>
<li>Support for the Full-Speed (12-Mbps) mode.</li>
<li>Supports up to 7 bidirectional endpoints, including control endpoint 0.</li>
<li>Supports SOFs in Full-Speed modes.</li>
<li>Supports clock gating for power saving.</li>
<li>Supports USB suspend/resume.</li>
<li>Supports USB soft disconnect.</li>
<li>Supports DMA mode.</li>
<li>Supports FIFO mode.</li>
</ol>
<p>The below figure shows the overview of USB0 module in XMC4 microntroller. </p><div class="image">
<img src="USB_module_overview.png" alt="USB_module_overview.png"/>
</div>
 <p>The below figure shows the USB device connection of USB0 module. </p><div class="image">
<img src="USB_device_connection.png" alt="USB_device_connection.png"/>
</div>
 <p>The USBD device driver supports the following features:<br />
</p><ol type="1">
<li>Initialize/Uninitialize the USB0 module on XMC4000 device.</li>
<li>Connect the USB device to host.</li>
<li>Get USB device state.</li>
<li>Set the USB device address.</li>
<li>Configure/Unconfigure the USB endpoints.</li>
<li>Stall/Abort the USB endpoints.</li>
<li>USB IN transfers on EP0 and non EP0 endpoints.</li>
<li>USB OUT transfers on EP0 and non EP0 endpoints.</li>
</ol>
<p>The USBD device driver provides the configuration structure <a class="el" href="struct_x_m_c___u_s_b_d__t.html">XMC_USBD_t</a> which user need to configure before initializing the USB.<br />
The following elements of configuration structure need to be initialized before calling the <a class="el" href="group___u_s_b_d.html#gaad24c323055e8e5014835159867878c1">XMC_USBD_Init</a> API:</p><ol type="1">
<li>cb_xmc_device_event of type <a class="el" href="group___u_s_b_d.html#ga4d1be41d2cd37f5c9367b75a91a517d6">XMC_USBD_SignalDeviceEvent_t</a>.</li>
<li>cb_endpoint_event of type <a class="el" href="group___u_s_b_d.html#ga52dd28acc7e2e09a7d3a48c136f1ecdb">XMC_USBD_SignalEndpointEvent_t</a>.</li>
<li>usbd_max_num_eps of type <a class="el" href="group___u_s_b_d.html#gaa7e7d0502c559923da7e324160c527a7">XMC_USBD_MAX_NUM_EPS_t</a>.</li>
<li>usbd_transfer_mode of type <a class="el" href="group___u_s_b_d.html#gac1a7468fe227f852bd4835ae2723d7db">XMC_USBD_TRANSFER_MODE_t</a>. </li>
</ol>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gab1c802f6c9e96e1f7da3f74322c208e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1c802f6c9e96e1f7da3f74322c208e8">&#9670;&nbsp;</a></span>XMC_USBD_ENDPOINT_DIRECTION_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USBD_ENDPOINT_DIRECTION_MASK&#160;&#160;&#160;(0x80U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USB Endpoint direction mask to get the EP direction from address. </p>

</div>
</div>
<a id="ga8037eaa900c5d1a0ae001af59ccdd265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8037eaa900c5d1a0ae001af59ccdd265">&#9670;&nbsp;</a></span>XMC_USBD_ENDPOINT_MAX_PACKET_SIZE_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USBD_ENDPOINT_MAX_PACKET_SIZE_MASK&#160;&#160;&#160;(0x07FFU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USB Endpoint Maximum Packet Size mask </p>

</div>
</div>
<a id="ga525dd0b1bf8605bfea203b042ca6b108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga525dd0b1bf8605bfea203b042ca6b108">&#9670;&nbsp;</a></span>XMC_USBD_ENDPOINT_NUMBER_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USBD_ENDPOINT_NUMBER_MASK&#160;&#160;&#160;(0x0FU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USB Endpoint number mask to get the EP number from address. </p>

</div>
</div>
<a id="ga45f97d1784301af706011ec194b7051e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45f97d1784301af706011ec194b7051e">&#9670;&nbsp;</a></span>XMC_USBD_EP_DIR_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USBD_EP_DIR_MASK&#160;&#160;&#160;(0x80U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USB Endpoint direction mask </p>

</div>
</div>
<a id="ga57c582d9481a38d6d13ff06c9f4556a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57c582d9481a38d6d13ff06c9f4556a0">&#9670;&nbsp;</a></span>XMC_USBD_EP_NUM_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USBD_EP_NUM_MASK&#160;&#160;&#160;(0x0FU)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USB Endpoint number mask. </p>

</div>
</div>
<a id="gafa5e2795ac35096a761782612ca72e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa5e2795ac35096a761782612ca72e56">&#9670;&nbsp;</a></span>XMC_USBD_MAX_FIFO_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USBD_MAX_FIFO_SIZE&#160;&#160;&#160;(2048U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum USBD endpoint fifo size </p>

</div>
</div>
<a id="gaa793a8df254ec8724b62d3cb4d9e80db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa793a8df254ec8724b62d3cb4d9e80db">&#9670;&nbsp;</a></span>XMC_USBD_MAX_PACKET_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USBD_MAX_PACKET_SIZE&#160;&#160;&#160;(64U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum packet size for all endpoints (including ep0) Maximum transfer size for endpoints.</p>
<p>It's based on the maximum payload, due to the fact, that we only can transfer 2^10 - 1 packets and this is less than the transfer size field can hold. </p>

</div>
</div>
<a id="ga31089a0a781ac70ae6f1445847ab2683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31089a0a781ac70ae6f1445847ab2683">&#9670;&nbsp;</a></span>XMC_USBD_MAX_TRANSFER_SIZE_EP0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USBD_MAX_TRANSFER_SIZE_EP0&#160;&#160;&#160;(64U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum transfer size for endpoint 0 </p>

</div>
</div>
<a id="ga4d76d3b99600addc55f489000ff9d23d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d76d3b99600addc55f489000ff9d23d">&#9670;&nbsp;</a></span>XMC_USBD_NUM_EPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USBD_NUM_EPS&#160;&#160;&#160;(7U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of hardware endpoints </p>

</div>
</div>
<a id="ga4af1761f07df3a8bb43b6ee8070f92e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4af1761f07df3a8bb43b6ee8070f92e9">&#9670;&nbsp;</a></span>XMC_USBD_NUM_TX_FIFOS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USBD_NUM_TX_FIFOS&#160;&#160;&#160;(7U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of hardware transmission endpoint fifos </p>

</div>
</div>
<a id="ga658b3523c9a1a6bfd7a40ea57b1aa7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga658b3523c9a1a6bfd7a40ea57b1aa7a2">&#9670;&nbsp;</a></span>XMC_USBD_SETUP_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USBD_SETUP_COUNT&#160;&#160;&#160;(3U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of USB setup packets </p>

</div>
</div>
<a id="ga4d351b5fc9b8b32dac88369e7d7a4e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d351b5fc9b8b32dac88369e7d7a4e25">&#9670;&nbsp;</a></span>XMC_USBD_SETUP_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USBD_SETUP_SIZE&#160;&#160;&#160;(8U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The size of USB setup data </p>

</div>
</div>
<a id="gacdb39ab4197b13b6363b14181f081e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdb39ab4197b13b6363b14181f081e3f">&#9670;&nbsp;</a></span>XMC_USBD_SPEED_FULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_USBD_SPEED_FULL&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Speed Mode. Full Speed </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga4d1be41d2cd37f5c9367b75a91a517d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d1be41d2cd37f5c9367b75a91a517d6">&#9670;&nbsp;</a></span>XMC_USBD_SignalDeviceEvent_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XMC_USBD_SignalDeviceEvent_t) (<a class="el" href="group___u_s_b_d.html#gaab5d22fa8b9bbf4d4295ee761ca1150c">XMC_USBD_EVENT_t</a> event)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USB device/endpoint event function pointersPointer to USB device event call back. Uses type <a class="el" href="group___u_s_b_d.html#gaab5d22fa8b9bbf4d4295ee761ca1150c">XMC_USBD_EVENT_t</a> as the argument of callback. </p>

</div>
</div>
<a id="ga52dd28acc7e2e09a7d3a48c136f1ecdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52dd28acc7e2e09a7d3a48c136f1ecdb">&#9670;&nbsp;</a></span>XMC_USBD_SignalEndpointEvent_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XMC_USBD_SignalEndpointEvent_t) (uint8_t ep_addr, <a class="el" href="group___u_s_b_d.html#ga6af185b470e216aeb9f5a8f57934c523">XMC_USBD_EP_EVENT_t</a> ep_event)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to USB endpoint event call back. Uses type <a class="el" href="group___u_s_b_d.html#ga6af185b470e216aeb9f5a8f57934c523">XMC_USBD_EP_EVENT_t</a> and EP address as the argument of callback. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gae7245a0620a6bb5fe8249380d14b284c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7245a0620a6bb5fe8249380d14b284c">&#9670;&nbsp;</a></span>XMC_USBD_ENDPOINT_TYPE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_b_d.html#gae7245a0620a6bb5fe8249380d14b284c">XMC_USBD_ENDPOINT_TYPE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the options for the USB endpoint type. The values are from the USB 2.0 specification. Use type <a class="el" href="group___u_s_b_d.html#gae7245a0620a6bb5fe8249380d14b284c">XMC_USBD_ENDPOINT_TYPE_t</a> for this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae7245a0620a6bb5fe8249380d14b284cad6e387496d0f904a066bc4ac7ffdf2ca"></a>XMC_USBD_ENDPOINT_TYPE_CONTROL&#160;</td><td class="fielddoc"><p>Control endpoint </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae7245a0620a6bb5fe8249380d14b284caea00e8371dfd7203b9557d5490e8b547"></a>XMC_USBD_ENDPOINT_TYPE_ISOCHRONOUS&#160;</td><td class="fielddoc"><p>Isochronous endpoint </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae7245a0620a6bb5fe8249380d14b284cab242625a605762145cb7f54c11616926"></a>XMC_USBD_ENDPOINT_TYPE_BULK&#160;</td><td class="fielddoc"><p>Bulk endpoint </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae7245a0620a6bb5fe8249380d14b284cab0e04ee932b57daee5524237c55a8169"></a>XMC_USBD_ENDPOINT_TYPE_INTERRUPT&#160;</td><td class="fielddoc"><p>Interrupt endpoint </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6af185b470e216aeb9f5a8f57934c523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6af185b470e216aeb9f5a8f57934c523">&#9670;&nbsp;</a></span>XMC_USBD_EP_EVENT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_b_d.html#ga6af185b470e216aeb9f5a8f57934c523">XMC_USBD_EP_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the generic USB endpoint events. Use type <a class="el" href="group___u_s_b_d.html#ga6af185b470e216aeb9f5a8f57934c523">XMC_USBD_EP_EVENT_t</a> for this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6af185b470e216aeb9f5a8f57934c523aad2323067f37cd025ea812c7e2782f1a"></a>XMC_USBD_EP_EVENT_SETUP&#160;</td><td class="fielddoc"><p>SETUP packet </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6af185b470e216aeb9f5a8f57934c523ad98f0520946b50cd67e99015b9d84d35"></a>XMC_USBD_EP_EVENT_OUT&#160;</td><td class="fielddoc"><p>OUT packet </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6af185b470e216aeb9f5a8f57934c523a1a238282052f9a66736f62e27279ff88"></a>XMC_USBD_EP_EVENT_IN&#160;</td><td class="fielddoc"><p>IN packet </p>
</td></tr>
</table>

</div>
</div>
<a id="gae9d04ab6e275df9194533711f3f2fffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9d04ab6e275df9194533711f3f2fffe">&#9670;&nbsp;</a></span>XMC_USBD_EVENT_IN_EP_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_b_d.html#gae9d04ab6e275df9194533711f3f2fffe">XMC_USBD_EVENT_IN_EP_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the USB IN endpoint events. Use type <a class="el" href="group___u_s_b_d.html#gae9d04ab6e275df9194533711f3f2fffe">XMC_USBD_EVENT_IN_EP_t</a> for this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae9d04ab6e275df9194533711f3f2fffea5282d2ec5170a450542055174d7b1c8f"></a>XMC_USBD_EVENT_IN_EP_TX_COMPLET&#160;</td><td class="fielddoc"><p>USB IN ep transmission complete </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9d04ab6e275df9194533711f3f2fffeacf660faba3964908927d8e692dfcd033"></a>XMC_USBD_EVENT_IN_EP_DISABLED&#160;</td><td class="fielddoc"><p>USB IN ep disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9d04ab6e275df9194533711f3f2fffeadd67d9bee08e07860bf006ab419b58dd"></a>XMC_USBD_EVENT_IN_EP_AHB_ERROR&#160;</td><td class="fielddoc"><p>USB IN ep AHB error </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9d04ab6e275df9194533711f3f2fffeae68c6f0d3558ba6468de8cbd2815e9e6"></a>XMC_USBD_EVENT_IN_EP_TIMEOUT&#160;</td><td class="fielddoc"><p>USB IN ep timeout </p>
</td></tr>
</table>

</div>
</div>
<a id="gae670af5d633ceb13ed361390c49c2128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae670af5d633ceb13ed361390c49c2128">&#9670;&nbsp;</a></span>XMC_USBD_EVENT_OUT_EP_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_b_d.html#gae670af5d633ceb13ed361390c49c2128">XMC_USBD_EVENT_OUT_EP_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the USB OUT endpoint events. Use type <a class="el" href="group___u_s_b_d.html#gae670af5d633ceb13ed361390c49c2128">XMC_USBD_EVENT_OUT_EP_t</a> for this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae670af5d633ceb13ed361390c49c2128aab42b2cc55b7c7544ce82c26af313256"></a>XMC_USBD_EVENT_OUT_EP_TX_COMPLET&#160;</td><td class="fielddoc"><p>USB OUT ep transmission complete </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae670af5d633ceb13ed361390c49c2128a5d88091a27a6c7335750ebc2a9dd999e"></a>XMC_USBD_EVENT_OUT_EP_DISABLED&#160;</td><td class="fielddoc"><p>USB OUT ep disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae670af5d633ceb13ed361390c49c2128a6970257a69bbdd596ea043e1d7475937"></a>XMC_USBD_EVENT_OUT_EP_AHB_ERROR&#160;</td><td class="fielddoc"><p>USB OUT ep AHB error </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae670af5d633ceb13ed361390c49c2128aacdd50c13ea1dbbc9c41f943fe889fed"></a>XMC_USBD_EVENT_OUT_EP_SETUP&#160;</td><td class="fielddoc"><p>USB OUT ep setup </p>
</td></tr>
</table>

</div>
</div>
<a id="gaab5d22fa8b9bbf4d4295ee761ca1150c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab5d22fa8b9bbf4d4295ee761ca1150c">&#9670;&nbsp;</a></span>XMC_USBD_EVENT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_b_d.html#gaab5d22fa8b9bbf4d4295ee761ca1150c">XMC_USBD_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the USB Device events. Use type <a class="el" href="group___u_s_b_d.html#gaab5d22fa8b9bbf4d4295ee761ca1150c">XMC_USBD_EVENT_t</a> for this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaab5d22fa8b9bbf4d4295ee761ca1150ca26083e0907c204498dc256d2d7672f50"></a>XMC_USBD_EVENT_POWER_ON&#160;</td><td class="fielddoc"><p>USB Device Power On </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab5d22fa8b9bbf4d4295ee761ca1150ca75f695425041a9808d76726a75fc0c98"></a>XMC_USBD_EVENT_POWER_OFF&#160;</td><td class="fielddoc"><p>USB Device Power Off </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab5d22fa8b9bbf4d4295ee761ca1150ca71edcf809669023763055b5b4040afaf"></a>XMC_USBD_EVENT_CONNECT&#160;</td><td class="fielddoc"><p>USB Device connected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab5d22fa8b9bbf4d4295ee761ca1150caced5b43e4893c849a2bfec634603ab27"></a>XMC_USBD_EVENT_DISCONNECT&#160;</td><td class="fielddoc"><p>USB Device disconnected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab5d22fa8b9bbf4d4295ee761ca1150ca35c08a1b1fda2483d50de49ff19aae9a"></a>XMC_USBD_EVENT_RESET&#160;</td><td class="fielddoc"><p>USB Reset occurred </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab5d22fa8b9bbf4d4295ee761ca1150ca0614b7af2d019050a87d71b0fcf9346e"></a>XMC_USBD_EVENT_HIGH_SPEED&#160;</td><td class="fielddoc"><p>USB switch to High Speed occurred </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab5d22fa8b9bbf4d4295ee761ca1150ca7f5ad99f9dfa832826ec8c7e336fcf43"></a>XMC_USBD_EVENT_SUSPEND&#160;</td><td class="fielddoc"><p>USB Suspend occurred </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab5d22fa8b9bbf4d4295ee761ca1150ca747e81db30bbdb33fc23289cec41f390"></a>XMC_USBD_EVENT_RESUME&#160;</td><td class="fielddoc"><p>USB Resume occurred </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab5d22fa8b9bbf4d4295ee761ca1150ca914fcd65e6beae942001767c870b8211"></a>XMC_USBD_EVENT_REMOTE_WAKEUP&#160;</td><td class="fielddoc"><p>USB Remote wakeup </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab5d22fa8b9bbf4d4295ee761ca1150cace38af9bdbcc48dd60eca96fc4ba36fd"></a>XMC_USBD_EVENT_SOF&#160;</td><td class="fielddoc"><p>USB Start of frame event </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab5d22fa8b9bbf4d4295ee761ca1150caa620e9ce8bb8f9b786af69b66ffb35be"></a>XMC_USBD_EVENT_EARLYSUSPEND&#160;</td><td class="fielddoc"><p>USB Early suspend </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab5d22fa8b9bbf4d4295ee761ca1150ca4c0bfbed5e888792676faa63dd8fb7c8"></a>XMC_USBD_EVENT_ENUMDONE&#160;</td><td class="fielddoc"><p>USB enumeration done </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab5d22fa8b9bbf4d4295ee761ca1150caca15fd85a47c745792708723b080e335"></a>XMC_USBD_EVENT_ENUMNOTDONE&#160;</td><td class="fielddoc"><p>USB enumeration not done </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab5d22fa8b9bbf4d4295ee761ca1150caf6ea63c187d2a0c508f13a6ff8f7faac"></a>XMC_USBD_EVENT_OUTEP&#160;</td><td class="fielddoc"><p>USB OUT endpoint </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab5d22fa8b9bbf4d4295ee761ca1150ca152b5d852cbe94b08f872803a714a656"></a>XMC_USBD_EVENT_INEP&#160;</td><td class="fielddoc"><p>USB IN endpoint </p>
</td></tr>
</table>

</div>
</div>
<a id="gaef2c56426dd4ecb5da943eab0cf08e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef2c56426dd4ecb5da943eab0cf08e13">&#9670;&nbsp;</a></span>XMC_USBD_GRXSTS_PKTSTS_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_b_d.html#gaef2c56426dd4ecb5da943eab0cf08e13">XMC_USBD_GRXSTS_PKTSTS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the options for the global receive fifo packet status. Use type <a class="el" href="group___u_s_b_d.html#gaef2c56426dd4ecb5da943eab0cf08e13">XMC_USBD_GRXSTS_PKTSTS_t</a> for this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaef2c56426dd4ecb5da943eab0cf08e13a4c34882f1c5ddeccc4aecac4b98a4c49"></a>XMC_USBD_GRXSTS_PKTSTS_GOUTNAK&#160;</td><td class="fielddoc"><p>Global out nack send ( triggers an interrupt ) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef2c56426dd4ecb5da943eab0cf08e13a6da8520458120cfaba76159c5ba6c9a8"></a>XMC_USBD_GRXSTS_PKTSTS_OUTDATA&#160;</td><td class="fielddoc"><p>OUT data packet received </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef2c56426dd4ecb5da943eab0cf08e13a13b19907a0417f09f0385bef52431c3e"></a>XMC_USBD_GRXSTS_PKTSTS_OUTCMPL&#160;</td><td class="fielddoc"><p>OUT transfer completed (triggers an interrupt) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef2c56426dd4ecb5da943eab0cf08e13a65761560fedab5236f8e6e97c2e4c443"></a>XMC_USBD_GRXSTS_PKTSTS_SETUPCMPL&#160;</td><td class="fielddoc"><p>SETUP transaction completed (triggers an interrupt) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaef2c56426dd4ecb5da943eab0cf08e13aee092e930d84748b127f17446c345148"></a>XMC_USBD_GRXSTS_PKTSTS_SETUP&#160;</td><td class="fielddoc"><p>SETUP data packet received </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa7e7d0502c559923da7e324160c527a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7e7d0502c559923da7e324160c527a7">&#9670;&nbsp;</a></span>XMC_USBD_MAX_NUM_EPS_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_b_d.html#gaa7e7d0502c559923da7e324160c527a7">XMC_USBD_MAX_NUM_EPS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the options for the maximum number of endpoints used. Use type <a class="el" href="group___u_s_b_d.html#gaa7e7d0502c559923da7e324160c527a7">XMC_USBD_MAX_NUM_EPS_t</a> for this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa7e7d0502c559923da7e324160c527a7a6bb26eec5cd8f27a8789cf5f6cdfa7e6"></a>XMC_USBD_MAX_NUM_EPS_1&#160;</td><td class="fielddoc"><p>Maximum 1 endpoint used </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa7e7d0502c559923da7e324160c527a7a9a54cc0b5435be2c1694bb59dd5a6042"></a>XMC_USBD_MAX_NUM_EPS_2&#160;</td><td class="fielddoc"><p>Maximum 2 endpoints used </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa7e7d0502c559923da7e324160c527a7af4dda15407014e54cef3e7927e700790"></a>XMC_USBD_MAX_NUM_EPS_3&#160;</td><td class="fielddoc"><p>Maximum 3 endpoints used </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa7e7d0502c559923da7e324160c527a7a181279f81880219809c139ef01caf1f6"></a>XMC_USBD_MAX_NUM_EPS_4&#160;</td><td class="fielddoc"><p>Maximum 4 endpoints used </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa7e7d0502c559923da7e324160c527a7a4c97fdca7ad6ea7f7f119ddc7bd02432"></a>XMC_USBD_MAX_NUM_EPS_5&#160;</td><td class="fielddoc"><p>Maximum 5 endpoints used </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa7e7d0502c559923da7e324160c527a7ac19349e23f2e7cf6b9c48d831043fadf"></a>XMC_USBD_MAX_NUM_EPS_6&#160;</td><td class="fielddoc"><p>Maximum 6 endpoints used </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa7e7d0502c559923da7e324160c527a7a28dffb25c224b6507f9248cd4cbd1fbb"></a>XMC_USBD_MAX_NUM_EPS_7&#160;</td><td class="fielddoc"><p>Maximum 2 endpoints used </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1983ea285c683f63ee535552d9d2ec1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1983ea285c683f63ee535552d9d2ec1e">&#9670;&nbsp;</a></span>XMC_USBD_SET_ADDRESS_STAGE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_b_d.html#ga1983ea285c683f63ee535552d9d2ec1e">XMC_USBD_SET_ADDRESS_STAGE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the options for USB device state while setting the address. Use type <a class="el" href="group___u_s_b_d.html#ga1983ea285c683f63ee535552d9d2ec1e">XMC_USBD_SET_ADDRESS_STAGE_t</a> for this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1983ea285c683f63ee535552d9d2ec1eae46c347e00fbbf9c315ad9e0d5a8279a"></a>XMC_USBD_SET_ADDRESS_STAGE_SETUP&#160;</td><td class="fielddoc"><p>Setup address </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1983ea285c683f63ee535552d9d2ec1ea95fb7ee8ca9ec0dd6820da21c1be0417"></a>XMC_USBD_SET_ADDRESS_STAGE_STATUS&#160;</td><td class="fielddoc"><p>Status address </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2ed7a439225ce1a0b56349cf914b8cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ed7a439225ce1a0b56349cf914b8cda">&#9670;&nbsp;</a></span>XMC_USBD_STATUS_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the USB Device Status of executed operation. Use type <a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a> for this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2ed7a439225ce1a0b56349cf914b8cdaa252bc4cec27a140368769ae0ea6a349b"></a>XMC_USBD_STATUS_OK&#160;</td><td class="fielddoc"><p>USBD Status: Operation succeeded </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2ed7a439225ce1a0b56349cf914b8cdaa1ddef3a7f4b624a87abb31dae5407c20"></a>XMC_USBD_STATUS_BUSY&#160;</td><td class="fielddoc"><p>Driver is busy and cannot handle request </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2ed7a439225ce1a0b56349cf914b8cdaa87da2dd04f9fa46dfe27cc599330feb6"></a>XMC_USBD_STATUS_ERROR&#160;</td><td class="fielddoc"><p>USBD Status: Unspecified error </p>
</td></tr>
</table>

</div>
</div>
<a id="gac1a7468fe227f852bd4835ae2723d7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1a7468fe227f852bd4835ae2723d7db">&#9670;&nbsp;</a></span>XMC_USBD_TRANSFER_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_s_b_d.html#gac1a7468fe227f852bd4835ae2723d7db">XMC_USBD_TRANSFER_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the options for the USB data transfer modes. Use type <a class="el" href="group___u_s_b_d.html#gac1a7468fe227f852bd4835ae2723d7db">XMC_USBD_TRANSFER_MODE_t</a> for this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac1a7468fe227f852bd4835ae2723d7dba6a790ad5624ce6bf47062c87ce9e50d6"></a>XMC_USBD_USE_DMA&#160;</td><td class="fielddoc"><p>Transfer by DMA </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac1a7468fe227f852bd4835ae2723d7dba6b2871991c75c20b1f4a2cd778ae63d6"></a>XMC_USBD_USE_FIFO&#160;</td><td class="fielddoc"><p>Transfer by FIFO </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0f50121054da395d3685c6ad9ecb0a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f50121054da395d3685c6ad9ecb0a56">&#9670;&nbsp;</a></span>XMC_USBD_ClearEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USBD_ClearEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_s_b_d.html#gaab5d22fa8b9bbf4d4295ee761ca1150c">XMC_USBD_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The single event that needs to be cleared. Use <a class="el" href="group___u_s_b_d.html#gaab5d22fa8b9bbf4d4295ee761ca1150c">XMC_USBD_EVENT_t</a> as argument.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Clears the selected USBD <em>event</em>.<br />
 It clears the event by writing to the GINTSTS register.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>This API is called inside the USB interrupt handler to clear the event XMC_USBD_EVENT_t and maintain the device state machine.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#gadaef35f7f883268c95e15e8849bf3530">XMC_USBD_ClearEventOUTEP()</a>,<a class="el" href="group___u_s_b_d.html#gaf5f99dc34a65ebd0dd4d5686632702e7">XMC_USBD_ClearEventINEP()</a><br />
</dd></dl>

</div>
</div>
<a id="gaf5f99dc34a65ebd0dd4d5686632702e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5f99dc34a65ebd0dd4d5686632702e7">&#9670;&nbsp;</a></span>XMC_USBD_ClearEventINEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USBD_ClearEventINEP </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The single event or multiple events that need to be cleared.</td></tr>
    <tr><td class="paramname">ep_num</td><td>The IN endpoint number on which the events to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Clears the single event or multiple events of the selected IN endpoint.<br />
 The multiple events can be selected by the bitwise OR operation of <a class="el" href="group___u_s_b_d.html#gae9d04ab6e275df9194533711f3f2fffe">XMC_USBD_EVENT_IN_EP_t</a> elements.<br />
It clears the event by programming DIEPINT register.<br />
 </dd></dl>
<dl class="section user"><dt>Note:</dt><dd>This API is called inside the USB IN EP interrupt handler to clear the <a class="el" href="group___u_s_b_d.html#gae9d04ab6e275df9194533711f3f2fffe">XMC_USBD_EVENT_IN_EP_t</a> event and maintain the device state machine.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#gadaef35f7f883268c95e15e8849bf3530">XMC_USBD_ClearEventOUTEP()</a><br />
</dd></dl>

</div>
</div>
<a id="gadaef35f7f883268c95e15e8849bf3530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaef35f7f883268c95e15e8849bf3530">&#9670;&nbsp;</a></span>XMC_USBD_ClearEventOUTEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USBD_ClearEventOUTEP </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The single event or multiple events that need to be cleared.</td></tr>
    <tr><td class="paramname">ep_num</td><td>The OUT endpoint number on which the events to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Clears the single <em>event</em> or multiple events of the selected OUT endpoint.<br />
 The multiple events can be selected by the bitwise OR operation of <a class="el" href="group___u_s_b_d.html#gae670af5d633ceb13ed361390c49c2128">XMC_USBD_EVENT_OUT_EP_t</a> elements. It clears the event by writing to DOEPINT register.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>This API is called inside the USB OUT EP interrupt handler to clear the <a class="el" href="group___u_s_b_d.html#gae670af5d633ceb13ed361390c49c2128">XMC_USBD_EVENT_OUT_EP_t</a> event and maintain the device state machine.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#gaf5f99dc34a65ebd0dd4d5686632702e7">XMC_USBD_ClearEventINEP()</a><br />
</dd></dl>

</div>
</div>
<a id="ga5a46af80a2ac68076e8d82d0b7967613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a46af80a2ac68076e8d82d0b7967613">&#9670;&nbsp;</a></span>XMC_USBD_DeviceConnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a> XMC_USBD_DeviceConnect </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Connects the USB device to host and triggers the USB enumeration.<br />
 Connects the USB device to host by programming DCTL register.<br />
It resets the soft disconnect bit, which activates the speed pull up at d+ line of USB. <a class="el" href="group___u_s_b_d.html#gaad24c323055e8e5014835159867878c1">XMC_USBD_Init()</a> should be called before calling this API.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Once this API is called, USB host starts the enumeration process and the device should handle the descriptor requests.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#gaad24c323055e8e5014835159867878c1">XMC_USBD_Init()</a><br />
</dd></dl>

</div>
</div>
<a id="ga7b341bdd4b66740230bda3f94d49052e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b341bdd4b66740230bda3f94d49052e">&#9670;&nbsp;</a></span>XMC_USBD_DeviceDisconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a> XMC_USBD_DeviceDisconnect </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disconnects the USB device from host.<br />
 By programming DCTL register, it sets the soft disconnect bit, which deactivates<br />
the speed pull up at d+ line of USB.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Once this API is called, USB device will not be accessible from host.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#ga5a46af80a2ac68076e8d82d0b7967613">XMC_USBD_DeviceConnect()</a><br />
</dd></dl>

</div>
</div>
<a id="ga42cdb3dc1b05ec18cf8687ea88c7c175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42cdb3dc1b05ec18cf8687ea88c7c175">&#9670;&nbsp;</a></span>XMC_USBD_DeviceGetState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_m_c___u_s_b_d___s_t_a_t_e__t.html">XMC_USBD_STATE_t</a> XMC_USBD_DeviceGetState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___u_s_b_d__t.html">XMC_USBD_t</a> *const&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The pointer to the USB device handle structure <em><a class="el" href="struct_x_m_c___u_s_b_d__t.html">XMC_USBD_t</a></em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_x_m_c___u_s_b_d___s_t_a_t_e__t.html">XMC_USBD_STATE_t</a>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Retrieves the current USB device state.<br />
 Power,active,speed and connection status data are retrieved.<br />
 </dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Before calling this API, USB should be initialized with <a class="el" href="group___u_s_b_d.html#gaad24c323055e8e5014835159867878c1">XMC_USBD_Init</a>.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#gaad24c323055e8e5014835159867878c1">XMC_USBD_Init()</a><br />
</dd></dl>

</div>
</div>
<a id="ga0cb810be749bfd8e8c733a6e17bd5388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cb810be749bfd8e8c733a6e17bd5388">&#9670;&nbsp;</a></span>XMC_USBD_DeviceSetAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a> XMC_USBD_DeviceSetAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_s_b_d.html#ga1983ea285c683f63ee535552d9d2ec1e">XMC_USBD_SET_ADDRESS_STAGE_t</a>&#160;</td>
          <td class="paramname"><em>stage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address to be set for the USB device . </td></tr>
    <tr><td class="paramname">stage</td><td>The device request stage-setup or status <a class="el" href="group___u_s_b_d.html#ga1983ea285c683f63ee535552d9d2ec1e">XMC_USBD_SET_ADDRESS_STAGE_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the USB device address.<br />
 The device address is programmed in the DCFG register.<br />
</dd></dl>
<p>The address should be more than 0; as 0 is the default USB device address at the starting of enumeration. As part of enumeration, host sends the control request to the device to set the USB address; and in turn,<br />
in the USB device event call back handler, user has to set the address using this API for the set address request.<br />
</p>
<p>The stage parameter should be XMC_USBD_SET_ADDRESS_STAGE_SETUP from the enum <a class="el" href="group___u_s_b_d.html#ga1983ea285c683f63ee535552d9d2ec1e">XMC_USBD_SET_ADDRESS_STAGE_t</a>.</p>
<dl class="section user"><dt>Note:</dt><dd>Before calling this API, USB should be initialized with <a class="el" href="group___u_s_b_d.html#gaad24c323055e8e5014835159867878c1">XMC_USBD_Init</a> () and connected to USB host using <a class="el" href="group___u_s_b_d.html#ga5a46af80a2ac68076e8d82d0b7967613">XMC_USBD_DeviceConnect()</a> <br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#gaad24c323055e8e5014835159867878c1">XMC_USBD_Init()</a>, <a class="el" href="group___u_s_b_d.html#ga5a46af80a2ac68076e8d82d0b7967613">XMC_USBD_DeviceConnect()</a><br />
</dd></dl>

</div>
</div>
<a id="ga1c28d84f9afe864fb9dc0e253137ae54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c28d84f9afe864fb9dc0e253137ae54">&#9670;&nbsp;</a></span>XMC_USBD_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USBD_Disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the USB module in the XMC controller.<br />
 It asserts the peripheral reset on USB0 module and disables the USB power.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#ga755920b85d839979d699894e98c13b69">XMC_USBD_Enable()</a><br />
</dd></dl>

</div>
</div>
<a id="ga755920b85d839979d699894e98c13b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga755920b85d839979d699894e98c13b69">&#9670;&nbsp;</a></span>XMC_USBD_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USBD_Enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the USB module in the XMC controller.<br />
 It de-asserts the peripheral reset on USB0 module and enables the USB power.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>This API is called inside the <a class="el" href="group___u_s_b_d.html#gaad24c323055e8e5014835159867878c1">XMC_USBD_Init()</a>.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#ga1c28d84f9afe864fb9dc0e253137ae54">XMC_USBD_Disable()</a><br />
</dd></dl>

</div>
</div>
<a id="gaaec2e039f617fdbaa50acb34061c5056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaec2e039f617fdbaa50acb34061c5056">&#9670;&nbsp;</a></span>XMC_USBD_EnableEventINEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USBD_EnableEventINEP </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The single event or multiple events that need to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the <em>event</em> or multiple events of the USB IN endpoints.<br />
 The multiple events can be selected by the bitwise OR operation of <a class="el" href="group___u_s_b_d.html#gae9d04ab6e275df9194533711f3f2fffe">XMC_USBD_EVENT_IN_EP_t</a> elements. It enables the event by programming DIEPMSK register.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>This API is called inside the <a class="el" href="group___u_s_b_d.html#gaad24c323055e8e5014835159867878c1">XMC_USBD_Init()</a> to enable the IN EP interrupts.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#ga215e0c7a10299d26c9f91c6ad06866f6">XMC_USBD_EnableEventOUTEP()</a><br />
</dd></dl>

</div>
</div>
<a id="ga215e0c7a10299d26c9f91c6ad06866f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga215e0c7a10299d26c9f91c6ad06866f6">&#9670;&nbsp;</a></span>XMC_USBD_EnableEventOUTEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USBD_EnableEventOUTEP </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The single event or multiple events that need to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the event or multiple events of the OUT endpoints.<br />
 The multiple events can be selected by the bitwise OR operation of <a class="el" href="group___u_s_b_d.html#gae670af5d633ceb13ed361390c49c2128">XMC_USBD_EVENT_OUT_EP_t</a> elements. It enables the event by programming DOEPMSK register.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>This API is called inside the <a class="el" href="group___u_s_b_d.html#gaad24c323055e8e5014835159867878c1">XMC_USBD_Init()</a> to enable the OUT EP interrupts.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#gaaec2e039f617fdbaa50acb34061c5056">XMC_USBD_EnableEventINEP()</a><br />
</dd></dl>

</div>
</div>
<a id="ga685e20ab2777c403ae1e3463d47f2d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga685e20ab2777c403ae1e3463d47f2d53">&#9670;&nbsp;</a></span>XMC_USBD_EndpointAbort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a> XMC_USBD_EndpointAbort </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_addr</td><td>The address of the USB endpoint, on which the data need to be aborted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a></dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Abort the transfer on endpoint <em>ep_addr</em>.<br />
 On any failure with the USB transmission user can reset the endpoint into default state and clear all assigned buffers, to start from a clean point. The endpoint will not be unconfigured or disabled.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#ga7903550b9130e811d39b55936174cc36">XMC_USBD_EndpointUnconfigure()</a><br />
</dd></dl>

</div>
</div>
<a id="ga1ec7cf807c281084ab7022c23617bdcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ec7cf807c281084ab7022c23617bdcb">&#9670;&nbsp;</a></span>XMC_USBD_EndpointConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a> XMC_USBD_EndpointConfigure </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_s_b_d.html#gae7245a0620a6bb5fe8249380d14b284c">XMC_USBD_ENDPOINT_TYPE_t</a>&#160;</td>
          <td class="paramname"><em>ep_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ep_max_packet_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_addr</td><td>The address of the USB endpoint, which needs to be configured. </td></tr>
    <tr><td class="paramname">ep_type</td><td>The <a class="el" href="group___u_s_b_d.html#gae7245a0620a6bb5fe8249380d14b284c">XMC_USBD_ENDPOINT_TYPE_t</a>. </td></tr>
    <tr><td class="paramname">ep_max_packet_size</td><td>The maximum packet size of endpoint in USB full speed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the USB endpoint.<br />
 The endpoint is configured by programming the DAINT,DIEPCTL and DOEPCTL registers.<br />
</dd></dl>
<p>Configures the EP type, FIFO number,maximum packet size, enables endpoint and sets the DATA0 PID. This function also initializes the internal buffer handling for the specified endpoint, but does not start any transfers.<br />
</p>
<p>As part of enumeration, host sends the control request to the device to set the configuration; and in turn,<br />
in the USB device event call back handler, user has to set the configuration and configure the endpoints <br />
required for the device.<br />
 </p><dl class="section user"><dt>Note:</dt><dd>This API should only be used as part of enumeration.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#gaad24c323055e8e5014835159867878c1">XMC_USBD_Init()</a>,<a class="el" href="group___u_s_b_d.html#ga5a46af80a2ac68076e8d82d0b7967613">XMC_USBD_DeviceConnect()</a>,<a class="el" href="group___u_s_b_d.html#ga7903550b9130e811d39b55936174cc36">XMC_USBD_EndpointUnconfigure()</a><br />
</dd></dl>

</div>
</div>
<a id="gafd364e0fd03285bde32bc6359e6bc218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd364e0fd03285bde32bc6359e6bc218">&#9670;&nbsp;</a></span>XMC_USBD_EndpointRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t XMC_USBD_EndpointRead </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>ep_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_addr</td><td>The address of the USB OUT endpoint, from which data need to be read. </td></tr>
    <tr><td class="paramname">buffer</td><td>The pointer to the user buffer,in which data need to be received. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to be read from OUT EP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 The actual number of bytes received.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Read <em>length</em> number of bytes from an OUT endpoint <em>ep_addr</em>.<br />
 If data has been received for this endpoint, it gets copied into the user buffer until its full or no data is left in the driver buffer.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>For preparing the next OUT token, use <a class="el" href="group___u_s_b_d.html#ga18f4cb810289187a885e6f04659bc335">XMC_USBD_EndpointReadStart()</a> after <a class="el" href="group___u_s_b_d.html#gafd364e0fd03285bde32bc6359e6bc218">XMC_USBD_EndpointRead()</a>.<br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#ga18f4cb810289187a885e6f04659bc335">XMC_USBD_EndpointReadStart()</a><br />
</dd></dl>

</div>
</div>
<a id="ga18f4cb810289187a885e6f04659bc335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18f4cb810289187a885e6f04659bc335">&#9670;&nbsp;</a></span>XMC_USBD_EndpointReadStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a> XMC_USBD_EndpointReadStart </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>ep_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_addr</td><td>The address of the USB endpoint, from which data need to be read. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Prepares an endpoint to receive OUT tokens from the USB host.<br />
 The selected endpoint gets configured, so that it receives the specified amount of data from the host. As part of streaming of OUT data, after reading the current OUT buffer using <a class="el" href="group___u_s_b_d.html#gafd364e0fd03285bde32bc6359e6bc218">XMC_USBD_EndpointRead()</a>,<br />
user can prepare endpoint for the next OUT packet by using <a class="el" href="group___u_s_b_d.html#ga18f4cb810289187a885e6f04659bc335">XMC_USBD_EndpointReadStart()</a>.</dd></dl>
<p>The registers DOEPDMA,DOEPTSIZ and DOEPCTL are programmed to start a new read request.</p>
<dl class="section user"><dt>Note:</dt><dd>For the data received on OUT EP buffer, use <a class="el" href="group___u_s_b_d.html#gafd364e0fd03285bde32bc6359e6bc218">XMC_USBD_EndpointRead()</a>.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#gafd364e0fd03285bde32bc6359e6bc218">XMC_USBD_EndpointRead()</a><br />
</dd></dl>

</div>
</div>
<a id="ga6b54b58df01ada8156d8449129778f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b54b58df01ada8156d8449129778f05">&#9670;&nbsp;</a></span>XMC_USBD_EndpointStall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a> XMC_USBD_EndpointStall </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stall</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_addr</td><td>The address of the USB endpoint, on which stall needs to be set or cleared. </td></tr>
    <tr><td class="paramname">stall</td><td>The boolean variable to decide on set or clear of stall on EP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Set or Clear stall on the USB endpoint <em>ep_addr</em>, based on <em>stall</em> parameter.<br />
</dd></dl>
<p>By programming stall bit in the doepctl and diepctl, it sets or clears the stall on the endpoint. The endpoint can be stalled when a non supported request comes from the USB host. The <a class="el" href="group___u_s_b_d.html#ga6b54b58df01ada8156d8449129778f05">XMC_USBD_EndpointStall()</a> should be called with <em>stall</em> set to 0, in the clear feature standard request in the USB device event call back handler. *</p>
<dl class="section user"><dt>Note:</dt><dd>The host should clear the stall set on the endpoint by sending the clear feature standard request on the non EP0 endpoints. On EP0, the stall will automatically gets cleared on the next control request.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#ga685e20ab2777c403ae1e3463d47f2d53">XMC_USBD_EndpointAbort()</a><br />
</dd></dl>

</div>
</div>
<a id="ga7903550b9130e811d39b55936174cc36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7903550b9130e811d39b55936174cc36">&#9670;&nbsp;</a></span>XMC_USBD_EndpointUnconfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a> XMC_USBD_EndpointUnconfigure </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_addr</td><td>The address of the USB endpoint, which needs to be unconfigured.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Unconfigures the USB endpoint.<br />
 The endpoint is unconfigured by programming the DAINT,DIEPCTL and DOEPCTL registers.<br />
Disables the endpoint, unassign the fifo, deactivate it and only send nacks.<br />
Waits until the endpoint has finished operation and disables it. All (eventuallly) allocated buffers gets freed. Forces the endpoint to stop immediately, any pending transfers are killed(Can cause device reset).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#ga1ec7cf807c281084ab7022c23617bdcb">XMC_USBD_EndpointConfigure()</a><br />
</dd></dl>

</div>
</div>
<a id="ga27d8052980544dc78f56462fc7c157ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27d8052980544dc78f56462fc7c157ba">&#9670;&nbsp;</a></span>XMC_USBD_EndpointWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t XMC_USBD_EndpointWrite </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>ep_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep_addr</td><td>The address of the USB IN endpoint, on which data should be sent. </td></tr>
    <tr><td class="paramname">buffer</td><td>The pointer to the data buffer, to write to the endpoint. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to be written to IN EP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 The actual amount of data written to the endpoint buffer.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Write the <em>length</em> bytes of data to an IN endpoint <em>ep_addr</em>.<br />
 The User data gets copied into the driver buffer or will be send directly based on the buffer concept selected in the <a class="el" href="group___u_s_b_d.html#gac1a7468fe227f852bd4835ae2723d7db">XMC_USBD_TRANSFER_MODE_t</a> configuration.</dd></dl>
<p>Then the endpoint is set up to transfer the data to the host.<br />
DIEPDMA,DIEPTSIZ and DIEPCTL registers are programmed to start the IN transfer.</p>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#gafd364e0fd03285bde32bc6359e6bc218">XMC_USBD_EndpointRead()</a><br />
</dd></dl>

</div>
</div>
<a id="ga26113550391be8fc0e2678fe0e6e85ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26113550391be8fc0e2678fe0e6e85ff">&#9670;&nbsp;</a></span>XMC_USBD_GetCapabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_m_c___u_s_b_d___c_a_p_a_b_i_l_i_t_i_e_s__t.html">XMC_USBD_CAPABILITIES_t</a> XMC_USBD_GetCapabilities </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_x_m_c___u_s_b_d___c_a_p_a_b_i_l_i_t_i_e_s__t.html">XMC_USBD_CAPABILITIES_t</a>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Retrieves the USB device capabilities of type <em><a class="el" href="struct_x_m_c___u_s_b_d___c_a_p_a_b_i_l_i_t_i_e_s__t.html">XMC_USBD_CAPABILITIES_t</a></em> <br />
 The USB device capabilities supported by the USBD driver, like power on/off, connect/disconnect, reset,suspend/resume,USB speed etc are retrieved.</dd></dl>
<p>It can be called after initializing the USB device to get the information on the USBD capabilities. </p>

</div>
</div>
<a id="gace9648d66a9f092562ca5da8754f5ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace9648d66a9f092562ca5da8754f5ac0">&#9670;&nbsp;</a></span>XMC_USBD_GetFrameNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XMC_USBD_GetFrameNumber </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 16 bit current USB frame number.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Read the current USB frame number.<br />
 * Reads the device status register (DSTS) and returns the SOFFN field. </dd></dl>

</div>
</div>
<a id="gaad24c323055e8e5014835159867878c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad24c323055e8e5014835159867878c1">&#9670;&nbsp;</a></span>XMC_USBD_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a> XMC_USBD_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_b_d__t.html">XMC_USBD_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The pointer to the USB device handle <a class="el" href="struct_x_m_c___u_s_b_d__t.html">XMC_USBD_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_USBD_STATUS_t The USB device status of type <a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initializes the USB device to get ready for connect to USB host.<br />
 Enables the USB module,sets the EP buffer sizes,registers the device and EP event call backs. Initializes the global,device and FIFO register base addresses. Configures the global AHB,enables the global interrupt and DMA by programming GAHBCFG register. Configures the USB in to device mode and enables the session request protocol by programming GUSBCFG register. Configures the USB device speed to full speed by programming DCFG register. Disconnects the USB device by programming DCTL register. Enables the USB common and device interrupts by programming GINTMSK register.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>This API makes the USB device ready to connect to host.The user has to explicitly call the <a class="el" href="group___u_s_b_d.html#ga5a46af80a2ac68076e8d82d0b7967613">XMC_USBD_DeviceConnect()</a> after the USB initialization to connect to USB host.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#ga5a46af80a2ac68076e8d82d0b7967613">XMC_USBD_DeviceConnect()</a><br />
</dd></dl>

</div>
</div>
<a id="ga275780df6f1b3acf50c4c51151d228b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga275780df6f1b3acf50c4c51151d228b8">&#9670;&nbsp;</a></span>XMC_USBD_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_USBD_IRQHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___u_s_b_d__t.html">XMC_USBD_t</a> *const&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The pointer to the USB device handle structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>USB device default IRQ handler.<br />
 USBD Peripheral LLD provides default implementation of ISR. The user needs to explicitly either use our default implementation or use its own one using the LLD APIs.</dd></dl>
<p>For example: <a class="el" href="struct_x_m_c___u_s_b_d__t.html">XMC_USBD_t</a> *obj; void USB0_0_IRQHandler(void) { XMC_USBD_IRQHandler(obj); }</p>
<dl class="section user"><dt>Note:</dt><dd>The user should initialize the XMC USB device configuration structure before calling <a class="el" href="group___u_s_b_d.html#ga275780df6f1b3acf50c4c51151d228b8">XMC_USBD_IRQHandler()</a> in the actual USB0 IRQ handler. </dd></dl>

</div>
</div>
<a id="gac958c928fc573f39b30126ac2e2828d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac958c928fc573f39b30126ac2e2828d7">&#9670;&nbsp;</a></span>XMC_USBD_IsEnumDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_USBD_IsEnumDone </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1, if the speed enumeration is done and 0 otherwise.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Gets the speed enumeration completion status of the USB device.<br />
</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>This should not be used for the actual USB enumeration completion status. For the actual USB enumeration status, the application layer should check for the completion of USB standard request 'Set configuration'.<br />
</dd></dl>

</div>
</div>
<a id="ga21f8d8e728cce37ff9d4898acb2e62cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21f8d8e728cce37ff9d4898acb2e62cf">&#9670;&nbsp;</a></span>XMC_USBD_Uninitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a> XMC_USBD_Uninitialize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___u_s_b_d.html#ga2ed7a439225ce1a0b56349cf914b8cda">XMC_USBD_STATUS_t</a>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Uninitialises the USB device.<br />
 Disconnects the USB device by programming DCTL register and resets the XMC USB device data.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Once this API is called, USB device will not be accessible from host.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_b_d.html#gaad24c323055e8e5014835159867878c1">XMC_USBD_Init()</a><br />
</dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga24b0d090ba036e032aba146ca34fc035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24b0d090ba036e032aba146ca34fc035">&#9670;&nbsp;</a></span>Driver_USBD0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_x_m_c___u_s_b_d___d_r_i_v_e_r__t.html">XMC_USBD_DRIVER_t</a> Driver_USBD0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the driver interface function table. To access the XMC device controller driver interface use this table of functions. </p>

</div>
</div>
<a id="ga407e973323123c34ea9c9c04b6899992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga407e973323123c34ea9c9c04b6899992">&#9670;&nbsp;</a></span>xmc_device</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_m_c___u_s_b_d___d_e_v_i_c_e__t.html">XMC_USBD_DEVICE_t</a> xmc_device</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the XMC USB device data The instance of <a class="el" href="struct_x_m_c___u_s_b_d___d_e_v_i_c_e__t.html">XMC_USBD_DEVICE_t</a> structure describing the XMC device. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>XMC Peripheral Library for XMC4000 Family</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
