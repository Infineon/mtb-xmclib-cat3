<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XMC Peripheral Library for XMC4000 Family: CCU4</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC4000 Family
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CCU4<div class="ingroups"><a class="el" href="group___x_m_clib.html">XMC Peripheral Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___c_c_u4___s_l_i_c_e___c_a_p_t_u_r_e___c_o_n_f_i_g__t.html">XMC_CCU4_SLICE_CAPTURE_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___c_c_u4___s_l_i_c_e___c_o_m_p_a_r_e___c_o_n_f_i_g__t.html">XMC_CCU4_SLICE_COMPARE_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___c_c_u4___s_l_i_c_e___e_v_e_n_t___c_o_n_f_i_g__t.html">XMC_CCU4_SLICE_EVENT_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gabc8c277fccba02adfd4c57fdbf66df71"><td class="memItemLeft" align="right" valign="top">typedef CCU4_GLOBAL_TypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a></td></tr>
<tr class="separator:gabc8c277fccba02adfd4c57fdbf66df71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab7f7bcdc1aff8cc0beb2edae16a3cf3"><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gaab7f7bcdc1aff8cc0beb2edae16a3cf3">XMC_CCU4_SLICE_INPUT_t</a></td></tr>
<tr class="separator:gaab7f7bcdc1aff8cc0beb2edae16a3cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga759d9cc26009d3567612d196ac3f3969"><td class="memItemLeft" align="right" valign="top">typedef CCU4_CC4_TypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a></td></tr>
<tr class="separator:ga759d9cc26009d3567612d196ac3f3969"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaf5e64519972ca9ee2c9b590eba7c041b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gaf5e64519972ca9ee2c9b590eba7c041b">XMC_CCU4_CLOCK_t</a> </td></tr>
<tr class="separator:gaf5e64519972ca9ee2c9b590eba7c041b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a88d5f27f3d04acf49beae187238299"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga9a88d5f27f3d04acf49beae187238299">XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_t</a> </td></tr>
<tr class="separator:ga9a88d5f27f3d04acf49beae187238299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d2c64420abee84dccce68e68b942e67"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga8d2c64420abee84dccce68e68b942e67">XMC_CCU4_SHADOW_TRANSFER_t</a> </td></tr>
<tr class="separator:ga8d2c64420abee84dccce68e68b942e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2216adfcbbc93dde340169582ef17ff6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga2216adfcbbc93dde340169582ef17ff6">XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_t</a> </td></tr>
<tr class="separator:ga2216adfcbbc93dde340169582ef17ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5c05e6fda34ac046c12ec25ef405a3d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gab5c05e6fda34ac046c12ec25ef405a3d">XMC_CCU4_SLICE_CAP_REG_SET_t</a> </td></tr>
<tr class="separator:gab5c05e6fda34ac046c12ec25ef405a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed08e3fd07e061ccb45377415a958c6a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gaed08e3fd07e061ccb45377415a958c6a">XMC_CCU4_SLICE_END_MODE_t</a> </td></tr>
<tr class="separator:gaed08e3fd07e061ccb45377415a958c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d83f7d7d27ced4fbc071540f942cbdd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga0d83f7d7d27ced4fbc071540f942cbdd">XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_t</a> </td></tr>
<tr class="separator:ga0d83f7d7d27ced4fbc071540f942cbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1f2e1821e948b519f665a3b75fde3a3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gac1f2e1821e948b519f665a3b75fde3a3">XMC_CCU4_SLICE_EVENT_FILTER_t</a> </td></tr>
<tr class="separator:gac1f2e1821e948b519f665a3b75fde3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6885762c605583d15f280d371e08b8b0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga6885762c605583d15f280d371e08b8b0">XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_t</a> </td></tr>
<tr class="separator:ga6885762c605583d15f280d371e08b8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc266caa550eca30994d968fa3b82b94"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a> </td></tr>
<tr class="separator:gacc266caa550eca30994d968fa3b82b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac60bd4b37c3c5d5d0e2401d769c51d28"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gac60bd4b37c3c5d5d0e2401d769c51d28">XMC_CCU4_SLICE_FUNCTION_t</a> </td></tr>
<tr class="separator:gac60bd4b37c3c5d5d0e2401d769c51d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b6b22c75755089c6c4038de4a5d213c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga9b6b22c75755089c6c4038de4a5d213c">XMC_CCU4_SLICE_IRQ_ID_t</a> </td></tr>
<tr class="separator:ga9b6b22c75755089c6c4038de4a5d213c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace3b8480c5644319f7c266b67b3aa07b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gace3b8480c5644319f7c266b67b3aa07b">XMC_CCU4_SLICE_MASK_t</a> </td></tr>
<tr class="separator:gace3b8480c5644319f7c266b67b3aa07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cdf6b35dbf21bc9ffd767cf8df77615"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga1cdf6b35dbf21bc9ffd767cf8df77615">XMC_CCU4_SLICE_MCMS_ACTION_t</a> </td></tr>
<tr class="separator:ga1cdf6b35dbf21bc9ffd767cf8df77615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9667e43e2a54209c309f767354a0af8e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga9667e43e2a54209c309f767354a0af8e">XMC_CCU4_SLICE_MODE_t</a> </td></tr>
<tr class="separator:ga9667e43e2a54209c309f767354a0af8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba1abc67da718dd4dd0df6054aeda354"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gaba1abc67da718dd4dd0df6054aeda354">XMC_CCU4_SLICE_MODULATION_MODE_t</a> </td></tr>
<tr class="separator:gaba1abc67da718dd4dd0df6054aeda354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99a221425b50cb24f3358c905c92f105"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga99a221425b50cb24f3358c905c92f105">XMC_CCU4_SLICE_MULTI_IRQ_ID_t</a> </td></tr>
<tr class="separator:ga99a221425b50cb24f3358c905c92f105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1e13100aef87f3fdbffcd561b1d7e57"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gad1e13100aef87f3fdbffcd561b1d7e57">XMC_CCU4_SLICE_OUTPUT_PASSIVE_LEVEL_t</a> </td></tr>
<tr class="separator:gad1e13100aef87f3fdbffcd561b1d7e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dcda6886b599a8260e6f9934dd74dc1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga1dcda6886b599a8260e6f9934dd74dc1">XMC_CCU4_SLICE_PRESCALER_MODE_t</a> </td></tr>
<tr class="separator:ga1dcda6886b599a8260e6f9934dd74dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga871bce3beb610d5e16b083c68381a60f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga871bce3beb610d5e16b083c68381a60f">XMC_CCU4_SLICE_PRESCALER_t</a> </td></tr>
<tr class="separator:ga871bce3beb610d5e16b083c68381a60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b7d3d96e6ba78dd55ca0850379ebf9d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga6b7d3d96e6ba78dd55ca0850379ebf9d">XMC_CCU4_SLICE_SHADOW_TRANSFER_MODE_t</a> </td></tr>
<tr class="separator:ga6b7d3d96e6ba78dd55ca0850379ebf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9de58e90257a0c33532f376c7c5f959e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga9de58e90257a0c33532f376c7c5f959e">XMC_CCU4_SLICE_SR_ID_t</a> </td></tr>
<tr class="separator:ga9de58e90257a0c33532f376c7c5f959e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga665528c9d6bedf104384b20797e892c3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga665528c9d6bedf104384b20797e892c3">XMC_CCU4_SLICE_START_MODE_t</a> </td></tr>
<tr class="separator:ga665528c9d6bedf104384b20797e892c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bd133ab5643ed217b548ce94f6bacc6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga5bd133ab5643ed217b548ce94f6bacc6">XMC_CCU4_SLICE_STATUS_BIT_t</a> </td></tr>
<tr class="separator:ga5bd133ab5643ed217b548ce94f6bacc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39bc5ede3f6f7d5e44dbaf01f0e3a98d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga39bc5ede3f6f7d5e44dbaf01f0e3a98d">XMC_CCU4_SLICE_TIMER_CLEAR_MODE_t</a> </td></tr>
<tr class="separator:ga39bc5ede3f6f7d5e44dbaf01f0e3a98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbf19766ba6532d4b09ac3ac1cd0d571"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gacbf19766ba6532d4b09ac3ac1cd0d571">XMC_CCU4_SLICE_TIMER_COUNT_DIR_t</a> </td></tr>
<tr class="separator:gacbf19766ba6532d4b09ac3ac1cd0d571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga488780142d4d7da249cbb6e2c16ec512"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga488780142d4d7da249cbb6e2c16ec512">XMC_CCU4_SLICE_TIMER_COUNT_MODE_t</a> </td></tr>
<tr class="separator:ga488780142d4d7da249cbb6e2c16ec512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c8c78c8c4ec52eae3d4654aa37ad9d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga85c8c78c8c4ec52eae3d4654aa37ad9d">XMC_CCU4_SLICE_TIMER_REPEAT_MODE_t</a> </td></tr>
<tr class="separator:ga85c8c78c8c4ec52eae3d4654aa37ad9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc3c6b390f18574d954473174a595eb2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gafc3c6b390f18574d954473174a595eb2">XMC_CCU4_SLICE_TRAP_EXIT_MODE_t</a> </td></tr>
<tr class="separator:gafc3c6b390f18574d954473174a595eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf1dcb4c712c711441f1ee42a8577bd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga1cf1dcb4c712c711441f1ee42a8577bd">XMC_CCU4_SLICE_WRITE_INTO_t</a> </td></tr>
<tr class="separator:ga1cf1dcb4c712c711441f1ee42a8577bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0f35f7b62570cbbd9ff102fea356b62"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gac0f35f7b62570cbbd9ff102fea356b62">XMC_CCU4_STATUS_t</a> </td></tr>
<tr class="separator:gac0f35f7b62570cbbd9ff102fea356b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac29c624b192d2b963e29389ae01a707a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gac29c624b192d2b963e29389ae01a707a">XMC_CCU4_SUSPEND_MODE_t</a> </td></tr>
<tr class="separator:gac29c624b192d2b963e29389ae01a707a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga58ad9c171f730ad379f349aac4e78009"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga58ad9c171f730ad379f349aac4e78009">XMC_CCU4_DisableClock</a> (<a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const module, const uint8_t slice_number)</td></tr>
<tr class="separator:ga58ad9c171f730ad379f349aac4e78009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb7f295a4b04bd0cf79e9df8da97a954"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gacb7f295a4b04bd0cf79e9df8da97a954">XMC_CCU4_DisableModule</a> (<a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const module)</td></tr>
<tr class="separator:gacb7f295a4b04bd0cf79e9df8da97a954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1809347868d61b8627442802601fb863"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga1809347868d61b8627442802601fb863">XMC_CCU4_EnableClock</a> (<a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const module, const uint8_t slice_number)</td></tr>
<tr class="separator:ga1809347868d61b8627442802601fb863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71ef51e46d57bdd95563fdc0da1f44c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga71ef51e46d57bdd95563fdc0da1f44c3">XMC_CCU4_EnableModule</a> (<a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const module)</td></tr>
<tr class="separator:ga71ef51e46d57bdd95563fdc0da1f44c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga636c23537ae9718af9bb3c3f66c7db4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga636c23537ae9718af9bb3c3f66c7db4b">XMC_CCU4_EnableMultipleClocks</a> (<a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const module, const uint8_t clock_mask)</td></tr>
<tr class="separator:ga636c23537ae9718af9bb3c3f66c7db4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcfbaa660e4c008e78128b8deb4cc5c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gadcfbaa660e4c008e78128b8deb4cc5c1">XMC_CCU4_EnableShadowTransfer</a> (<a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const module, const uint32_t shadow_transfer_msk)</td></tr>
<tr class="separator:gadcfbaa660e4c008e78128b8deb4cc5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38533fac543669af19de6972cd56a3a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_c_u4.html#ga5bd133ab5643ed217b548ce94f6bacc6">XMC_CCU4_SLICE_STATUS_BIT_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga38533fac543669af19de6972cd56a3a9">XMC_CCU4_GetSliceStatusBit</a> (<a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const module, uint8_t slice_number)</td></tr>
<tr class="separator:ga38533fac543669af19de6972cd56a3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ab30100f7e86a8f47095282a123d071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga6ab30100f7e86a8f47095282a123d071">XMC_CCU4_Init</a> (<a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const module, const <a class="el" href="group___c_c_u4.html#ga1cdf6b35dbf21bc9ffd767cf8df77615">XMC_CCU4_SLICE_MCMS_ACTION_t</a> mcs_action)</td></tr>
<tr class="separator:ga6ab30100f7e86a8f47095282a123d071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13b0b2fb23ac55d1fcfa41378e22e395"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga13b0b2fb23ac55d1fcfa41378e22e395">XMC_CCU4_IsPrescalerRunning</a> (<a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const module)</td></tr>
<tr class="separator:ga13b0b2fb23ac55d1fcfa41378e22e395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafc3f9bdcb648bf3e2cc6fdd1a597d3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gaafc3f9bdcb648bf3e2cc6fdd1a597d3e">XMC_CCU4_SetModuleClock</a> (<a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const module, const <a class="el" href="group___c_c_u4.html#gaf5e64519972ca9ee2c9b590eba7c041b">XMC_CCU4_CLOCK_t</a> clock)</td></tr>
<tr class="separator:gaafc3f9bdcb648bf3e2cc6fdd1a597d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10d688acde3cd3ffa2067973c640f9bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga10d688acde3cd3ffa2067973c640f9bf">XMC_CCU4_SetMultiChannelShadowTransferMode</a> (<a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const module, const uint32_t slice_mode_msk)</td></tr>
<tr class="separator:ga10d688acde3cd3ffa2067973c640f9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga541ed12424b01306986e12e15172e175"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga541ed12424b01306986e12e15172e175">XMC_CCU4_SetSuspendMode</a> (<a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const module, const <a class="el" href="group___c_c_u4.html#gac29c624b192d2b963e29389ae01a707a">XMC_CCU4_SUSPEND_MODE_t</a> mode)</td></tr>
<tr class="separator:ga541ed12424b01306986e12e15172e175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ed073924b8580efb863070ddf20426a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga3ed073924b8580efb863070ddf20426a">XMC_CCU4_SLICE_Capture0Config</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a> event)</td></tr>
<tr class="separator:ga3ed073924b8580efb863070ddf20426a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01bd8510437249b1bc33eb5cd2da7b0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga01bd8510437249b1bc33eb5cd2da7b0f">XMC_CCU4_SLICE_Capture1Config</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a> event)</td></tr>
<tr class="separator:ga01bd8510437249b1bc33eb5cd2da7b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e1afff754cd0b288f3ef9e364b86092"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga0e1afff754cd0b288f3ef9e364b86092">XMC_CCU4_SLICE_CaptureInit</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="struct_x_m_c___c_c_u4___s_l_i_c_e___c_a_p_t_u_r_e___c_o_n_f_i_g__t.html">XMC_CCU4_SLICE_CAPTURE_CONFIG_t</a> *const capture_init)</td></tr>
<tr class="separator:ga0e1afff754cd0b288f3ef9e364b86092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40dd61be60dc66c77164829280181e90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga40dd61be60dc66c77164829280181e90">XMC_CCU4_SLICE_ClearEvent</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#ga9b6b22c75755089c6c4038de4a5d213c">XMC_CCU4_SLICE_IRQ_ID_t</a> event)</td></tr>
<tr class="separator:ga40dd61be60dc66c77164829280181e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4520a69a5d5e653512ca6042feef4678"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga4520a69a5d5e653512ca6042feef4678">XMC_CCU4_SLICE_ClearTimer</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:ga4520a69a5d5e653512ca6042feef4678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf6a6054b308d38a5d05a518d042873"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gaaaf6a6054b308d38a5d05a518d042873">XMC_CCU4_SLICE_CompareInit</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="struct_x_m_c___c_c_u4___s_l_i_c_e___c_o_m_p_a_r_e___c_o_n_f_i_g__t.html">XMC_CCU4_SLICE_COMPARE_CONFIG_t</a> *const compare_init)</td></tr>
<tr class="separator:gaaaf6a6054b308d38a5d05a518d042873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6417b3f8823b6c76ec44118fc9c1eeb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga6417b3f8823b6c76ec44118fc9c1eeb7">XMC_CCU4_SLICE_ConfigureEvent</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a> event, const <a class="el" href="struct_x_m_c___c_c_u4___s_l_i_c_e___e_v_e_n_t___c_o_n_f_i_g__t.html">XMC_CCU4_SLICE_EVENT_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga6417b3f8823b6c76ec44118fc9c1eeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b084822487e0ca0a4a950c7d0f36fa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga0b084822487e0ca0a4a950c7d0f36fa7">XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="struct_x_m_c___c_c_u4___s_l_i_c_e___e_v_e_n_t___c_o_n_f_i_g__t.html">XMC_CCU4_SLICE_EVENT_CONFIG_t</a> *const ev1_config, const <a class="el" href="struct_x_m_c___c_c_u4___s_l_i_c_e___e_v_e_n_t___c_o_n_f_i_g__t.html">XMC_CCU4_SLICE_EVENT_CONFIG_t</a> *const ev2_config)</td></tr>
<tr class="separator:ga0b084822487e0ca0a4a950c7d0f36fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf312a02f00b3149c2f5cd3faea6f93c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gaf312a02f00b3149c2f5cd3faea6f93c2">XMC_CCU4_SLICE_CountConfig</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a> event)</td></tr>
<tr class="separator:gaf312a02f00b3149c2f5cd3faea6f93c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac61d7dc678e8379b4afaa8d763975866"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gac61d7dc678e8379b4afaa8d763975866">XMC_CCU4_SLICE_DirectionConfig</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a> event)</td></tr>
<tr class="separator:gac61d7dc678e8379b4afaa8d763975866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e4002ef45cbd1504f1dfa03be7f79d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga3e4002ef45cbd1504f1dfa03be7f79d6">XMC_CCU4_SLICE_DisableAutomaticShadowTransferRequest</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const uint32_t automatic_shadow_transfer)</td></tr>
<tr class="separator:ga3e4002ef45cbd1504f1dfa03be7f79d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf299d2965b919f5828ded78d2d015baa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gaf299d2965b919f5828ded78d2d015baa">XMC_CCU4_SLICE_DisableCascadedShadowTransfer</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:gaf299d2965b919f5828ded78d2d015baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga074938e1d84568cc5d0c14247188ceab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga074938e1d84568cc5d0c14247188ceab">XMC_CCU4_SLICE_DisableDithering</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:ga074938e1d84568cc5d0c14247188ceab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d8dd9cc41693043dec0ae759d91fbae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga1d8dd9cc41693043dec0ae759d91fbae">XMC_CCU4_SLICE_DisableEvent</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#ga9b6b22c75755089c6c4038de4a5d213c">XMC_CCU4_SLICE_IRQ_ID_t</a> event)</td></tr>
<tr class="separator:ga1d8dd9cc41693043dec0ae759d91fbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2c8386269be2f976ab9bb83da99087a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gae2c8386269be2f976ab9bb83da99087a">XMC_CCU4_SLICE_DisableFloatingPrescaler</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:gae2c8386269be2f976ab9bb83da99087a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08273e7c8fa6261de82759637831a989"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga08273e7c8fa6261de82759637831a989">XMC_CCU4_SLICE_DisableMultiChannelMode</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:ga08273e7c8fa6261de82759637831a989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3152586e4a4d2f25775bb0286653ca8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga3152586e4a4d2f25775bb0286653ca8c">XMC_CCU4_SLICE_DisableMultipleEvents</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const uint16_t mask)</td></tr>
<tr class="separator:ga3152586e4a4d2f25775bb0286653ca8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga528b039bddfe9e20f765aaa2f7bdcc0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga528b039bddfe9e20f765aaa2f7bdcc0e">XMC_CCU4_SLICE_DisableTrap</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:ga528b039bddfe9e20f765aaa2f7bdcc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada142961bff1eae9b4182249810b762e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gada142961bff1eae9b4182249810b762e">XMC_CCU4_SLICE_EnableAutomaticShadowTransferRequest</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const uint32_t automatic_shadow_transfer)</td></tr>
<tr class="separator:gada142961bff1eae9b4182249810b762e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a44e999105f023b688fb8e3cf28c43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gaa8a44e999105f023b688fb8e3cf28c43">XMC_CCU4_SLICE_EnableCascadedShadowTransfer</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:gaa8a44e999105f023b688fb8e3cf28c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga726d7c99adf8d7f438f1f08ef2a9de1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga726d7c99adf8d7f438f1f08ef2a9de1a">XMC_CCU4_SLICE_EnableDithering</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const bool period_dither, const bool duty_dither, const uint8_t spread)</td></tr>
<tr class="separator:ga726d7c99adf8d7f438f1f08ef2a9de1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70968924480cf3d06eb9381856a69b87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga70968924480cf3d06eb9381856a69b87">XMC_CCU4_SLICE_EnableEvent</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#ga9b6b22c75755089c6c4038de4a5d213c">XMC_CCU4_SLICE_IRQ_ID_t</a> event)</td></tr>
<tr class="separator:ga70968924480cf3d06eb9381856a69b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga495ca5dfa02beb5a818dd113ebf99ae1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga495ca5dfa02beb5a818dd113ebf99ae1">XMC_CCU4_SLICE_EnableFloatingPrescaler</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:ga495ca5dfa02beb5a818dd113ebf99ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga470cd6e533923a9495e76fd7f0fcf0de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga470cd6e533923a9495e76fd7f0fcf0de">XMC_CCU4_SLICE_EnableMultiChannelMode</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:ga470cd6e533923a9495e76fd7f0fcf0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc79794c8392fdd71e843220786d8d99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gadc79794c8392fdd71e843220786d8d99">XMC_CCU4_SLICE_EnableMultipleEvents</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const uint16_t intr_mask)</td></tr>
<tr class="separator:gadc79794c8392fdd71e843220786d8d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba1fc3c0735f1bed11dafb3d4c773ba5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gaba1fc3c0735f1bed11dafb3d4c773ba5">XMC_CCU4_SLICE_EnableTrap</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:gaba1fc3c0735f1bed11dafb3d4c773ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbf3c4118d03da31af66baf439183cae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gafbf3c4118d03da31af66baf439183cae">XMC_CCU4_SLICE_GateConfig</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a> event)</td></tr>
<tr class="separator:gafbf3c4118d03da31af66baf439183cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c918bf66f4046e22bb10f7172f8ae41"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga0c918bf66f4046e22bb10f7172f8ae41">XMC_CCU4_SLICE_GetCapturedValueFromFifo</a> (const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#gab5c05e6fda34ac046c12ec25ef405a3d">XMC_CCU4_SLICE_CAP_REG_SET_t</a> set)</td></tr>
<tr class="separator:ga0c918bf66f4046e22bb10f7172f8ae41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b2360da5116806f763ee79a63591ab"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gaf3b2360da5116806f763ee79a63591ab">XMC_CCU4_SLICE_GetCaptureRegisterValue</a> (const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const uint8_t reg_num)</td></tr>
<tr class="separator:gaf3b2360da5116806f763ee79a63591ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6762faa90aae0987218b1c0b173b5385"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_c_u4.html#gacbf19766ba6532d4b09ac3ac1cd0d571">XMC_CCU4_SLICE_TIMER_COUNT_DIR_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga6762faa90aae0987218b1c0b173b5385">XMC_CCU4_SLICE_GetCountingDir</a> (const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:ga6762faa90aae0987218b1c0b173b5385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d5a5802adc4917b4802db02926397e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga6d5a5802adc4917b4802db02926397e9">XMC_CCU4_SLICE_GetEvent</a> (const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#ga9b6b22c75755089c6c4038de4a5d213c">XMC_CCU4_SLICE_IRQ_ID_t</a> event)</td></tr>
<tr class="separator:ga6d5a5802adc4917b4802db02926397e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3392bbfae89deb4a809aab04efde114b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_c_u4.html#gac0f35f7b62570cbbd9ff102fea356b62">XMC_CCU4_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga3392bbfae89deb4a809aab04efde114b">XMC_CCU4_SLICE_GetLastCapturedTimerValue</a> (const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#gab5c05e6fda34ac046c12ec25ef405a3d">XMC_CCU4_SLICE_CAP_REG_SET_t</a> set, uint32_t *val_ptr)</td></tr>
<tr class="separator:ga3392bbfae89deb4a809aab04efde114b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace251376e4d8988e023fbf11013791c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_c_u4.html#ga871bce3beb610d5e16b083c68381a60f">XMC_CCU4_SLICE_PRESCALER_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gace251376e4d8988e023fbf11013791c4">XMC_CCU4_SLICE_GetPrescaler</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:gace251376e4d8988e023fbf11013791c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aa3f23d1d1251bfc67284abd641eb0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_c_u4.html#ga9667e43e2a54209c309f767354a0af8e">XMC_CCU4_SLICE_MODE_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga0aa3f23d1d1251bfc67284abd641eb0b">XMC_CCU4_SLICE_GetSliceMode</a> (const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:ga0aa3f23d1d1251bfc67284abd641eb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dbf6592e274fd4a3df6322abbcf1af3"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga6dbf6592e274fd4a3df6322abbcf1af3">XMC_CCU4_SLICE_GetTimerCompareMatch</a> (const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:ga6dbf6592e274fd4a3df6322abbcf1af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac330a353060ff06f84d2d9835716ea94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_c_u4.html#ga488780142d4d7da249cbb6e2c16ec512">XMC_CCU4_SLICE_TIMER_COUNT_MODE_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gac330a353060ff06f84d2d9835716ea94">XMC_CCU4_SLICE_GetTimerCountingMode</a> (const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:gac330a353060ff06f84d2d9835716ea94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f030851ea5f6abc4d7e1ecd7de2906"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga33f030851ea5f6abc4d7e1ecd7de2906">XMC_CCU4_SLICE_GetTimerPeriodMatch</a> (const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:ga33f030851ea5f6abc4d7e1ecd7de2906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad164d9989a251f651159323c718965f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_c_u4.html#ga85c8c78c8c4ec52eae3d4654aa37ad9d">XMC_CCU4_SLICE_TIMER_REPEAT_MODE_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gad164d9989a251f651159323c718965f1">XMC_CCU4_SLICE_GetTimerRepeatMode</a> (const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:gad164d9989a251f651159323c718965f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d9be217f287f53b1e96e929753acf41"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga9d9be217f287f53b1e96e929753acf41">XMC_CCU4_SLICE_GetTimerValue</a> (const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:ga9d9be217f287f53b1e96e929753acf41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9fa582be48916db21e086f073930ce2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gaf9fa582be48916db21e086f073930ce2">XMC_CCU4_SLICE_IsExtendedCapReadEnabled</a> (const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:gaf9fa582be48916db21e086f073930ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga505356f6ed183985041548ee87abfa69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga505356f6ed183985041548ee87abfa69">XMC_CCU4_SLICE_IsTimerRunning</a> (const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:ga505356f6ed183985041548ee87abfa69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d77fccc50ddf0c24b4906fd1b4ba1ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga2d77fccc50ddf0c24b4906fd1b4ba1ae">XMC_CCU4_SLICE_LoadConfig</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a> event)</td></tr>
<tr class="separator:ga2d77fccc50ddf0c24b4906fd1b4ba1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14933455fad7c724768f0cf8fbd61324"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga14933455fad7c724768f0cf8fbd61324">XMC_CCU4_SLICE_ModulationConfig</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a> event, const <a class="el" href="group___c_c_u4.html#gaba1abc67da718dd4dd0df6054aeda354">XMC_CCU4_SLICE_MODULATION_MODE_t</a> mod_mode, const bool synch_with_pwm)</td></tr>
<tr class="separator:ga14933455fad7c724768f0cf8fbd61324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac459b6e5e0efccd9bc762c5add86ca48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gac459b6e5e0efccd9bc762c5add86ca48">XMC_CCU4_SLICE_SetDitherCompareValue</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const uint8_t comp_val)</td></tr>
<tr class="separator:gac459b6e5e0efccd9bc762c5add86ca48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa063b2ed84316c3dfb3f45b8cf2fcd38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gaa063b2ed84316c3dfb3f45b8cf2fcd38">XMC_CCU4_SLICE_SetEvent</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#ga9b6b22c75755089c6c4038de4a5d213c">XMC_CCU4_SLICE_IRQ_ID_t</a> event)</td></tr>
<tr class="separator:gaa063b2ed84316c3dfb3f45b8cf2fcd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga989c0d32380efe2053c259ff4e7d3c78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga989c0d32380efe2053c259ff4e7d3c78">XMC_CCU4_SLICE_SetFloatingPrescalerCompareValue</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const uint8_t cmp_val)</td></tr>
<tr class="separator:ga989c0d32380efe2053c259ff4e7d3c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28e214514acb1a75a67de63e6d74b167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a> event, const <a class="el" href="group___c_c_u4.html#gaab7f7bcdc1aff8cc0beb2edae16a3cf3">XMC_CCU4_SLICE_INPUT_t</a> input)</td></tr>
<tr class="separator:ga28e214514acb1a75a67de63e6d74b167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c882083ebd4d874a466b61d011e3f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga08c882083ebd4d874a466b61d011e3f7">XMC_CCU4_SLICE_SetInterruptNode</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#ga9b6b22c75755089c6c4038de4a5d213c">XMC_CCU4_SLICE_IRQ_ID_t</a> event, const <a class="el" href="group___c_c_u4.html#ga9de58e90257a0c33532f376c7c5f959e">XMC_CCU4_SLICE_SR_ID_t</a> sr)</td></tr>
<tr class="separator:ga08c882083ebd4d874a466b61d011e3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga962a6a7402c99ec80359d3202ae9cd50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga962a6a7402c99ec80359d3202ae9cd50">XMC_CCU4_SLICE_SetPassiveLevel</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#gad1e13100aef87f3fdbffcd561b1d7e57">XMC_CCU4_SLICE_OUTPUT_PASSIVE_LEVEL_t</a> level)</td></tr>
<tr class="separator:ga962a6a7402c99ec80359d3202ae9cd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24127bd989b62814c2ba0cc876b99473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga24127bd989b62814c2ba0cc876b99473">XMC_CCU4_SLICE_SetPrescaler</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#ga871bce3beb610d5e16b083c68381a60f">XMC_CCU4_SLICE_PRESCALER_t</a> div_val)</td></tr>
<tr class="separator:ga24127bd989b62814c2ba0cc876b99473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8631a666973bd4471bb80d8f08ae99cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga8631a666973bd4471bb80d8f08ae99cd">XMC_CCU4_SLICE_SetShadowTransferMode</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#ga6b7d3d96e6ba78dd55ca0850379ebf9d">XMC_CCU4_SLICE_SHADOW_TRANSFER_MODE_t</a> shadow_transfer_mode)</td></tr>
<tr class="separator:ga8631a666973bd4471bb80d8f08ae99cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae1adcaba614fa7d919221da9020a57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga7ae1adcaba614fa7d919221da9020a57">XMC_CCU4_SLICE_SetTimerCompareMatch</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const uint16_t compare_val)</td></tr>
<tr class="separator:ga7ae1adcaba614fa7d919221da9020a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b25352390bfa747b51ba511fe85c57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga35b25352390bfa747b51ba511fe85c57">XMC_CCU4_SLICE_SetTimerCountingMode</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#ga488780142d4d7da249cbb6e2c16ec512">XMC_CCU4_SLICE_TIMER_COUNT_MODE_t</a> mode)</td></tr>
<tr class="separator:ga35b25352390bfa747b51ba511fe85c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1341abfd52a8165c7e1b5292033797ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga1341abfd52a8165c7e1b5292033797ed">XMC_CCU4_SLICE_SetTimerPeriodMatch</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const uint16_t period_val)</td></tr>
<tr class="separator:ga1341abfd52a8165c7e1b5292033797ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaceaa5953e0235db8f17592c3606aff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gaaaceaa5953e0235db8f17592c3606aff">XMC_CCU4_SLICE_SetTimerRepeatMode</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#ga85c8c78c8c4ec52eae3d4654aa37ad9d">XMC_CCU4_SLICE_TIMER_REPEAT_MODE_t</a> mode)</td></tr>
<tr class="separator:gaaaceaa5953e0235db8f17592c3606aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad654c695ac03c9218657816e4468d835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gad654c695ac03c9218657816e4468d835">XMC_CCU4_SLICE_SetTimerValue</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const uint16_t timer_val)</td></tr>
<tr class="separator:gad654c695ac03c9218657816e4468d835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac029dc08c5d54be8e773df0de9641691"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a> event, const <a class="el" href="group___c_c_u4.html#ga665528c9d6bedf104384b20797e892c3">XMC_CCU4_SLICE_START_MODE_t</a> start_mode)</td></tr>
<tr class="separator:gac029dc08c5d54be8e773df0de9641691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9997bb59706a4034e3e3be33a4935a7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga9997bb59706a4034e3e3be33a4935a7c">XMC_CCU4_SLICE_StartTimer</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:ga9997bb59706a4034e3e3be33a4935a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1ff68c2bae61d72c539684a050553b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga8f1ff68c2bae61d72c539684a050553b">XMC_CCU4_SLICE_StatusBitOverrideConfig</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:ga8f1ff68c2bae61d72c539684a050553b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bd3401eb3b8744163b730998e5e3f7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga9bd3401eb3b8744163b730998e5e3f7a">XMC_CCU4_SLICE_StopClearTimer</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:ga9bd3401eb3b8744163b730998e5e3f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17330b4b761f443140b1c736c1a09840"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga17330b4b761f443140b1c736c1a09840">XMC_CCU4_SLICE_StopConfig</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a> event, const <a class="el" href="group___c_c_u4.html#gaed08e3fd07e061ccb45377415a958c6a">XMC_CCU4_SLICE_END_MODE_t</a> end_mode)</td></tr>
<tr class="separator:ga17330b4b761f443140b1c736c1a09840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac41eed8d2857f7c9d23567fa742a705c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gac41eed8d2857f7c9d23567fa742a705c">XMC_CCU4_SLICE_StopTimer</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice)</td></tr>
<tr class="separator:gac41eed8d2857f7c9d23567fa742a705c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2d5615177cfa2f20c5f5655400f4a8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gab2d5615177cfa2f20c5f5655400f4a8e">XMC_CCU4_SLICE_TrapConfig</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const <a class="el" href="group___c_c_u4.html#gafc3c6b390f18574d954473174a595eb2">XMC_CCU4_SLICE_TRAP_EXIT_MODE_t</a> exit_mode, bool synch_with_pwm)</td></tr>
<tr class="separator:gab2d5615177cfa2f20c5f5655400f4a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga416ddf2d93e243f85ecbf5b087b4672f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga416ddf2d93e243f85ecbf5b087b4672f">XMC_CCU4_SLICE_WriteCoherentlyWithPWMCycle</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const uint32_t coherent_write)</td></tr>
<tr class="separator:ga416ddf2d93e243f85ecbf5b087b4672f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5048bfa6fbbcc4752d137f32c141743c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#ga5048bfa6fbbcc4752d137f32c141743c">XMC_CCU4_SLICE_WriteImmediateAfterShadowTransfer</a> (<a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const slice, const uint32_t immediate_write)</td></tr>
<tr class="separator:ga5048bfa6fbbcc4752d137f32c141743c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad492e0c49bfa5b89b01d6dd5a43a1e1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gad492e0c49bfa5b89b01d6dd5a43a1e1b">XMC_CCU4_StartPrescaler</a> (<a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const module)</td></tr>
<tr class="separator:gad492e0c49bfa5b89b01d6dd5a43a1e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3741bc9dc0cb9f565ade9182d73141f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_c_u4.html#gae3741bc9dc0cb9f565ade9182d73141f">XMC_CCU4_StopPrescaler</a> (<a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const module)</td></tr>
<tr class="separator:gae3741bc9dc0cb9f565ade9182d73141f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The CCU4 peripheral is a major component for systems that need general purpose timers for signal monitoring/conditioning and Pulse Width Modulation (PWM) signal generation. Power electronic control systems like switched mode power supplies or interruptible power supplies, can easily be implemented with the functions inside the CCU4 peripheral.<br />
Each CCU4 module is comprised of four identical 16 bit Capture/Compare Timer slices, CC4y (where y = [0..4]). Each timer slice can work in compare mode or in capture mode.</p>
<p>APIs provided in this file cover the following functional blocks of CCU4:<br />
&ndash; Timer configuration, Capture configuration, Function/Event configuration, Interrupt configuration<br />
</p><dl class="section user"><dt>Note:</dt><dd><ol type="1">
<li>SLICE (APIs prefixed with e.g. XMC_CCU4_SLICE_)</li>
<li>Module (APIs are not having any prefix e.g. XMC_CCU4_)</li>
</ol>
</dd></dl>
<dl class="section user"><dt>Timer(Compare mode) configuration:</dt><dd>This section of the LLD provides the configuration structure <a class="el" href="struct_x_m_c___c_c_u4___s_l_i_c_e___c_o_m_p_a_r_e___c_o_n_f_i_g__t.html">XMC_CCU4_SLICE_COMPARE_CONFIG_t</a> and the initialization function <a class="el" href="group___c_c_u4.html#gaaaf6a6054b308d38a5d05a518d042873">XMC_CCU4_SLICE_CompareInit()</a>.</dd></dl>
<p>It can be used to:</p><ol type="1">
<li>Start and Stop the timer. (<a class="el" href="group___c_c_u4.html#ga9997bb59706a4034e3e3be33a4935a7c">XMC_CCU4_SLICE_StartTimer()</a>, <a class="el" href="group___c_c_u4.html#gac41eed8d2857f7c9d23567fa742a705c">XMC_CCU4_SLICE_StopTimer()</a>)</li>
<li>Update the period, compare, Dither, Prescaler and Passive values. (<a class="el" href="group___c_c_u4.html#ga1341abfd52a8165c7e1b5292033797ed">XMC_CCU4_SLICE_SetTimerPeriodMatch()</a>, <a class="el" href="group___c_c_u4.html#ga7ae1adcaba614fa7d919221da9020a57">XMC_CCU4_SLICE_SetTimerCompareMatch()</a>, <a class="el" href="group___c_c_u4.html#ga24127bd989b62814c2ba0cc876b99473">XMC_CCU4_SLICE_SetPrescaler()</a>, <a class="el" href="group___c_c_u4.html#gac459b6e5e0efccd9bc762c5add86ca48">XMC_CCU4_SLICE_SetDitherCompareValue()</a>, <a class="el" href="group___c_c_u4.html#ga962a6a7402c99ec80359d3202ae9cd50">XMC_CCU4_SLICE_SetPassiveLevel()</a>)</li>
<li>Enable the slices to support multichannel mode. (<a class="el" href="group___c_c_u4.html#ga470cd6e533923a9495e76fd7f0fcf0de">XMC_CCU4_SLICE_EnableMultiChannelMode()</a>)</li>
</ol>
<dl class="section user"><dt>Capture configuration:</dt><dd>This section of the LLD provides the configuration structure <a class="el" href="struct_x_m_c___c_c_u4___s_l_i_c_e___c_a_p_t_u_r_e___c_o_n_f_i_g__t.html">XMC_CCU4_SLICE_CAPTURE_CONFIG_t</a> and the initialization function <a class="el" href="group___c_c_u4.html#ga0e1afff754cd0b288f3ef9e364b86092">XMC_CCU4_SLICE_CaptureInit()</a>.</dd></dl>
<p>It can be used to:</p><ol type="1">
<li>Configure the capture functionality. (<a class="el" href="group___c_c_u4.html#ga3ed073924b8580efb863070ddf20426a">XMC_CCU4_SLICE_Capture0Config()</a>, <a class="el" href="group___c_c_u4.html#ga01bd8510437249b1bc33eb5cd2da7b0f">XMC_CCU4_SLICE_Capture1Config()</a>)</li>
<li>Read the captured values along with the status, which indicate the value is latest or not. (<a class="el" href="group___c_c_u4.html#gaf3b2360da5116806f763ee79a63591ab">XMC_CCU4_SLICE_GetCaptureRegisterValue()</a>)</li>
</ol>
<dl class="section user"><dt>Function/Event configuration:</dt><dd>This section of the LLD provides the configuration structure <a class="el" href="struct_x_m_c___c_c_u4___s_l_i_c_e___e_v_e_n_t___c_o_n_f_i_g__t.html">XMC_CCU4_SLICE_EVENT_CONFIG_t</a>.<br />
 It can be used to:<ol type="1">
<li>Enable and Disable the events. (<a class="el" href="group___c_c_u4.html#ga70968924480cf3d06eb9381856a69b87">XMC_CCU4_SLICE_EnableEvent()</a>, <a class="el" href="group___c_c_u4.html#ga1d8dd9cc41693043dec0ae759d91fbae">XMC_CCU4_SLICE_DisableEvent()</a>)</li>
<li>Configure to start and stop the timer on external events.(<a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig()</a>, <a class="el" href="group___c_c_u4.html#ga17330b4b761f443140b1c736c1a09840">XMC_CCU4_SLICE_StopConfig()</a>)</li>
<li>Modulation, external load and Gating of the timer output.(<a class="el" href="group___c_c_u4.html#ga14933455fad7c724768f0cf8fbd61324">XMC_CCU4_SLICE_ModulationConfig()</a>, <a class="el" href="group___c_c_u4.html#ga2d77fccc50ddf0c24b4906fd1b4ba1ae">XMC_CCU4_SLICE_LoadConfig()</a>, <a class="el" href="group___c_c_u4.html#gafbf3c4118d03da31af66baf439183cae">XMC_CCU4_SLICE_GateConfig()</a>)</li>
<li>Control the count direction of the timer based on the external event. (<a class="el" href="group___c_c_u4.html#gac61d7dc678e8379b4afaa8d763975866">XMC_CCU4_SLICE_DirectionConfig()</a>)</li>
<li>Count the external events.(<a class="el" href="group___c_c_u4.html#gaf312a02f00b3149c2f5cd3faea6f93c2">XMC_CCU4_SLICE_CountConfig()</a>)</li>
<li>External Trap. Which can be used as protective feature.(<a class="el" href="group___c_c_u4.html#gaba1fc3c0735f1bed11dafb3d4c773ba5">XMC_CCU4_SLICE_EnableTrap()</a>, <a class="el" href="group___c_c_u4.html#ga528b039bddfe9e20f765aaa2f7bdcc0e">XMC_CCU4_SLICE_DisableTrap()</a>, <a class="el" href="group___c_c_u4.html#gab2d5615177cfa2f20c5f5655400f4a8e">XMC_CCU4_SLICE_TrapConfig()</a>)</li>
</ol>
</dd></dl>
<dl class="section user"><dt>Interrupt configuration:</dt><dd>This section of the LLD provides the function to configure the interrupt node to each event (<a class="el" href="group___c_c_u4.html#ga08c882083ebd4d874a466b61d011e3f7">XMC_CCU4_SLICE_SetInterruptNode()</a>) </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gabc8c277fccba02adfd4c57fdbf66df71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc8c277fccba02adfd4c57fdbf66df71">&#9670;&nbsp;</a></span>XMC_CCU4_MODULE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef CCU4_GLOBAL_TypeDef <a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef for CCU4 Global data structure </p>

</div>
</div>
<a id="gaab7f7bcdc1aff8cc0beb2edae16a3cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab7f7bcdc1aff8cc0beb2edae16a3cf3">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_INPUT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="group___c_c_u4.html#gaab7f7bcdc1aff8cc0beb2edae16a3cf3">XMC_CCU4_SLICE_INPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>External Event Input list. This list depicts the possible input connections to the CCU4 slice. Interconnects are specific to each device. </p>

</div>
</div>
<a id="ga759d9cc26009d3567612d196ac3f3969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga759d9cc26009d3567612d196ac3f3969">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef CCU4_CC4_TypeDef <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef for CCU4 Slice data structure </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaf5e64519972ca9ee2c9b590eba7c041b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5e64519972ca9ee2c9b590eba7c041b">&#9670;&nbsp;</a></span>XMC_CCU4_CLOCK_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#gaf5e64519972ca9ee2c9b590eba7c041b">XMC_CCU4_CLOCK_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CCU4 module clock </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf5e64519972ca9ee2c9b590eba7c041ba4deb5b0622679b85cd70d22c4837c06c"></a>XMC_CCU4_CLOCK_SCU&#160;</td><td class="fielddoc"><p>Select the fCCU as the clock </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf5e64519972ca9ee2c9b590eba7c041ba43d3d2e51babff4ad846f917908a6643"></a>XMC_CCU4_CLOCK_EXTERNAL_A&#160;</td><td class="fielddoc"><p>External clock-A </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf5e64519972ca9ee2c9b590eba7c041baa674f73ca657b4db6e9e7ba04eb0a705"></a>XMC_CCU4_CLOCK_EXTERNAL_B&#160;</td><td class="fielddoc"><p>External clock-B </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf5e64519972ca9ee2c9b590eba7c041bad80e3f15924161536182512e77d055c1"></a>XMC_CCU4_CLOCK_EXTERNAL_C&#160;</td><td class="fielddoc"><p>External clock-C </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9a88d5f27f3d04acf49beae187238299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a88d5f27f3d04acf49beae187238299">&#9670;&nbsp;</a></span>XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga9a88d5f27f3d04acf49beae187238299">XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CCU4 set the shadow transfer type for multichannel mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9a88d5f27f3d04acf49beae187238299acb4554396269817e2613cf9834438676"></a>XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_SLICE0&#160;</td><td class="fielddoc"><p>Shadow transfer through software only for slice 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a88d5f27f3d04acf49beae187238299a544b030bf4838c41e6aaa83cc6b4f19c"></a>XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_MCSS_SLICE0&#160;</td><td class="fielddoc"><p>Shadow transfer through software and hardware for slice 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a88d5f27f3d04acf49beae187238299a4f300cfe0a4ed8fa98482d6c1855f3cc"></a>XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_SLICE1&#160;</td><td class="fielddoc"><p>Shadow transfer through software only for slice 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a88d5f27f3d04acf49beae187238299a26601e9cf361a3654835d6478218b410"></a>XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_MCSS_SLICE1&#160;</td><td class="fielddoc"><p>Shadow transfer through software and hardware for slice 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a88d5f27f3d04acf49beae187238299af2529181f7176bf8e10abd67dffa5760"></a>XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_SLICE2&#160;</td><td class="fielddoc"><p>Shadow transfer through software only for slice 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a88d5f27f3d04acf49beae187238299a611bad68cc4433cd957d63284a4f71aa"></a>XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_MCSS_SLICE2&#160;</td><td class="fielddoc"><p>Shadow transfer through software and hardware for slice 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a88d5f27f3d04acf49beae187238299ae0778e7e9ec14a0a4159bdd853687ad8"></a>XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_SLICE3&#160;</td><td class="fielddoc"><p>Shadow transfer through software only for slice 3 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a88d5f27f3d04acf49beae187238299a53dabf599c7711ee6a3f6d314104e13b"></a>XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_MCSS_SLICE3&#160;</td><td class="fielddoc"><p>Shadow transfer through software and hardware for slice 3 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8d2c64420abee84dccce68e68b942e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d2c64420abee84dccce68e68b942e67">&#9670;&nbsp;</a></span>XMC_CCU4_SHADOW_TRANSFER_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga8d2c64420abee84dccce68e68b942e67">XMC_CCU4_SHADOW_TRANSFER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Slice shadow transfer options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8d2c64420abee84dccce68e68b942e67a5f7f3e0bb3a17300679f5d595fc91aa8"></a>XMC_CCU4_SHADOW_TRANSFER_SLICE_0&#160;</td><td class="fielddoc"><p>Transfer Period, Compare and Passive Level shadow register values to actual registers for SLICE-0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d2c64420abee84dccce68e68b942e67aa90b1cb2a4e67094fbd409f5cc2cd405"></a>XMC_CCU4_SHADOW_TRANSFER_DITHER_SLICE_0&#160;</td><td class="fielddoc"><p>Transfer Dither compare shadow register value to actual register for SLICE-0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d2c64420abee84dccce68e68b942e67a645b1781c3eb75cb91412115594506c6"></a>XMC_CCU4_SHADOW_TRANSFER_PRESCALER_SLICE_0&#160;</td><td class="fielddoc"><p>Transfer Prescaler shadow register value to actual register for SLICE-0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d2c64420abee84dccce68e68b942e67a9a7680934bebba88c31eaa8511413119"></a>XMC_CCU4_SHADOW_TRANSFER_SLICE_1&#160;</td><td class="fielddoc"><p>Transfer Period, Compare and Passive Level shadow register values to actual registers for SLICE-1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d2c64420abee84dccce68e68b942e67a50b8ff29688ee7cd0bdee36df48964d1"></a>XMC_CCU4_SHADOW_TRANSFER_DITHER_SLICE_1&#160;</td><td class="fielddoc"><p>Transfer Dither compare shadow register value to actual registers for SLICE-1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d2c64420abee84dccce68e68b942e67aa6b353194a15b689bf278d5096111cb7"></a>XMC_CCU4_SHADOW_TRANSFER_PRESCALER_SLICE_1&#160;</td><td class="fielddoc"><p>Transfer Prescaler shadow register value to actual register for SLICE-1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d2c64420abee84dccce68e68b942e67a4c2eddfcf2a9aededba31fb616d81f6a"></a>XMC_CCU4_SHADOW_TRANSFER_SLICE_2&#160;</td><td class="fielddoc"><p>Transfer Period, Compare and Passive Level shadow register values to actual registers for SLICE-2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d2c64420abee84dccce68e68b942e67a18d9d9b0d43768a80257e6d09d8e269a"></a>XMC_CCU4_SHADOW_TRANSFER_DITHER_SLICE_2&#160;</td><td class="fielddoc"><p>Transfer Dither compare shadow register value to actual register for SLICE-2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d2c64420abee84dccce68e68b942e67aab602460197ddb047b0669d50eb07438"></a>XMC_CCU4_SHADOW_TRANSFER_PRESCALER_SLICE_2&#160;</td><td class="fielddoc"><p>Transfer Prescaler shadow register value to actual register for SLICE-2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d2c64420abee84dccce68e68b942e67aba2ebd26d8e8c60faaadc932a235f55d"></a>XMC_CCU4_SHADOW_TRANSFER_SLICE_3&#160;</td><td class="fielddoc"><p>Transfer Period, Compare and Passive Level shadow register values to actual registers for SLICE-3 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d2c64420abee84dccce68e68b942e67a9a4e23045766ee28fcdada89fb690d2f"></a>XMC_CCU4_SHADOW_TRANSFER_DITHER_SLICE_3&#160;</td><td class="fielddoc"><p>Transfer Dither compare shadow register value to actual register for SLICE-3 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d2c64420abee84dccce68e68b942e67a7f7c5fe0b3384b219430d815a0f41bab"></a>XMC_CCU4_SHADOW_TRANSFER_PRESCALER_SLICE_3&#160;</td><td class="fielddoc"><p>Transfer Prescaler shadow register value to actual register for SLICE-3 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2216adfcbbc93dde340169582ef17ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2216adfcbbc93dde340169582ef17ff6">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga2216adfcbbc93dde340169582ef17ff6">XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Automatic Shadow Transfer request when writing into shadow register </p><dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2216adfcbbc93dde340169582ef17ff6a26b5652444293e1123ca1daa4256779c"></a>XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_PERIOD_SHADOW&#160;</td><td class="fielddoc"><p>Automatic Shadow Transfer request when writing into Period Shadow Register </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2216adfcbbc93dde340169582ef17ff6aeaf05428ff334a16cfcc652eb2ce6e39"></a>XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_COMPARE_SHADOW&#160;</td><td class="fielddoc"><p>Automatic Shadow transfer request when writing into Compare Shadow Register </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2216adfcbbc93dde340169582ef17ff6af5b97b18e485a8c00dfaee23a1e60763"></a>XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_PASSIVE_LEVEL&#160;</td><td class="fielddoc"><p>Automatic Shadow transfer request when writing into Passive Level Register </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2216adfcbbc93dde340169582ef17ff6a1dd75a1607e1060f9cc0cbba49e129a2"></a>XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_DITHER_SHADOW&#160;</td><td class="fielddoc"><p>Automatic Shadow transfer request when writing into Dither Shadow Register </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2216adfcbbc93dde340169582ef17ff6a598a5a3e0bb4976dcd6e0b379263dfaf"></a>XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_FLOATING_PRESCALER_SHADOW&#160;</td><td class="fielddoc"><p>Automatic Shadow transfer request when writing into Floating Prescaler Shadow register </p>
</td></tr>
</table>

</div>
</div>
<a id="gab5c05e6fda34ac046c12ec25ef405a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5c05e6fda34ac046c12ec25ef405a3d">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_CAP_REG_SET_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#gab5c05e6fda34ac046c12ec25ef405a3d">XMC_CCU4_SLICE_CAP_REG_SET_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Capture mode register sets </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab5c05e6fda34ac046c12ec25ef405a3da10fbc9596fdd42ae042ec67e0c4ded2f"></a>XMC_CCU4_SLICE_CAP_REG_SET_LOW&#160;</td><td class="fielddoc"><p>Capture register-0, Capture register-1 used </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab5c05e6fda34ac046c12ec25ef405a3daca9cb79415d453134c3de65838dd2697"></a>XMC_CCU4_SLICE_CAP_REG_SET_HIGH&#160;</td><td class="fielddoc"><p>Capture register-2, Capture register-3 used </p>
</td></tr>
</table>

</div>
</div>
<a id="gaed08e3fd07e061ccb45377415a958c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed08e3fd07e061ccb45377415a958c6a">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_END_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#gaed08e3fd07e061ccb45377415a958c6a">XMC_CCU4_SLICE_END_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Actions that can be performed upon detection of an external Timer STOP event </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaed08e3fd07e061ccb45377415a958c6aacf0acaf0128b4de22ca78b183b4cf043"></a>XMC_CCU4_SLICE_END_MODE_TIMER_STOP&#160;</td><td class="fielddoc"><p>Stops the timer, without clearing TIMER register </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed08e3fd07e061ccb45377415a958c6aaacbae5ca775f3bda91af179b815691b0"></a>XMC_CCU4_SLICE_END_MODE_TIMER_CLEAR&#160;</td><td class="fielddoc"><p>Without stopping timer, clears the TIMER register </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed08e3fd07e061ccb45377415a958c6aad4cc5a2fe376cf3fe7cd5a1396c286f3"></a>XMC_CCU4_SLICE_END_MODE_TIMER_STOP_CLEAR&#160;</td><td class="fielddoc"><p>Stops the timer and clears the TIMER register </p>
</td></tr>
</table>

</div>
</div>
<a id="ga0d83f7d7d27ced4fbc071540f942cbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d83f7d7d27ced4fbc071540f942cbdd">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga0d83f7d7d27ced4fbc071540f942cbdd">XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>External Event trigger criteria - Edge sensitivity </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0d83f7d7d27ced4fbc071540f942cbdda2fef49c1f94a1445b4f6ac7d2079020a"></a>XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_NONE&#160;</td><td class="fielddoc"><p>None </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0d83f7d7d27ced4fbc071540f942cbdda05cc676a0d88c9c69de0115e81f57837"></a>XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_RISING_EDGE&#160;</td><td class="fielddoc"><p>Rising Edge of the input signal generates event trigger </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0d83f7d7d27ced4fbc071540f942cbddabfdb31ec01eba65cf4dfea93ea6e8758"></a>XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_FALLING_EDGE&#160;</td><td class="fielddoc"><p>Falling Edge of the input signal generates event trigger </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0d83f7d7d27ced4fbc071540f942cbddad73e4189505de1509082db746c103407"></a>XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_DUAL_EDGE&#160;</td><td class="fielddoc"><p>Both Rising and Falling edges cause an event trigger </p>
</td></tr>
</table>

</div>
</div>
<a id="gac1f2e1821e948b519f665a3b75fde3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1f2e1821e948b519f665a3b75fde3a3">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_EVENT_FILTER_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#gac1f2e1821e948b519f665a3b75fde3a3">XMC_CCU4_SLICE_EVENT_FILTER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Low pass filter Configuration. The External Event input should be stable for a selected number of clock cycles. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac1f2e1821e948b519f665a3b75fde3a3a6d6eb4e612801d52b70d2a731ff2b736"></a>XMC_CCU4_SLICE_EVENT_FILTER_DISABLED&#160;</td><td class="fielddoc"><p>No Low Pass Filter </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac1f2e1821e948b519f665a3b75fde3a3acf095d1aead6a63fbf4247737d8c0562"></a>XMC_CCU4_SLICE_EVENT_FILTER_3_CYCLES&#160;</td><td class="fielddoc"><p>3 clock cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac1f2e1821e948b519f665a3b75fde3a3a9925034cd9be0dd89976e159936e9813"></a>XMC_CCU4_SLICE_EVENT_FILTER_5_CYCLES&#160;</td><td class="fielddoc"><p>5 clock cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac1f2e1821e948b519f665a3b75fde3a3a3e3fb15c00232316d09a3ca1b0554674"></a>XMC_CCU4_SLICE_EVENT_FILTER_7_CYCLES&#160;</td><td class="fielddoc"><p>7 clock cycles </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6885762c605583d15f280d371e08b8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6885762c605583d15f280d371e08b8b0">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga6885762c605583d15f280d371e08b8b0">XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>External Event trigger criteria - Level sensitivity </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6885762c605583d15f280d371e08b8b0a0b176aa26e1c8251e5ea3599e34bc337"></a>XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH&#160;</td><td class="fielddoc"><p>Level sensitive functions react to a high signal level </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6885762c605583d15f280d371e08b8b0a1aaf8e9547536e171d18608b801ac967"></a>XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW&#160;</td><td class="fielddoc"><p>Level sensitive functions react to a low signal level </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6885762c605583d15f280d371e08b8b0ac06667a1122fa8c657543cb6ee35c4ba"></a>XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_COUNT_UP_ON_LOW&#160;</td><td class="fielddoc"><p>Timer counts up, during Low state of the control signal </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6885762c605583d15f280d371e08b8b0a9d1921bbe3295a0e1a71ec5d2d3fb46d"></a>XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_COUNT_UP_ON_HIGH&#160;</td><td class="fielddoc"><p>Timer counts up, during High state of the control signal </p>
</td></tr>
</table>

</div>
</div>
<a id="gacc266caa550eca30994d968fa3b82b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc266caa550eca30994d968fa3b82b94">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_EVENT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>External Event list </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacc266caa550eca30994d968fa3b82b94afc62ff96861da446ea03c170174cd3dd"></a>XMC_CCU4_SLICE_EVENT_NONE&#160;</td><td class="fielddoc"><p>None </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacc266caa550eca30994d968fa3b82b94a266ebde2f56d765d2063e2a9a5ad13ab"></a>XMC_CCU4_SLICE_EVENT_0&#160;</td><td class="fielddoc"><p>Event-0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacc266caa550eca30994d968fa3b82b94a09e79302a201b7369b0e87ff98759ff0"></a>XMC_CCU4_SLICE_EVENT_1&#160;</td><td class="fielddoc"><p>Event-1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacc266caa550eca30994d968fa3b82b94a9bbb89139959f97e28f497fb57a870b0"></a>XMC_CCU4_SLICE_EVENT_2&#160;</td><td class="fielddoc"><p>Event-2 </p>
</td></tr>
</table>

</div>
</div>
<a id="gac60bd4b37c3c5d5d0e2401d769c51d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac60bd4b37c3c5d5d0e2401d769c51d28">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_FUNCTION_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#gac60bd4b37c3c5d5d0e2401d769c51d28">XMC_CCU4_SLICE_FUNCTION_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>External Function list </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac60bd4b37c3c5d5d0e2401d769c51d28afe690c6006b55d1b3228a106bfc65cad"></a>XMC_CCU4_SLICE_FUNCTION_START&#160;</td><td class="fielddoc"><p>Start function </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac60bd4b37c3c5d5d0e2401d769c51d28af6cb3555bf927665b90feee075ee23c9"></a>XMC_CCU4_SLICE_FUNCTION_STOP&#160;</td><td class="fielddoc"><p>Stop function </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac60bd4b37c3c5d5d0e2401d769c51d28aa25bfc04b6982b1ef51a818ca23b0e39"></a>XMC_CCU4_SLICE_FUNCTION_CAPTURE_EVENT0&#160;</td><td class="fielddoc"><p>Capture Event-0 function, CCycapt0 signal is used for event generation </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac60bd4b37c3c5d5d0e2401d769c51d28a3738408500da28c154550454c64d5f32"></a>XMC_CCU4_SLICE_FUNCTION_CAPTURE_EVENT1&#160;</td><td class="fielddoc"><p>Capture Event-1 function, CCycapt1 signal is used for event generation </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac60bd4b37c3c5d5d0e2401d769c51d28a5cdc1037f4c88e017720d3c1b6512803"></a>XMC_CCU4_SLICE_FUNCTION_GATING&#160;</td><td class="fielddoc"><p>Gating function </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac60bd4b37c3c5d5d0e2401d769c51d28a16d7d785730ccb9529fa47bf6398c36d"></a>XMC_CCU4_SLICE_FUNCTION_DIRECTION&#160;</td><td class="fielddoc"><p>Direction function </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac60bd4b37c3c5d5d0e2401d769c51d28a178650c8b1bdbd8e8c8988906431b326"></a>XMC_CCU4_SLICE_FUNCTION_LOAD&#160;</td><td class="fielddoc"><p>Load function </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac60bd4b37c3c5d5d0e2401d769c51d28a1468e37099c197b5306576c87c8f80d7"></a>XMC_CCU4_SLICE_FUNCTION_COUNT&#160;</td><td class="fielddoc"><p>Counting function </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac60bd4b37c3c5d5d0e2401d769c51d28ac0176be221201d76c061546f5db11c0a"></a>XMC_CCU4_SLICE_FUNCTION_OVERRIDE&#160;</td><td class="fielddoc"><p>Override function </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac60bd4b37c3c5d5d0e2401d769c51d28a7a4e2d332e64a114f0c846f765d74813"></a>XMC_CCU4_SLICE_FUNCTION_MODULATION&#160;</td><td class="fielddoc"><p>Modulation function </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac60bd4b37c3c5d5d0e2401d769c51d28adbe73766f6842ed2f2c8f4cf05f78d10"></a>XMC_CCU4_SLICE_FUNCTION_TRAP&#160;</td><td class="fielddoc"><p>Trap function </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9b6b22c75755089c6c4038de4a5d213c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b6b22c75755089c6c4038de4a5d213c">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_IRQ_ID_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga9b6b22c75755089c6c4038de4a5d213c">XMC_CCU4_SLICE_IRQ_ID_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Available Interrupt Event Ids </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9b6b22c75755089c6c4038de4a5d213ca1110754891260f416e50d1ad2bb30930"></a>XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH&#160;</td><td class="fielddoc"><p>Period match counting up </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9b6b22c75755089c6c4038de4a5d213ca615bf994e6e5f1b13ababdd84616904f"></a>XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH&#160;</td><td class="fielddoc"><p>Period match -&gt; One match counting down </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9b6b22c75755089c6c4038de4a5d213ca1195f29e18054e36acb8a3ec18bbd238"></a>XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP&#160;</td><td class="fielddoc"><p>Compare match counting up </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9b6b22c75755089c6c4038de4a5d213ca2eb52479fe0ae263fe317b1743e50608"></a>XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN&#160;</td><td class="fielddoc"><p>Compare match counting down </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9b6b22c75755089c6c4038de4a5d213cacc10ec1487839dcdd54b9dbd9466b00e"></a>XMC_CCU4_SLICE_IRQ_ID_EVENT0&#160;</td><td class="fielddoc"><p>Event-0 occurrence </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9b6b22c75755089c6c4038de4a5d213cac2fe4d6206f325e8ff4dff7099e5ab0b"></a>XMC_CCU4_SLICE_IRQ_ID_EVENT1&#160;</td><td class="fielddoc"><p>Event-1 occurrence </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9b6b22c75755089c6c4038de4a5d213ca98d2fb52e2a0891b483e14fd0b821604"></a>XMC_CCU4_SLICE_IRQ_ID_EVENT2&#160;</td><td class="fielddoc"><p>Event-2 occurrence </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9b6b22c75755089c6c4038de4a5d213cace11d182e6f743f723d70077f588801a"></a>XMC_CCU4_SLICE_IRQ_ID_TRAP&#160;</td><td class="fielddoc"><p>Trap occurrence </p>
</td></tr>
</table>

</div>
</div>
<a id="gace3b8480c5644319f7c266b67b3aa07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace3b8480c5644319f7c266b67b3aa07b">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_MASK_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#gace3b8480c5644319f7c266b67b3aa07b">XMC_CCU4_SLICE_MASK_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to create Mask needed for Multi-channel Shadow transfer enable/disable </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggace3b8480c5644319f7c266b67b3aa07baaedf4ef58f5d086c994756b77d4c8b19"></a>XMC_CCU4_SLICE_MASK_SLICE_0&#160;</td><td class="fielddoc"><p>SLICE-0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggace3b8480c5644319f7c266b67b3aa07bac585e780ceca6c8629e5e73af024c3b6"></a>XMC_CCU4_SLICE_MASK_SLICE_1&#160;</td><td class="fielddoc"><p>SLICE-1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggace3b8480c5644319f7c266b67b3aa07ba137ee059dc23e97ce2040b97b9b98d53"></a>XMC_CCU4_SLICE_MASK_SLICE_2&#160;</td><td class="fielddoc"><p>SLICE-2 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggace3b8480c5644319f7c266b67b3aa07bae1c3588c1a342901461e591c685e5e11"></a>XMC_CCU4_SLICE_MASK_SLICE_3&#160;</td><td class="fielddoc"><p>SLICE-3 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1cdf6b35dbf21bc9ffd767cf8df77615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cdf6b35dbf21bc9ffd767cf8df77615">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_MCMS_ACTION_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga1cdf6b35dbf21bc9ffd767cf8df77615">XMC_CCU4_SLICE_MCMS_ACTION_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multi Channel Shadow transfer request configuration options </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1cdf6b35dbf21bc9ffd767cf8df77615a07f35a295b4b3b9432cdd03450185d8e"></a>XMC_CCU4_SLICE_MCMS_ACTION_TRANSFER_PR_CR&#160;</td><td class="fielddoc"><p>Transfer Compare and Period Shadow register values to the actual registers upon MCS xfer request </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1cdf6b35dbf21bc9ffd767cf8df77615af0335adc39165b7a0427260db33f0208"></a>XMC_CCU4_SLICE_MCMS_ACTION_TRANSFER_PR_CR_PCMP&#160;</td><td class="fielddoc"><p>Transfer Compare, Period and Prescaler Compare Shadow register values to the actual registers upon MCS xfer request </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1cdf6b35dbf21bc9ffd767cf8df77615a07778edd210fcdd0fe458a3b87ba45b3"></a>XMC_CCU4_SLICE_MCMS_ACTION_TRANSFER_PR_CR_PCMP_DIT&#160;</td><td class="fielddoc"><p>Transfer Compare, Period ,Prescaler Compare and Dither Compare register values to the actual registers upon MCS xfer request </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9667e43e2a54209c309f767354a0af8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9667e43e2a54209c309f767354a0af8e">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga9667e43e2a54209c309f767354a0af8e">XMC_CCU4_SLICE_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operational modes of CCU4 slice </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9667e43e2a54209c309f767354a0af8eae2a0b1462e62ea6c1de6e2cfb1ab9a4b"></a>XMC_CCU4_SLICE_MODE_COMPARE&#160;</td><td class="fielddoc"><p>slice(CC4y) operates in Compare Mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9667e43e2a54209c309f767354a0af8ea0d70c96f084872d0db5b8dd34c6384d1"></a>XMC_CCU4_SLICE_MODE_CAPTURE&#160;</td><td class="fielddoc"><p>slice(CC4y) operates in Capture Mode </p>
</td></tr>
</table>

</div>
</div>
<a id="gaba1abc67da718dd4dd0df6054aeda354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba1abc67da718dd4dd0df6054aeda354">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_MODULATION_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#gaba1abc67da718dd4dd0df6054aeda354">XMC_CCU4_SLICE_MODULATION_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulation of timer output signals </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaba1abc67da718dd4dd0df6054aeda354ad37a1aa22cf58f318f0a6b7319ee5f3a"></a>XMC_CCU4_SLICE_MODULATION_MODE_CLEAR_ST_OUT&#160;</td><td class="fielddoc"><p>Clear ST and OUT signals </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba1abc67da718dd4dd0df6054aeda354a4eb2b8e39a4ad266febeba6f6d02ed89"></a>XMC_CCU4_SLICE_MODULATION_MODE_CLEAR_OUT&#160;</td><td class="fielddoc"><p>Clear only the OUT signal </p>
</td></tr>
</table>

</div>
</div>
<a id="ga99a221425b50cb24f3358c905c92f105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99a221425b50cb24f3358c905c92f105">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_MULTI_IRQ_ID_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga99a221425b50cb24f3358c905c92f105">XMC_CCU4_SLICE_MULTI_IRQ_ID_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Available Interrupt Event Ids, which is added to support multi event APIs </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga99a221425b50cb24f3358c905c92f105abef36d3c3a24427fb8f031db28e9baac"></a>XMC_CCU4_SLICE_MULTI_IRQ_ID_PERIOD_MATCH&#160;</td><td class="fielddoc"><p>Period match counting up </p>
</td></tr>
<tr><td class="fieldname"><a id="gga99a221425b50cb24f3358c905c92f105a68eb8b00bdfc1336c66d92104fde9af1"></a>XMC_CCU4_SLICE_MULTI_IRQ_ID_ONE_MATCH&#160;</td><td class="fielddoc"><p>Period match -&gt; One match counting down </p>
</td></tr>
<tr><td class="fieldname"><a id="gga99a221425b50cb24f3358c905c92f105a351a2552a33a0f3163605a19e30f7a56"></a>XMC_CCU4_SLICE_MULTI_IRQ_ID_COMPARE_MATCH_UP&#160;</td><td class="fielddoc"><p>Compare match counting up </p>
</td></tr>
<tr><td class="fieldname"><a id="gga99a221425b50cb24f3358c905c92f105acd2dc3adf095991bf1c374bdcdd85a92"></a>XMC_CCU4_SLICE_MULTI_IRQ_ID_COMPARE_MATCH_DOWN&#160;</td><td class="fielddoc"><p>Compare match counting down </p>
</td></tr>
<tr><td class="fieldname"><a id="gga99a221425b50cb24f3358c905c92f105a4dae63fc87fb65f4a027402c1ec9adfe"></a>XMC_CCU4_SLICE_MULTI_IRQ_ID_EVENT0&#160;</td><td class="fielddoc"><p>Event-0 occurrence </p>
</td></tr>
<tr><td class="fieldname"><a id="gga99a221425b50cb24f3358c905c92f105ae8fb1889eed2861dd5ccdc2c3556ee56"></a>XMC_CCU4_SLICE_MULTI_IRQ_ID_EVENT1&#160;</td><td class="fielddoc"><p>Event-1 occurrence </p>
</td></tr>
<tr><td class="fieldname"><a id="gga99a221425b50cb24f3358c905c92f105a8915bb2051d30faa27e400170865977f"></a>XMC_CCU4_SLICE_MULTI_IRQ_ID_EVENT2&#160;</td><td class="fielddoc"><p>Event-2 occurrence </p>
</td></tr>
</table>

</div>
</div>
<a id="gad1e13100aef87f3fdbffcd561b1d7e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1e13100aef87f3fdbffcd561b1d7e57">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_OUTPUT_PASSIVE_LEVEL_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#gad1e13100aef87f3fdbffcd561b1d7e57">XMC_CCU4_SLICE_OUTPUT_PASSIVE_LEVEL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timer output passive level </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad1e13100aef87f3fdbffcd561b1d7e57a4a4c2f6167364519a64a4357390d8791"></a>XMC_CCU4_SLICE_OUTPUT_PASSIVE_LEVEL_LOW&#160;</td><td class="fielddoc"><p>Passive level = Low </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad1e13100aef87f3fdbffcd561b1d7e57a165b8c77d8101587c31ad8f01fd14cb1"></a>XMC_CCU4_SLICE_OUTPUT_PASSIVE_LEVEL_HIGH&#160;</td><td class="fielddoc"><p>Passive level = High </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1dcda6886b599a8260e6f9934dd74dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dcda6886b599a8260e6f9934dd74dc1">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_PRESCALER_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga1dcda6886b599a8260e6f9934dd74dc1">XMC_CCU4_SLICE_PRESCALER_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prescaler mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1dcda6886b599a8260e6f9934dd74dc1ae811f6f9afca2fa27136947ed5f2ea5b"></a>XMC_CCU4_SLICE_PRESCALER_MODE_NORMAL&#160;</td><td class="fielddoc"><p>Fixed division of module clock </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1dcda6886b599a8260e6f9934dd74dc1a5c26f6a0bfdc053250da48a6e205cce6"></a>XMC_CCU4_SLICE_PRESCALER_MODE_FLOAT&#160;</td><td class="fielddoc"><p>Floating divider. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga871bce3beb610d5e16b083c68381a60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga871bce3beb610d5e16b083c68381a60f">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_PRESCALER_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga871bce3beb610d5e16b083c68381a60f">XMC_CCU4_SLICE_PRESCALER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timer clock Divider </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga871bce3beb610d5e16b083c68381a60fa21730c3c85876b200cfe3c53fbefb409"></a>XMC_CCU4_SLICE_PRESCALER_1&#160;</td><td class="fielddoc"><p>Slice Clock = fccu4 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga871bce3beb610d5e16b083c68381a60fa1274e6b5c52db963d9160ab3855dcca5"></a>XMC_CCU4_SLICE_PRESCALER_2&#160;</td><td class="fielddoc"><p>Slice Clock = fccu4/2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga871bce3beb610d5e16b083c68381a60faa90473df8e937f3605698d4d4e7a780b"></a>XMC_CCU4_SLICE_PRESCALER_4&#160;</td><td class="fielddoc"><p>Slice Clock = fccu4/4 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga871bce3beb610d5e16b083c68381a60fa86d1d3241d91aea49d5b342375eb88e4"></a>XMC_CCU4_SLICE_PRESCALER_8&#160;</td><td class="fielddoc"><p>Slice Clock = fccu4/8 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga871bce3beb610d5e16b083c68381a60fa9b791c72ca12272d96b6852063d4dcea"></a>XMC_CCU4_SLICE_PRESCALER_16&#160;</td><td class="fielddoc"><p>Slice Clock = fccu4/16 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga871bce3beb610d5e16b083c68381a60fa4c7e8d216ba1848e14f7c353de015620"></a>XMC_CCU4_SLICE_PRESCALER_32&#160;</td><td class="fielddoc"><p>Slice Clock = fccu4/32 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga871bce3beb610d5e16b083c68381a60fa420a4d436ffe32d312f0bd9a6e25060a"></a>XMC_CCU4_SLICE_PRESCALER_64&#160;</td><td class="fielddoc"><p>Slice Clock = fccu4/64 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga871bce3beb610d5e16b083c68381a60fa8ed8c701fe46730b47375a1b94e8c993"></a>XMC_CCU4_SLICE_PRESCALER_128&#160;</td><td class="fielddoc"><p>Slice Clock = fccu4/128 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga871bce3beb610d5e16b083c68381a60fa040bfdb62c0c148163a39e48251a7e3f"></a>XMC_CCU4_SLICE_PRESCALER_256&#160;</td><td class="fielddoc"><p>Slice Clock = fccu4/256 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga871bce3beb610d5e16b083c68381a60fa1f2bdbb25d2177a9bc2d5b816b11db37"></a>XMC_CCU4_SLICE_PRESCALER_512&#160;</td><td class="fielddoc"><p>Slice Clock = fccu4/512 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga871bce3beb610d5e16b083c68381a60fac4d910af417ec48ddefb40d600b39549"></a>XMC_CCU4_SLICE_PRESCALER_1024&#160;</td><td class="fielddoc"><p>Slice Clock = fccu4/1024 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga871bce3beb610d5e16b083c68381a60faf08263ed3302cae17bad9745d3a0618e"></a>XMC_CCU4_SLICE_PRESCALER_2048&#160;</td><td class="fielddoc"><p>Slice Clock = fccu4/2048 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga871bce3beb610d5e16b083c68381a60fa503205ae411d32a5a966caf019b4e817"></a>XMC_CCU4_SLICE_PRESCALER_4096&#160;</td><td class="fielddoc"><p>Slice Clock = fccu4/4096 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga871bce3beb610d5e16b083c68381a60faa5635168ed9b7ceb25fab5887e97c430"></a>XMC_CCU4_SLICE_PRESCALER_8192&#160;</td><td class="fielddoc"><p>Slice Clock = fccu4/8192 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga871bce3beb610d5e16b083c68381a60fa6987633000fa62b874eecf6882edb3d4"></a>XMC_CCU4_SLICE_PRESCALER_16384&#160;</td><td class="fielddoc"><p>Slice Clock = fccu4/16384 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga871bce3beb610d5e16b083c68381a60fafc45b1530f6f2264995bb7b9703b4af3"></a>XMC_CCU4_SLICE_PRESCALER_32768&#160;</td><td class="fielddoc"><p>Slice Clock = fccu4/32768 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6b7d3d96e6ba78dd55ca0850379ebf9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b7d3d96e6ba78dd55ca0850379ebf9d">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_SHADOW_TRANSFER_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga6b7d3d96e6ba78dd55ca0850379ebf9d">XMC_CCU4_SLICE_SHADOW_TRANSFER_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Slice shadow transfer mode options. </p><dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6b7d3d96e6ba78dd55ca0850379ebf9dacb0b5f0078d5039dd05903cd3440332a"></a>XMC_CCU4_SLICE_SHADOW_TRANSFER_MODE_IN_PERIOD_MATCH_AND_ONE_MATCH&#160;</td><td class="fielddoc"><p>Shadow transfer is done in Period Match and One match. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6b7d3d96e6ba78dd55ca0850379ebf9da3e58f0c4e9d39e1a7270a9acec6215cf"></a>XMC_CCU4_SLICE_SHADOW_TRANSFER_MODE_ONLY_IN_PERIOD_MATCH&#160;</td><td class="fielddoc"><p>Shadow transfer is done only in Period Match. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6b7d3d96e6ba78dd55ca0850379ebf9da1471dea0a4bf1f5043e36068521ed5e1"></a>XMC_CCU4_SLICE_SHADOW_TRANSFER_MODE_ONLY_IN_ONE_MATCH&#160;</td><td class="fielddoc"><p>Shadow transfer is done only in One Match. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9de58e90257a0c33532f376c7c5f959e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9de58e90257a0c33532f376c7c5f959e">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_SR_ID_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga9de58e90257a0c33532f376c7c5f959e">XMC_CCU4_SLICE_SR_ID_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Service Request Lines for CCU4. Event are mapped to these SR lines and these are used to generate the interrupt. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9de58e90257a0c33532f376c7c5f959ea606c95b58b5d6d5dbe49d3d5ef1ddcca"></a>XMC_CCU4_SLICE_SR_ID_0&#160;</td><td class="fielddoc"><p>Service Request Line-0 selected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9de58e90257a0c33532f376c7c5f959ea8c6eb4a0bd77ca1d2ee974c7ce2c28b1"></a>XMC_CCU4_SLICE_SR_ID_1&#160;</td><td class="fielddoc"><p>Service Request Line-1 selected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9de58e90257a0c33532f376c7c5f959ea49cefefb272abca4ba8a6c9f223c2c20"></a>XMC_CCU4_SLICE_SR_ID_2&#160;</td><td class="fielddoc"><p>Service Request Line-2 selected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9de58e90257a0c33532f376c7c5f959eac7d83257e819a2acd2b35b0e5f856897"></a>XMC_CCU4_SLICE_SR_ID_3&#160;</td><td class="fielddoc"><p>Service Request Line-3 selected </p>
</td></tr>
</table>

</div>
</div>
<a id="ga665528c9d6bedf104384b20797e892c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga665528c9d6bedf104384b20797e892c3">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_START_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga665528c9d6bedf104384b20797e892c3">XMC_CCU4_SLICE_START_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Actions that can be performed upon detection of an external Timer START event </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga665528c9d6bedf104384b20797e892c3ad412d8efd6c8145f9f39f048e4971a01"></a>XMC_CCU4_SLICE_START_MODE_TIMER_START&#160;</td><td class="fielddoc"><p>Start the timer from the current count of TIMER register </p>
</td></tr>
<tr><td class="fieldname"><a id="gga665528c9d6bedf104384b20797e892c3ae2bfe2856021d15cf1509a4d4cb56297"></a>XMC_CCU4_SLICE_START_MODE_TIMER_START_CLEAR&#160;</td><td class="fielddoc"><p>Clears the TIMER register and start the timer </p>
</td></tr>
</table>

</div>
</div>
<a id="ga5bd133ab5643ed217b548ce94f6bacc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bd133ab5643ed217b548ce94f6bacc6">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_STATUS_BIT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga5bd133ab5643ed217b548ce94f6bacc6">XMC_CCU4_SLICE_STATUS_BIT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CCU4 slice status bit </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5bd133ab5643ed217b548ce94f6bacc6acc767d7c8bbded08e87e3cc5232eb625"></a>XMC_CCU4_SLICE_STATUS_BIT_PASSIVE&#160;</td><td class="fielddoc"><p>Passive </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5bd133ab5643ed217b548ce94f6bacc6a99abff0fd6a7cef4624f571b047c5f6f"></a>XMC_CCU4_SLICE_STATUS_BIT_ACTIVE&#160;</td><td class="fielddoc"><p>Active </p>
</td></tr>
</table>

</div>
</div>
<a id="ga39bc5ede3f6f7d5e44dbaf01f0e3a98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39bc5ede3f6f7d5e44dbaf01f0e3a98d">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_TIMER_CLEAR_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga39bc5ede3f6f7d5e44dbaf01f0e3a98d">XMC_CCU4_SLICE_TIMER_CLEAR_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timer clear on capture </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga39bc5ede3f6f7d5e44dbaf01f0e3a98da34cf9539f3e113d0308fde8b2b7e7ea3"></a>XMC_CCU4_SLICE_TIMER_CLEAR_MODE_NEVER&#160;</td><td class="fielddoc"><p>Never clear the timer on any capture event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga39bc5ede3f6f7d5e44dbaf01f0e3a98daecb208a201233a895998122372644f76"></a>XMC_CCU4_SLICE_TIMER_CLEAR_MODE_CAP_HIGH&#160;</td><td class="fielddoc"><p>Clear only when timer value has been captured in C3V and C2V </p>
</td></tr>
<tr><td class="fieldname"><a id="gga39bc5ede3f6f7d5e44dbaf01f0e3a98da74bcde097f72a785eb0ddc1d95c08e3a"></a>XMC_CCU4_SLICE_TIMER_CLEAR_MODE_CAP_LOW&#160;</td><td class="fielddoc"><p>Clear only when timer value has been captured in C1V and C0V </p>
</td></tr>
<tr><td class="fieldname"><a id="gga39bc5ede3f6f7d5e44dbaf01f0e3a98daae8593b42bd161d754c42113e2312d54"></a>XMC_CCU4_SLICE_TIMER_CLEAR_MODE_ALWAYS&#160;</td><td class="fielddoc"><p>Always clear the timer upon detection of any capture event </p>
</td></tr>
</table>

</div>
</div>
<a id="gacbf19766ba6532d4b09ac3ac1cd0d571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbf19766ba6532d4b09ac3ac1cd0d571">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_TIMER_COUNT_DIR_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#gacbf19766ba6532d4b09ac3ac1cd0d571">XMC_CCU4_SLICE_TIMER_COUNT_DIR_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timer counting direction for the CCU4 slice </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacbf19766ba6532d4b09ac3ac1cd0d571afb257cb392cadc536c43f78e36d31dcf"></a>XMC_CCU4_SLICE_TIMER_COUNT_DIR_UP&#160;</td><td class="fielddoc"><p>Counting up </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacbf19766ba6532d4b09ac3ac1cd0d571afaf67b9b034f8168444940544144f796"></a>XMC_CCU4_SLICE_TIMER_COUNT_DIR_DOWN&#160;</td><td class="fielddoc"><p>Counting down </p>
</td></tr>
</table>

</div>
</div>
<a id="ga488780142d4d7da249cbb6e2c16ec512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga488780142d4d7da249cbb6e2c16ec512">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_TIMER_COUNT_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga488780142d4d7da249cbb6e2c16ec512">XMC_CCU4_SLICE_TIMER_COUNT_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timer counting modes for the slice </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga488780142d4d7da249cbb6e2c16ec512a4318f65933cfd2f8348b14a9527a54cf"></a>XMC_CCU4_SLICE_TIMER_COUNT_MODE_EA&#160;</td><td class="fielddoc"><p>Edge Aligned Mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga488780142d4d7da249cbb6e2c16ec512a873c92d1c37a0f7b040a5d2b5dc0231a"></a>XMC_CCU4_SLICE_TIMER_COUNT_MODE_CA&#160;</td><td class="fielddoc"><p>Center Aligned Mode </p>
</td></tr>
</table>

</div>
</div>
<a id="ga85c8c78c8c4ec52eae3d4654aa37ad9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85c8c78c8c4ec52eae3d4654aa37ad9d">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_TIMER_REPEAT_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga85c8c78c8c4ec52eae3d4654aa37ad9d">XMC_CCU4_SLICE_TIMER_REPEAT_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timer repetition mode for the slice </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga85c8c78c8c4ec52eae3d4654aa37ad9da8d51f93f5e31e8f72e4497a409bc2bcc"></a>XMC_CCU4_SLICE_TIMER_REPEAT_MODE_REPEAT&#160;</td><td class="fielddoc"><p>Repetitive mode: continuous mode of operation </p>
</td></tr>
<tr><td class="fieldname"><a id="gga85c8c78c8c4ec52eae3d4654aa37ad9da4de4b49a7511bbef001ee903a680bed6"></a>XMC_CCU4_SLICE_TIMER_REPEAT_MODE_SINGLE&#160;</td><td class="fielddoc"><p>Single shot mode: Once a Period match/One match occurs timer goes to idle state </p>
</td></tr>
</table>

</div>
</div>
<a id="gafc3c6b390f18574d954473174a595eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc3c6b390f18574d954473174a595eb2">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_TRAP_EXIT_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#gafc3c6b390f18574d954473174a595eb2">XMC_CCU4_SLICE_TRAP_EXIT_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trap exit mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafc3c6b390f18574d954473174a595eb2ad0e74edf598f2c828a938de5a2461112"></a>XMC_CCU4_SLICE_TRAP_EXIT_MODE_AUTOMATIC&#160;</td><td class="fielddoc"><p>Clear trap state as soon as the trap signal is de-asserted </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafc3c6b390f18574d954473174a595eb2a100606bfa8b7b7c11deef92dceb07da0"></a>XMC_CCU4_SLICE_TRAP_EXIT_MODE_SW&#160;</td><td class="fielddoc"><p>Clear only when acknowledged by software </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1cf1dcb4c712c711441f1ee42a8577bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cf1dcb4c712c711441f1ee42a8577bd">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_WRITE_INTO_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#ga1cf1dcb4c712c711441f1ee42a8577bd">XMC_CCU4_SLICE_WRITE_INTO_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Immediate write into configuration register </p><dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1cf1dcb4c712c711441f1ee42a8577bda793268c55ee55c93bc0c50fee9a17960"></a>XMC_CCU4_SLICE_WRITE_INTO_PERIOD_CONFIGURATION&#160;</td><td class="fielddoc"><p>Immediate or Coherent Write into Period Configuration </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1cf1dcb4c712c711441f1ee42a8577bdaf27bb047766d40a81e5bcea978070b78"></a>XMC_CCU4_SLICE_WRITE_INTO_COMPARE_CONFIGURATION&#160;</td><td class="fielddoc"><p>Immediate or Coherent Write into Compare Configuration </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1cf1dcb4c712c711441f1ee42a8577bda3e7e6d8f1bfdd6abf7854152f2b70c90"></a>XMC_CCU4_SLICE_WRITE_INTO_PASSIVE_LEVEL_CONFIGURATION&#160;</td><td class="fielddoc"><p>Immediate or Coherent Write into Passive Level Configuration </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1cf1dcb4c712c711441f1ee42a8577bda2027f4df492329f65376f6ffb220dc23"></a>XMC_CCU4_SLICE_WRITE_INTO_DITHER_VALUE_CONFIGURATION&#160;</td><td class="fielddoc"><p>Immediate or Coherent Write into Dither Value Configuration </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1cf1dcb4c712c711441f1ee42a8577bda7c8cbc8cb315c1caf2c23a1ca69c2bfc"></a>XMC_CCU4_SLICE_WRITE_INTO_FLOATING_PRESCALER_VALUE_CONFIGURATION&#160;</td><td class="fielddoc"><p>Immediate or Coherent Write into Floating Prescaler Value Configuration </p>
</td></tr>
</table>

</div>
</div>
<a id="gac0f35f7b62570cbbd9ff102fea356b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0f35f7b62570cbbd9ff102fea356b62">&#9670;&nbsp;</a></span>XMC_CCU4_STATUS_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#gac0f35f7b62570cbbd9ff102fea356b62">XMC_CCU4_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return Value of an API </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac0f35f7b62570cbbd9ff102fea356b62a2cb66ee3128b8de1632f4c92bf9a87be"></a>XMC_CCU4_STATUS_OK&#160;</td><td class="fielddoc"><p>API fulfils request </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac0f35f7b62570cbbd9ff102fea356b62a15005b0626b30abc2f37d1b3d1047bc3"></a>XMC_CCU4_STATUS_ERROR&#160;</td><td class="fielddoc"><p>API cannot fulfil the request </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac0f35f7b62570cbbd9ff102fea356b62aea3f12395fc07e2ce14d8d263ce7d2be"></a>XMC_CCU4_STATUS_RUNNING&#160;</td><td class="fielddoc"><p>The timer slice is currently running </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac0f35f7b62570cbbd9ff102fea356b62a0f2125e8f28d513ee65f60939d1aefe0"></a>XMC_CCU4_STATUS_IDLE&#160;</td><td class="fielddoc"><p>The timer slice is currently idle </p>
</td></tr>
</table>

</div>
</div>
<a id="gac29c624b192d2b963e29389ae01a707a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac29c624b192d2b963e29389ae01a707a">&#9670;&nbsp;</a></span>XMC_CCU4_SUSPEND_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_c_u4.html#gac29c624b192d2b963e29389ae01a707a">XMC_CCU4_SUSPEND_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects suspend mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac29c624b192d2b963e29389ae01a707aa809f16e07fb7d70ff37dfd05c3382c2a"></a>XMC_CCU4_SUSPEND_MODE_IGNORE&#160;</td><td class="fielddoc"><p>Suspend request ignored. The module never enters in suspend </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac29c624b192d2b963e29389ae01a707aaeb7d1ccc41651c6fdd86a2870149521e"></a>XMC_CCU4_SUSPEND_MODE_STOPS_INMEDIATELLY&#160;</td><td class="fielddoc"><p>Stops all the running slices immediately. Safe stop is not applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac29c624b192d2b963e29389ae01a707aa9d60ab20eea6e5d7f6d9a3f484533c32"></a>XMC_CCU4_SUSPEND_MODE_SAFE_STOP&#160;</td><td class="fielddoc"><p>Stops the block immediately and clamps all the outputs to PASSIVE state. Safe stop is applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac29c624b192d2b963e29389ae01a707aa87fc32e07bee14bfb4fd663e0a591595"></a>XMC_CCU4_SUSPEND_MODE_WAIT_ROLL_OVER&#160;</td><td class="fielddoc"><p>Waits for the roll over of each slice to stop and clamp the slices outputs. Safe stop is applied. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga58ad9c171f730ad379f349aac4e78009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58ad9c171f730ad379f349aac4e78009">&#9670;&nbsp;</a></span>XMC_CCU4_DisableClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_DisableClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>slice_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>Constant pointer to CCU4 module </td></tr>
    <tr><td class="paramname">slice_number</td><td>Slice for which the clock should be disabled. Range: [0x0 to 0x3] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the slice timer clock, by configuring GIDLS.SS0I, GIDLS.SSS1I, GIDLS.SSS2I, GIDLS.SSS3I bits according to the selected <em>slice_number</em> .<br />
<br />
It is possible to disable clock at slice level using the module pointer. <b>slice_number</b> is used to disable the clock to a given slice of the module. Directly accessed Register is GIDLS.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga1809347868d61b8627442802601fb863">XMC_CCU4_EnableClock()</a><br />
 <a class="el" href="group___c_c_u4.html#ga636c23537ae9718af9bb3c3f66c7db4b">XMC_CCU4_EnableMultipleClocks()</a><br />
 <a class="el" href="group___c_c_u4.html#gad492e0c49bfa5b89b01d6dd5a43a1e1b">XMC_CCU4_StartPrescaler()</a><br />
 <a class="el" href="group___c_c_u4.html#gae3741bc9dc0cb9f565ade9182d73141f">XMC_CCU4_StopPrescaler()</a>. </dd></dl>

</div>
</div>
<a id="gacb7f295a4b04bd0cf79e9df8da97a954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb7f295a4b04bd0cf79e9df8da97a954">&#9670;&nbsp;</a></span>XMC_CCU4_DisableModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_DisableModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>Constant pointer to CCU4 module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Brings the CCU4 module to reset state and enables gating of the clock signal(if applicable depending on the device being selected).<br />
<br />
Invoke this API when a CCU4 module needs to be disabled completely. Any operation on the CCU4 module will have no effect after this API is called.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga71ef51e46d57bdd95563fdc0da1f44c3">XMC_CCU4_EnableModule()</a><br />
 <a class="el" href="group___c_c_u4.html#gacb7f295a4b04bd0cf79e9df8da97a954">XMC_CCU4_DisableModule()</a>. </dd></dl>

</div>
</div>
<a id="ga1809347868d61b8627442802601fb863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1809347868d61b8627442802601fb863">&#9670;&nbsp;</a></span>XMC_CCU4_EnableClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_EnableClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>slice_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>Constant pointer to CCU4 module </td></tr>
    <tr><td class="paramname">slice_number</td><td>Slice for which the clock should be Enabled. Range: [0x0 to 0x3] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the slice timer clock, by configuring GIDLC.CS0I, GIDLC.CS1I, GIDLC.CS2I, GIDLC.CS3I bits according to the selected <em>slice_number</em>.<br />
<br />
 It is possible to enable/disable clock at slice level. This uses the <b>slice_number</b> to indicate the slice whose clock needs to be enabled.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga58ad9c171f730ad379f349aac4e78009">XMC_CCU4_DisableClock()</a><br />
 <a class="el" href="group___c_c_u4.html#ga636c23537ae9718af9bb3c3f66c7db4b">XMC_CCU4_EnableMultipleClocks()</a><br />
 <a class="el" href="group___c_c_u4.html#gad492e0c49bfa5b89b01d6dd5a43a1e1b">XMC_CCU4_StartPrescaler()</a><br />
 <a class="el" href="group___c_c_u4.html#gae3741bc9dc0cb9f565ade9182d73141f">XMC_CCU4_StopPrescaler()</a>. </dd></dl>

</div>
</div>
<a id="ga71ef51e46d57bdd95563fdc0da1f44c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71ef51e46d57bdd95563fdc0da1f44c3">&#9670;&nbsp;</a></span>XMC_CCU4_EnableModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_EnableModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>Constant pointer to CCU4 module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the CCU4 module and brings it to active state.<br />
<br />
Also disables the gating of the clock signal (if applicable depending on the device being selected). Invoke this API before any operations are done on the CCU4 module. Invoked from <a class="el" href="group___c_c_u4.html#ga6ab30100f7e86a8f47095282a123d071">XMC_CCU4_Init()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gaafc3f9bdcb648bf3e2cc6fdd1a597d3e">XMC_CCU4_SetModuleClock()</a><br />
 <a class="el" href="group___c_c_u4.html#gacb7f295a4b04bd0cf79e9df8da97a954">XMC_CCU4_DisableModule()</a><br />
 <a class="el" href="group___c_c_u4.html#gad492e0c49bfa5b89b01d6dd5a43a1e1b">XMC_CCU4_StartPrescaler()</a>. </dd></dl>

</div>
</div>
<a id="ga636c23537ae9718af9bb3c3f66c7db4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga636c23537ae9718af9bb3c3f66c7db4b">&#9670;&nbsp;</a></span>XMC_CCU4_EnableMultipleClocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_EnableMultipleClocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>clock_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>Constant pointer to CCU4 module </td></tr>
    <tr><td class="paramname">clock_mask</td><td>Slices whose clocks are to be enabled simultaneously. Bit location 0/1/2/3 represents slice-0/1/2/3 respectively. Range: [0x1 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables clocks of multiple slices at a time, by configuring GIDLC.CS0I, GIDLC.CS1I, GIDLC.CS2I, GIDLC.CS3I bits.<br />
<br />
Takes an input clock_mask, which determines the slices that would receive the clock. Bring them out of the idle state simultaneously.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga1809347868d61b8627442802601fb863">XMC_CCU4_EnableClock()</a><br />
 <a class="el" href="group___c_c_u4.html#ga58ad9c171f730ad379f349aac4e78009">XMC_CCU4_DisableClock()</a>. </dd></dl>

</div>
</div>
<a id="gadcfbaa660e4c008e78128b8deb4cc5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcfbaa660e4c008e78128b8deb4cc5c1">&#9670;&nbsp;</a></span>XMC_CCU4_EnableShadowTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_EnableShadowTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>shadow_transfer_msk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>Constant pointer to CCU4 module </td></tr>
    <tr><td class="paramname">shadow_transfer_msk</td><td>Shadow transfer request mask for various transfers. Use <a class="el" href="group___c_c_u4.html#ga8d2c64420abee84dccce68e68b942e67">XMC_CCU4_SHADOW_TRANSFER_t</a> enum items to create a mask of choice, using a bit wise OR operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Requests of shadow transfer for Period, Compare, Passive level, dither and prescaler, by configuring the GCSS register.<br />
<br />
The transfer from the shadow registers to the actual registers is done in the immediate next occurrence of the shadow transfer trigger after the API is called.</dd></dl>
<p>Any call to <a class="el" href="group___c_c_u4.html#ga1341abfd52a8165c7e1b5292033797ed">XMC_CCU4_SLICE_SetTimerPeriodMatch()</a><br />
 <a class="el" href="group___c_c_u4.html#ga7ae1adcaba614fa7d919221da9020a57">XMC_CCU4_SLICE_SetTimerCompareMatch()</a><br />
 <a class="el" href="group___c_c_u4.html#ga24127bd989b62814c2ba0cc876b99473">XMC_CCU4_SLICE_SetPrescaler()</a><br />
 <a class="el" href="group___c_c_u4.html#gaaaf6a6054b308d38a5d05a518d042873">XMC_CCU4_SLICE_CompareInit()</a><br />
 <a class="el" href="group___c_c_u4.html#ga0e1afff754cd0b288f3ef9e364b86092">XMC_CCU4_SLICE_CaptureInit()</a>. must be succeeded by this API. Directly accessed Register is GCSS.</p>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga38533fac543669af19de6972cd56a3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38533fac543669af19de6972cd56a3a9">&#9670;&nbsp;</a></span>XMC_CCU4_GetSliceStatusBit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_c_u4.html#ga5bd133ab5643ed217b548ce94f6bacc6">XMC_CCU4_SLICE_STATUS_BIT_t</a> XMC_CCU4_GetSliceStatusBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slice_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>Constant pointer to CCU4 module </td></tr>
    <tr><td class="paramname">slice_number</td><td>Slice for which the clock should be disabled. Range: [0x0 to 0x3] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status bit of slice passive (false) or active (true)</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns CCU4 slice status bit (passive or active) </dd></dl>

</div>
</div>
<a id="ga6ab30100f7e86a8f47095282a123d071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ab30100f7e86a8f47095282a123d071">&#9670;&nbsp;</a></span>XMC_CCU4_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga1cdf6b35dbf21bc9ffd767cf8df77615">XMC_CCU4_SLICE_MCMS_ACTION_t</a>&#160;</td>
          <td class="paramname"><em>mcs_action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>Constant pointer to CCU4 module </td></tr>
    <tr><td class="paramname">mcs_action</td><td>multi-channel shadow transfer request configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initialization of global register GCTRL.<br />
<br />
 As part of module initialization, behaviour of the module upon detection Multi-Channel Mode trigger is configured. Will also invoke the <a class="el" href="group___c_c_u4.html#ga71ef51e46d57bdd95563fdc0da1f44c3">XMC_CCU4_EnableModule()</a>. The API call would bring up the required CCU4 module and also initialize the module for the required multi-channel shadow transfer.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gaaaf6a6054b308d38a5d05a518d042873">XMC_CCU4_SLICE_CompareInit()</a><br />
 <a class="el" href="group___c_c_u4.html#ga0e1afff754cd0b288f3ef9e364b86092">XMC_CCU4_SLICE_CaptureInit()</a>. </dd></dl>

</div>
</div>
<a id="ga13b0b2fb23ac55d1fcfa41378e22e395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13b0b2fb23ac55d1fcfa41378e22e395">&#9670;&nbsp;</a></span>XMC_CCU4_IsPrescalerRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_CCU4_IsPrescalerRunning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>Constant pointer to CCU4 module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the state of the prescaler, by reading GSTAT.PRB bit.<br />
<br />
This will return true if the prescaler is running. If clock is being supplied to the slices of the module then returns as true.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gad492e0c49bfa5b89b01d6dd5a43a1e1b">XMC_CCU4_StartPrescaler()</a><br />
 <a class="el" href="group___c_c_u4.html#gae3741bc9dc0cb9f565ade9182d73141f">XMC_CCU4_StopPrescaler()</a><br />
 <a class="el" href="group___c_c_u4.html#ga1809347868d61b8627442802601fb863">XMC_CCU4_EnableClock()</a><br />
 <a class="el" href="group___c_c_u4.html#ga58ad9c171f730ad379f349aac4e78009">XMC_CCU4_DisableClock()</a>. </dd></dl>

</div>
</div>
<a id="gaafc3f9bdcb648bf3e2cc6fdd1a597d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafc3f9bdcb648bf3e2cc6fdd1a597d3e">&#9670;&nbsp;</a></span>XMC_CCU4_SetModuleClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SetModuleClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gaf5e64519972ca9ee2c9b590eba7c041b">XMC_CCU4_CLOCK_t</a>&#160;</td>
          <td class="paramname"><em>clock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>Constant pointer to CCU4 module </td></tr>
    <tr><td class="paramname">clock</td><td>Choice of input clock to the module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Selects the Module Clock by configuring GCTRL.PCIS bits.<br />
<br />
 There are 3 potential clock sources. This API helps to select the required clock source. Call to this API is valid after the <a class="el" href="group___c_c_u4.html#ga6ab30100f7e86a8f47095282a123d071">XMC_CCU4_Init()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None.<br />
 </dd></dl>

</div>
</div>
<a id="ga10d688acde3cd3ffa2067973c640f9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10d688acde3cd3ffa2067973c640f9bf">&#9670;&nbsp;</a></span>XMC_CCU4_SetMultiChannelShadowTransferMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SetMultiChannelShadowTransferMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>slice_mode_msk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>Constant pointer to CCU4 module </td></tr>
    <tr><td class="paramname">slice_mode_msk</td><td>Slices for which the configuration has to be applied. Use <a class="el" href="group___c_c_u4.html#ga9a88d5f27f3d04acf49beae187238299">XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_t</a> enum items to create a mask of choice, using a bit wise OR operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the Multi-channel shadow transfer request trigger signal either by software or hardware by configuring GCTRL.MSE0, GCTRL.MSE1, GCTRL.MSE2, and GCTRL.MSE3 based on the mask.<br />
<br />
The shadow transfer would take place either if it was requested by software or by the CCU4x.MCSS input.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga541ed12424b01306986e12e15172e175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga541ed12424b01306986e12e15172e175">&#9670;&nbsp;</a></span>XMC_CCU4_SetSuspendMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SetSuspendMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gac29c624b192d2b963e29389ae01a707a">XMC_CCU4_SUSPEND_MODE_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>Constant pointer to CCU8 module </td></tr>
    <tr><td class="paramname">mode</td><td>Selects suspend mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the entering in suspend mode for all the CCU8 slices.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga3ed073924b8580efb863070ddf20426a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ed073924b8580efb863070ddf20426a">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_Capture0Config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_Capture0Config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>Map an External event to the Capture-0 Function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the Capture-0 Function of the slice, by configuring CC4yCMC.CAP0S bit.<br />
<br />
Capture function is mapped with one of the 3 events. A CCU4 slice can be configured into capture-0 mode with the selected <b>event</b>. In this mode the CCU4 will capture the timer value into CC4yC0V and CC4yC1V.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga6417b3f8823b6c76ec44118fc9c1eeb7">XMC_CCU4_SLICE_ConfigureEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>. </dd></dl>

</div>
</div>
<a id="ga01bd8510437249b1bc33eb5cd2da7b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01bd8510437249b1bc33eb5cd2da7b0f">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_Capture1Config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_Capture1Config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>Map an External event to the Capture-1 Function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the Capture-1 Function of the slice, by configuring CC4yCMC.CAP1S bit.<br />
<br />
Capture function is mapped with one of the 3 events. A CCU4 slice can be configured into capture-1 mode with the selected <b>event</b>. In this mode the CCU4 will capture the timer value into CC4yC2V and CC4yC3V.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga6417b3f8823b6c76ec44118fc9c1eeb7">XMC_CCU4_SLICE_ConfigureEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>. </dd></dl>

</div>
</div>
<a id="ga0e1afff754cd0b288f3ef9e364b86092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e1afff754cd0b288f3ef9e364b86092">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_CaptureInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_CaptureInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___c_c_u4___s_l_i_c_e___c_a_p_t_u_r_e___c_o_n_f_i_g__t.html">XMC_CCU4_SLICE_CAPTURE_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>capture_init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">capture_init</td><td>Pointer to slice configuration structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initialization of a CC4 slice to capture mode, by configuring CC4yTC, CC4yCMC, CC4yPSC,CC4yFPCS registers.<br />
<br />
CC4 slice is configured with Capture configurations in this routine.After initialization user has to explicitly enable the shadow transfer for the required values by calling <a class="el" href="group___c_c_u4.html#gadcfbaa660e4c008e78128b8deb4cc5c1">XMC_CCU4_EnableShadowTransfer()</a> with appropriate mask.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga3ed073924b8580efb863070ddf20426a">XMC_CCU4_SLICE_Capture0Config()</a><br />
 <a class="el" href="group___c_c_u4.html#ga01bd8510437249b1bc33eb5cd2da7b0f">XMC_CCU4_SLICE_Capture1Config()</a>. </dd></dl>

</div>
</div>
<a id="ga40dd61be60dc66c77164829280181e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40dd61be60dc66c77164829280181e90">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_ClearEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_ClearEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga9b6b22c75755089c6c4038de4a5d213c">XMC_CCU4_SLICE_IRQ_ID_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>Asserted event which must be acknowledged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Acknowledges an asserted event, by setting CC4ySWR with respective event flag.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga70968924480cf3d06eb9381856a69b87">XMC_CCU4_SLICE_EnableEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#gaa063b2ed84316c3dfb3f45b8cf2fcd38">XMC_CCU4_SLICE_SetEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#ga6d5a5802adc4917b4802db02926397e9">XMC_CCU4_SLICE_GetEvent()</a>. </dd></dl>

</div>
</div>
<a id="ga4520a69a5d5e653512ca6042feef4678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4520a69a5d5e653512ca6042feef4678">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_ClearTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_ClearTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Resets the timer count to zero, by setting CC4yTCCLR.TCC bit.<br />
<br />
A timer which has been stopped can still retain the last counted value. After invoking this API the timer value will be cleared.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga9997bb59706a4034e3e3be33a4935a7c">XMC_CCU4_SLICE_StartTimer()</a>. </dd></dl>

</div>
</div>
<a id="gaaaf6a6054b308d38a5d05a518d042873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaf6a6054b308d38a5d05a518d042873">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_CompareInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_CompareInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___c_c_u4___s_l_i_c_e___c_o_m_p_a_r_e___c_o_n_f_i_g__t.html">XMC_CCU4_SLICE_COMPARE_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>compare_init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">compare_init</td><td>Pointer to slice configuration structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initialization of a CC4 slice to compare mode, by configuring CC4yTC, CC4yCMC, CC4yPSC, CC4yDITH, CC4yPSL, CC4yFPCS, CC4yCHC registers.<br />
<br />
CC4 slice is configured with Timer configurations in this routine. After initialization user has to explicitly enable the shadow transfer for the required values by calling <a class="el" href="group___c_c_u4.html#gadcfbaa660e4c008e78128b8deb4cc5c1">XMC_CCU4_EnableShadowTransfer()</a> with appropriate mask.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga6417b3f8823b6c76ec44118fc9c1eeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6417b3f8823b6c76ec44118fc9c1eeb7">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_ConfigureEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_ConfigureEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___c_c_u4___s_l_i_c_e___e_v_e_n_t___c_o_n_f_i_g__t.html">XMC_CCU4_SLICE_EVENT_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>The External Event which needs to be configured. </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to event configuration data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures an External Event of the slice, by updating CC4yINS register .<br />
<br />
Details such as the input mapped to the event, event detection criteria and low pass filter options are programmed by this routine. The Event <b>config</b> will configure the input selection, the edge selection, the level selection and the Low pass filter for the event.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#ga17330b4b761f443140b1c736c1a09840">XMC_CCU4_SLICE_StopConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#ga2d77fccc50ddf0c24b4906fd1b4ba1ae">XMC_CCU4_SLICE_LoadConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#ga14933455fad7c724768f0cf8fbd61324">XMC_CCU4_SLICE_ModulationConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#gaf312a02f00b3149c2f5cd3faea6f93c2">XMC_CCU4_SLICE_CountConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#gafbf3c4118d03da31af66baf439183cae">XMC_CCU4_SLICE_GateConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#ga3ed073924b8580efb863070ddf20426a">XMC_CCU4_SLICE_Capture0Config()</a><br />
 <a class="el" href="group___c_c_u4.html#ga01bd8510437249b1bc33eb5cd2da7b0f">XMC_CCU4_SLICE_Capture1Config()</a><br />
 <a class="el" href="group___c_c_u4.html#gac61d7dc678e8379b4afaa8d763975866">XMC_CCU4_SLICE_DirectionConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#ga8f1ff68c2bae61d72c539684a050553b">XMC_CCU4_SLICE_StatusBitOverrideConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#gab2d5615177cfa2f20c5f5655400f4a8e">XMC_CCU4_SLICE_TrapConfig()</a>. </dd></dl>

</div>
</div>
<a id="ga0b084822487e0ca0a4a950c7d0f36fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b084822487e0ca0a4a950c7d0f36fa7">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___c_c_u4___s_l_i_c_e___e_v_e_n_t___c_o_n_f_i_g__t.html">XMC_CCU4_SLICE_EVENT_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>ev1_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___c_c_u4___s_l_i_c_e___e_v_e_n_t___c_o_n_f_i_g__t.html">XMC_CCU4_SLICE_EVENT_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>ev2_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">ev1_config</td><td>Pointer to event 1 configuration data </td></tr>
    <tr><td class="paramname">ev2_config</td><td>Pointer to event 2 configuration data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Map Status bit override function with an Event1 &amp; Event 2 of the slice and configure CC4yINS register.<br />
<br />
Details such as the input mapped to the event, event detection criteria and Low Pass filter options are programmed by this routine for the events 1 &amp; 2. Event-1 input would be the trigger to override the value. Event-2 input would be the override value.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga8f1ff68c2bae61d72c539684a050553b">XMC_CCU4_SLICE_StatusBitOverrideConfig()</a>. </dd></dl>

</div>
</div>
<a id="gaf312a02f00b3149c2f5cd3faea6f93c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf312a02f00b3149c2f5cd3faea6f93c2">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_CountConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_CountConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>Map an External event to the External Count Function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the Count Function of the slice, by configuring CC4yCMC.CNTS bit.<br />
<br />
Count function is mapped with one of the 3 events. CCU4 slice can take an external signal to act as the counting event. The CCU4 slice would count the edges present on the <b>event</b> selected.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga6417b3f8823b6c76ec44118fc9c1eeb7">XMC_CCU4_SLICE_ConfigureEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>. </dd></dl>

</div>
</div>
<a id="gac61d7dc678e8379b4afaa8d763975866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac61d7dc678e8379b4afaa8d763975866">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_DirectionConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_DirectionConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>Map an External event to the External Count Direction Function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the Count Direction of the slice, by configuring CC4yCMC.UDS bit.<br />
<br />
Count direction function is mapped with one of the 3 events. A slice can be configured to change the CC4yTIMER count direction depending on an external signal.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga6417b3f8823b6c76ec44118fc9c1eeb7">XMC_CCU4_SLICE_ConfigureEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>. </dd></dl>

</div>
</div>
<a id="ga3e4002ef45cbd1504f1dfa03be7f79d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e4002ef45cbd1504f1dfa03be7f79d6">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_DisableAutomaticShadowTransferRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_DisableAutomaticShadowTransferRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>automatic_shadow_transfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">automatic_shadow_transfer</td><td>specify upon which register update, automatic shadow transfer request should not be generated Use :: XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_t enum items to create a mask of choice, using a bit wise OR operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configure on which shadow register update, automatic shadow transfer request generation has to be disabled. By clearing ASPC, ASCC1, ASCC2, ASLC, ASDC, ASFC bits in STC register.<br />
<br />
 This disables the generation of automatic shadow transfer request for the specified register update. </dd></dl>
<dl class="section user"><dt>Note:</dt><dd></dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gada142961bff1eae9b4182249810b762e">XMC_CCU4_SLICE_EnableAutomaticShadowTransferRequest()</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="gaf299d2965b919f5828ded78d2d015baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf299d2965b919f5828ded78d2d015baa">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_DisableCascadedShadowTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_DisableCascadedShadowTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the cascaded the shadow transfer operation, by clearing CSE bit in STC register.<br />
<br />
 If in any slice the cascaded mode disabled, other slices from there onwards does not update the values in cascaded mode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gaa8a44e999105f023b688fb8e3cf28c43">XMC_CCU4_SLICE_EnableCascadedShadowTransfer()</a><br />
. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="ga074938e1d84568cc5d0c14247188ceab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga074938e1d84568cc5d0c14247188ceab">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_DisableDithering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_DisableDithering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables dithering of PWM frequency and duty cycle, by clearing CC4yTC.DITHE bits.<br />
<br />
This disables the Dither mode that was set in <a class="el" href="group___c_c_u4.html#ga726d7c99adf8d7f438f1f08ef2a9de1a">XMC_CCU4_SLICE_EnableDithering()</a>. This API will not clear the dither compare value.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga726d7c99adf8d7f438f1f08ef2a9de1a">XMC_CCU4_SLICE_EnableDithering()</a>. </dd></dl>

</div>
</div>
<a id="ga1d8dd9cc41693043dec0ae759d91fbae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d8dd9cc41693043dec0ae759d91fbae">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_DisableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_DisableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga9b6b22c75755089c6c4038de4a5d213c">XMC_CCU4_SLICE_IRQ_ID_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>Event whose assertion can potentially lead to an interrupt </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the generation of an interrupt pulse for the event, by clearing CC4yINTE register.<br />
<br />
Prevents the event from being asserted</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga08c882083ebd4d874a466b61d011e3f7">XMC_CCU4_SLICE_SetInterruptNode()</a><br />
 <a class="el" href="group___c_c_u4.html#ga70968924480cf3d06eb9381856a69b87">XMC_CCU4_SLICE_EnableEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#gadc79794c8392fdd71e843220786d8d99">XMC_CCU4_SLICE_EnableMultipleEvents()</a><br />
 <a class="el" href="group___c_c_u4.html#ga3152586e4a4d2f25775bb0286653ca8c">XMC_CCU4_SLICE_DisableMultipleEvents()</a>. </dd></dl>

</div>
</div>
<a id="gae2c8386269be2f976ab9bb83da99087a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2c8386269be2f976ab9bb83da99087a">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_DisableFloatingPrescaler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_DisableFloatingPrescaler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the floating prescaler, by clearing CC4yTC.FPE bit.<br />
<br />
This would return the prescaler to the normal mode. The prescaler that would be applied is the value present in CC4yPSC.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga495ca5dfa02beb5a818dd113ebf99ae1">XMC_CCU4_SLICE_EnableFloatingPrescaler()</a>. </dd></dl>

</div>
</div>
<a id="ga08273e7c8fa6261de82759637831a989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08273e7c8fa6261de82759637831a989">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_DisableMultiChannelMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_DisableMultiChannelMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the multichannel mode, by clearing CC4yTC.MCME bit.<br />
<br />
This would return the slices to the normal operation mode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga470cd6e533923a9495e76fd7f0fcf0de">XMC_CCU4_SLICE_EnableMultiChannelMode()</a>. </dd></dl>

</div>
</div>
<a id="ga3152586e4a4d2f25775bb0286653ca8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3152586e4a4d2f25775bb0286653ca8c">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_DisableMultipleEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_DisableMultipleEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">mask</td><td>Event mask such that multiple events can be enabled. Use <a class="el" href="group___c_c_u4.html#ga99a221425b50cb24f3358c905c92f105">XMC_CCU4_SLICE_MULTI_IRQ_ID_t</a> enum items to create a mask of choice, using a bit wise OR operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the generation of an interrupt pulse for the required events, by clearing CC4yINTE register.<br />
<br />
 Prevents selected events of the slice from being asserted.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga08c882083ebd4d874a466b61d011e3f7">XMC_CCU4_SLICE_SetInterruptNode()</a><br />
 <a class="el" href="group___c_c_u4.html#ga70968924480cf3d06eb9381856a69b87">XMC_CCU4_SLICE_EnableEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#gadc79794c8392fdd71e843220786d8d99">XMC_CCU4_SLICE_EnableMultipleEvents()</a><br />
 <a class="el" href="group___c_c_u4.html#ga1d8dd9cc41693043dec0ae759d91fbae">XMC_CCU4_SLICE_DisableEvent()</a>. </dd></dl>

</div>
</div>
<a id="ga528b039bddfe9e20f765aaa2f7bdcc0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga528b039bddfe9e20f765aaa2f7bdcc0e">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_DisableTrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_DisableTrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the trap feature, by clearing CC4yTC.TRAPE0, CC4yTC.TRAPE1, CC4yTC.TRAPE2 and CC4yTC.TRAPE3 bit based on the <em>out_mask</em>.<br />
<br />
.<br />
<br />
This API will revert the changes done by <a class="el" href="group___c_c_u4.html#gaba1fc3c0735f1bed11dafb3d4c773ba5">XMC_CCU4_SLICE_EnableTrap()</a>. This Ensures that the TRAP function has no effect on the output of the CCU4 slice.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gaba1fc3c0735f1bed11dafb3d4c773ba5">XMC_CCU4_SLICE_EnableTrap()</a>. </dd></dl>

</div>
</div>
<a id="gada142961bff1eae9b4182249810b762e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada142961bff1eae9b4182249810b762e">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_EnableAutomaticShadowTransferRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_EnableAutomaticShadowTransferRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>automatic_shadow_transfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">automatic_shadow_transfer</td><td>specify upon which register update, automatic shadow transfer request is generated Use :: XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_t enum items to create a mask of choice, using a bit wise OR operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configure on which shadow register update, automatic shadow transfer request generation has to be enabled. By setting ASPC, ASCC1, ASCC2, ASLC, ASDC, ASFC bits in STC register.<br />
<br />
 By updating the configured shadow register, the shadow transfer request is generated to update all the shadow registers. </dd></dl>
<dl class="section user"><dt>Note:</dt><dd></dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga3e4002ef45cbd1504f1dfa03be7f79d6">XMC_CCU4_SLICE_DisableAutomaticShadowTransferRequest()</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="gaa8a44e999105f023b688fb8e3cf28c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8a44e999105f023b688fb8e3cf28c43">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_EnableCascadedShadowTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_EnableCascadedShadowTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Cascades the shadow transfer operation throughout the CCU4 timer slices, by setting CSE bit in STC register.<br />
<br />
 The shadow transfer enable bits needs to be set in all timer slices, that are being used in the cascaded architecture, at the same time. The shadow transfer enable bits, also need to be set for all slices even if the shadow values of some slices were not updated. It is possible to to cascade with the adjacent slices only. CC40 slice is a master to start the operation.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd><a class="el" href="group___c_c_u4.html#gadcfbaa660e4c008e78128b8deb4cc5c1">XMC_CCU4_EnableShadowTransfer()</a> must be called to enable the shadow transfer of the all the slices, which needs to be cascaded.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gadcfbaa660e4c008e78128b8deb4cc5c1">XMC_CCU4_EnableShadowTransfer()</a>, <a class="el" href="group___c_c_u4.html#gaf299d2965b919f5828ded78d2d015baa">XMC_CCU4_SLICE_DisableCascadedShadowTransfer()</a><br />
. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="ga726d7c99adf8d7f438f1f08ef2a9de1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga726d7c99adf8d7f438f1f08ef2a9de1a">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_EnableDithering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_EnableDithering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>period_dither</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>duty_dither</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>spread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">period_dither</td><td>Boolean instruction on dithering of period match </td></tr>
    <tr><td class="paramname">duty_dither</td><td>Boolean instruction on dithering of compare match </td></tr>
    <tr><td class="paramname">spread</td><td>Dither compare value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables dithering of PWM frequency and duty cycle, by configuring CC4yTC.DITHE and CC4yDITS bits.<br />
<br />
Some control loops are slow in updating PWM frequency and duty cycle. In such a case, a Bresenham style dithering can help reduce long term errors. Dithering can be applied to period and duty individually, this can be selected using the parameter <b>period_dither</b> and <b>duty_dither</b>. The <b>spread</b> would provide the dither compare value. If the dither counter value is less than this <b>spread</b> then the period/compare values would be dithered according to the dither mode selected. This API would invoke <a class="el" href="group___c_c_u4.html#gac459b6e5e0efccd9bc762c5add86ca48">XMC_CCU4_SLICE_SetDitherCompareValue()</a>.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>After this API call, <a class="el" href="group___c_c_u4.html#gadcfbaa660e4c008e78128b8deb4cc5c1">XMC_CCU4_EnableShadowTransfer()</a> has to be called with appropriate mask to transfer the dither value.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga074938e1d84568cc5d0c14247188ceab">XMC_CCU4_SLICE_DisableDithering()</a>. </dd></dl>

</div>
</div>
<a id="ga70968924480cf3d06eb9381856a69b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70968924480cf3d06eb9381856a69b87">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_EnableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_EnableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga9b6b22c75755089c6c4038de4a5d213c">XMC_CCU4_SLICE_IRQ_ID_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>Event whose assertion can potentially lead to an interrupt </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the generation of an interrupt pulse for the event, by configuring CC4yINTE register.<br />
<br />
For an event to lead to an interrupt, it must first be enabled and bound to a service request line. The corresponding NVIC node must be enabled as well. This API merely enables the event. Binding with SR is performed by another API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga08c882083ebd4d874a466b61d011e3f7">XMC_CCU4_SLICE_SetInterruptNode()</a><br />
 <a class="el" href="group___c_c_u4.html#gadc79794c8392fdd71e843220786d8d99">XMC_CCU4_SLICE_EnableMultipleEvents()</a><br />
 <a class="el" href="group___c_c_u4.html#ga1d8dd9cc41693043dec0ae759d91fbae">XMC_CCU4_SLICE_DisableEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#ga3152586e4a4d2f25775bb0286653ca8c">XMC_CCU4_SLICE_DisableMultipleEvents()</a>. </dd></dl>

</div>
</div>
<a id="ga495ca5dfa02beb5a818dd113ebf99ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga495ca5dfa02beb5a818dd113ebf99ae1">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_EnableFloatingPrescaler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_EnableFloatingPrescaler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the floating prescaler, by setting CC4yTC.FPE bit.<br />
<br />
The prescaler divider starts with an initial value and increments upon every period match. It keeps incrementing until a ceiling (prescaler compare value) is hit and thereafter rolls back to the original prescaler divider value.<br />
It is necessary to have programmed an initial divider value and a compare value before the feature is enabled.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga989c0d32380efe2053c259ff4e7d3c78">XMC_CCU4_SLICE_SetFloatingPrescalerCompareValue()</a><br />
 <a class="el" href="group___c_c_u4.html#gae2c8386269be2f976ab9bb83da99087a">XMC_CCU4_SLICE_DisableFloatingPrescaler()</a><br />
 <a class="el" href="group___c_c_u4.html#ga24127bd989b62814c2ba0cc876b99473">XMC_CCU4_SLICE_SetPrescaler()</a>. </dd></dl>

</div>
</div>
<a id="ga470cd6e533923a9495e76fd7f0fcf0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga470cd6e533923a9495e76fd7f0fcf0de">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_EnableMultiChannelMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_EnableMultiChannelMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the multichannel mode, by setting CC4yTC.MCME bit.<br />
<br />
The output state of the Timer slices can be controlled in parallel by a single input signal. A particularly useful feature in motor control applications where the PWM output of multiple slices of a module can be gated and ungated by multi-channel gating inputs connected to the slices. A peripheral like POSIF connected to the motor knows exactly which of the power drive switches are to be turned on and off at any instant. It can thus through a gating bus (known as multi-channel inputs) control which of the slices output stays gated/ungated.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga08273e7c8fa6261de82759637831a989">XMC_CCU4_SLICE_DisableMultiChannelMode()</a><br />
 <a class="el" href="group___c_c_u4.html#ga10d688acde3cd3ffa2067973c640f9bf">XMC_CCU4_SetMultiChannelShadowTransferMode()</a>. </dd></dl>

</div>
</div>
<a id="gadc79794c8392fdd71e843220786d8d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc79794c8392fdd71e843220786d8d99">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_EnableMultipleEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_EnableMultipleEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>intr_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">intr_mask</td><td>Event mask such that multiple events can be enabled. Use <a class="el" href="group___c_c_u4.html#ga99a221425b50cb24f3358c905c92f105">XMC_CCU4_SLICE_MULTI_IRQ_ID_t</a> enum items to create a mask of choice, using a bit wise OR operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the generation of an interrupt pulse for the required events, by configuring CC4yINTE register.<br />
<br />
For an event to lead to an interrupt, it must first be enabled and bound to a service request line. The corresponding NVIC node must be enabled as well. This API merely enables the events. Binding with SR is performed by another API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga08c882083ebd4d874a466b61d011e3f7">XMC_CCU4_SLICE_SetInterruptNode()</a><br />
 <a class="el" href="group___c_c_u4.html#ga70968924480cf3d06eb9381856a69b87">XMC_CCU4_SLICE_EnableEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#ga1d8dd9cc41693043dec0ae759d91fbae">XMC_CCU4_SLICE_DisableEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#ga3152586e4a4d2f25775bb0286653ca8c">XMC_CCU4_SLICE_DisableMultipleEvents()</a>. </dd></dl>

</div>
</div>
<a id="gaba1fc3c0735f1bed11dafb3d4c773ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba1fc3c0735f1bed11dafb3d4c773ba5">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_EnableTrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_EnableTrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the trap feature, by setting CC4yTC.TRAPE0, CC4yTC.TRAPE1, CC4yTC.TRAPE2 and CC4yTC.TRAPE3 bit based on the <em>out_mask</em>.<br />
<br />
A particularly useful feature where the PWM output can be forced inactive upon detection of a trap. The trap signal can be the output of a sensing element which has just detected an abnormal electrical condition.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gab2d5615177cfa2f20c5f5655400f4a8e">XMC_CCU4_SLICE_TrapConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#ga528b039bddfe9e20f765aaa2f7bdcc0e">XMC_CCU4_SLICE_DisableTrap()</a><br />
 <a class="el" href="group___c_c_u4.html#ga6417b3f8823b6c76ec44118fc9c1eeb7">XMC_CCU4_SLICE_ConfigureEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>. </dd></dl>

</div>
</div>
<a id="gafbf3c4118d03da31af66baf439183cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbf3c4118d03da31af66baf439183cae">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_GateConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_GateConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>Map an External event to the External Gating Function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the Gating Function of the slice, by configuring CC4yCMC.GATES bit.<br />
<br />
Gating function is mapped with one of the 3 events. A CCU4 slice can use an input signal that would operate as counter gating. If the configured Active level is detected the counter will gate all the pulses.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga6417b3f8823b6c76ec44118fc9c1eeb7">XMC_CCU4_SLICE_ConfigureEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>. </dd></dl>

</div>
</div>
<a id="ga0c918bf66f4046e22bb10f7172f8ae41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c918bf66f4046e22bb10f7172f8ae41">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_GetCapturedValueFromFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_CCU4_SLICE_GetCapturedValueFromFifo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gab5c05e6fda34ac046c12ec25ef405a3d">XMC_CCU4_SLICE_CAP_REG_SET_t</a>&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">set</td><td>The capture register set from which the captured value is to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 uint32_t Returns the value captured in the <b>slice_number</b> Range: [0x0 to 0xFFFF]</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Read captured value from FIFO(CC4yECRD0 and CC4yECRD1).<br />
<br />
This is applicable only in the Capture mode of operation. The signal whose timing characteristics are to be measured must be mapped to an event which in turn must be mapped to the capture function. Based on the capture criteria, the instant timer values are captured into capture registers. Timing characteristics of the input signal may then be derived/inferred from the captured values.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gaf9fa582be48916db21e086f073930ce2">XMC_CCU4_SLICE_IsExtendedCapReadEnabled()</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined for XMC4800, XMC4700, XMC4500, XMC4400, XMC4200, XMC4100 devices only. For other devices use XMC_CCU4_GetCapturedValueFromFifo() API </dd></dl>

</div>
</div>
<a id="gaf3b2360da5116806f763ee79a63591ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3b2360da5116806f763ee79a63591ab">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_GetCaptureRegisterValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_CCU4_SLICE_GetCaptureRegisterValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>reg_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">reg_num</td><td>The capture register from which the captured value is to be retrieved Range: [0,3] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 uint32_t Returns the Capture register value. Range: [0 to 0x1FFFFF]</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Retrieves timer value which has been captured in the Capture registers, by reading CC4yCV[<b>reg_num</b>] register.<br />
<br />
The signal whose timing characteristics are to be measured must be mapped to an event which in turn must be mapped to the capture function. Based on the capture criteria, the timer values are captured into capture registers. Timing characteristics of the input signal may then be derived/inferred from the captured values. The full flag will help to find out if there is a new captured value present.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga3392bbfae89deb4a809aab04efde114b">XMC_CCU4_SLICE_GetLastCapturedTimerValue()</a>. </dd></dl>

</div>
</div>
<a id="ga6762faa90aae0987218b1c0b173b5385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6762faa90aae0987218b1c0b173b5385">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_GetCountingDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_c_u4.html#gacbf19766ba6532d4b09ac3ac1cd0d571">XMC_CCU4_SLICE_TIMER_COUNT_DIR_t</a> XMC_CCU4_SLICE_GetCountingDir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 <a class="el" href="group___c_c_u4.html#gacbf19766ba6532d4b09ac3ac1cd0d571">XMC_CCU4_SLICE_TIMER_COUNT_DIR_t</a> returns the direction in which the timer is counting.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the timer counting direction, by reading CC4yTCST.CDIR bit.<br />
<br />
This API will return the direction in which the timer is currently incrementing(XMC_CCU4_SLICE_TIMER_COUNT_DIR_UP) or decrementing (XMC_CCU4_SLICE_TIMER_COUNT_DIR_DOWN).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga6d5a5802adc4917b4802db02926397e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d5a5802adc4917b4802db02926397e9">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_GetEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_CCU4_SLICE_GetEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga9b6b22c75755089c6c4038de4a5d213c">XMC_CCU4_SLICE_IRQ_ID_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>Event to be evaluated for assertion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 bool Returns true if event is set else false is returned.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Evaluates if a given event is asserted or not, by reading CC4yINTS register.<br />
<br />
Return true if the event is asserted. For a event to be asserted it has to be first enabled. Only if that event is enabled the call to this API is valid. If the Event is enabled and has not yet occurred then a false is returned.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga70968924480cf3d06eb9381856a69b87">XMC_CCU4_SLICE_EnableEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#gaa063b2ed84316c3dfb3f45b8cf2fcd38">XMC_CCU4_SLICE_SetEvent()</a>. </dd></dl>

</div>
</div>
<a id="ga3392bbfae89deb4a809aab04efde114b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3392bbfae89deb4a809aab04efde114b">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_GetLastCapturedTimerValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_c_u4.html#gac0f35f7b62570cbbd9ff102fea356b62">XMC_CCU4_STATUS_t</a> XMC_CCU4_SLICE_GetLastCapturedTimerValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gab5c05e6fda34ac046c12ec25ef405a3d">XMC_CCU4_SLICE_CAP_REG_SET_t</a>&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>val_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">set</td><td>The capture register set, which must be evaluated </td></tr>
    <tr><td class="paramname">val_ptr</td><td>Out Parameter of the API.Stores the captured timer value into this out parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 <a class="el" href="group___c_c_u4.html#gac0f35f7b62570cbbd9ff102fea356b62">XMC_CCU4_STATUS_t</a> Returns XMC_CCU4_STATUS_OK if there was new value present in the capture registers. returns XMC_CCU4_STATUS_ERROR if there was no new value present in the capture registers.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Retrieves the latest captured timer value, by reading CC4yCV registers.<br />
<br />
Retrieve the timer value last stored by the slice. When separate capture events are used, users must specify the capture set to evaluate. If single capture event mode is used, all 4 capture registers are evaluated.<br />
The lowest register is evaluated first followed by the next higher ordered register and this continues until all capture registers have been evaluated.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gaf3b2360da5116806f763ee79a63591ab">XMC_CCU4_SLICE_GetCaptureRegisterValue()</a>. </dd></dl>

</div>
</div>
<a id="gace251376e4d8988e023fbf11013791c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace251376e4d8988e023fbf11013791c4">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_GetPrescaler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_c_u4.html#ga871bce3beb610d5e16b083c68381a60f">XMC_CCU4_SLICE_PRESCALER_t</a> XMC_CCU4_SLICE_GetPrescaler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 XMC_CCU4_SLICE_PRESCALER_t Prescaler divider value.<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns current prescaler value.<br />
<br />
Used to detrmine the clock frequency of the CCU8 slice <a class="el" href="group___s_c_u.html#ga22725a6c39f19f4089e45509e63f936e">XMC_SCU_CLOCK_GetCcuClockFrequency()</a> / <a class="el" href="group___c_c_u4.html#gace251376e4d8988e023fbf11013791c4">XMC_CCU4_SLICE_GetPrescaler()</a></dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga24127bd989b62814c2ba0cc876b99473">XMC_CCU4_SLICE_SetPrescaler()</a>. </dd></dl>

</div>
</div>
<a id="ga0aa3f23d1d1251bfc67284abd641eb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aa3f23d1d1251bfc67284abd641eb0b">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_GetSliceMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_c_u4.html#ga9667e43e2a54209c309f767354a0af8e">XMC_CCU4_SLICE_MODE_t</a> XMC_CCU4_SLICE_GetSliceMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 <a class="el" href="group___c_c_u4.html#ga9667e43e2a54209c309f767354a0af8e">XMC_CCU4_SLICE_MODE_t</a> returns XMC_CCU4_SLICE_MODE_COMPARE if the slice is operating in compare mode returns XMC_CCU4_SLICE_MODE_CAPTURE if the slice is operating in capture mode</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Retrieves the current mode of operation in the slice (either Capture mode or Compare mode), by reading CC4yTC.CMOD bit.<br />
<br />
Ensure that before invoking this API the CCU4 slice should be configured otherwise the output of this API is invalid.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga6dbf6592e274fd4a3df6322abbcf1af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dbf6592e274fd4a3df6322abbcf1af3">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_GetTimerCompareMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XMC_CCU4_SLICE_GetTimerCompareMatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 uint16_t returns the current timer compare value Range: [0x0 to 0xFFFF]</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Retrieves the timer compare value currently effective, by reading CC4yCRS register.<br />
<br />
If the timer is active then the value being returned is currently being for the PWM duty cycle( timer compare value).</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>The <a class="el" href="group___c_c_u4.html#ga7ae1adcaba614fa7d919221da9020a57">XMC_CCU4_SLICE_SetTimerCompareMatch()</a> would set the new compare value to a shadow register. This would only transfer the new values into the actual compare register if the shadow transfer request is enabled and if a period match occurs. Hence a consecutive call to <a class="el" href="group___c_c_u4.html#ga6dbf6592e274fd4a3df6322abbcf1af3">XMC_CCU4_SLICE_GetTimerCompareMatch()</a> would not reflect the new values until the shadow transfer completes. Directly accessed Register is CC4yCR.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga7ae1adcaba614fa7d919221da9020a57">XMC_CCU4_SLICE_SetTimerCompareMatch()</a>. </dd></dl>

</div>
</div>
<a id="gac330a353060ff06f84d2d9835716ea94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac330a353060ff06f84d2d9835716ea94">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_GetTimerCountingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_c_u4.html#ga488780142d4d7da249cbb6e2c16ec512">XMC_CCU4_SLICE_TIMER_COUNT_MODE_t</a> XMC_CCU4_SLICE_GetTimerCountingMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 <a class="el" href="group___c_c_u4.html#ga488780142d4d7da249cbb6e2c16ec512">XMC_CCU4_SLICE_TIMER_COUNT_MODE_t</a> returns XMC_CCU4_SLICE_TIMER_COUNT_MODE_EA if edge aligned mode is selected returns XMC_CCU4_SLICE_TIMER_COUNT_MODE_CA if center aligned mode is selected</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Retrieves timer counting mode either Edge aligned or Center Aligned, by reading CC4yTC.TCM bit.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga35b25352390bfa747b51ba511fe85c57">XMC_CCU4_SLICE_SetTimerCountingMode()</a>. </dd></dl>

</div>
</div>
<a id="ga33f030851ea5f6abc4d7e1ecd7de2906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33f030851ea5f6abc4d7e1ecd7de2906">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_GetTimerPeriodMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XMC_CCU4_SLICE_GetTimerPeriodMatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 uint16_t returns the current timer period value Range: [0x0 to 0xFFFF]</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Retrieves the timer period value currently effective, by reading CC4yPR register.<br />
<br />
If the timer is active then the value being returned is currently being used for the PWM period.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>The <a class="el" href="group___c_c_u4.html#ga1341abfd52a8165c7e1b5292033797ed">XMC_CCU4_SLICE_SetTimerPeriodMatch()</a> would set the new period value to a shadow register. This would only transfer the new values into the actual period register if the shadow transfer request is enabled and if a period match occurs. Hence a consecutive call to <a class="el" href="group___c_c_u4.html#ga33f030851ea5f6abc4d7e1ecd7de2906">XMC_CCU4_SLICE_GetTimerPeriodMatch()</a> would not reflect the new values until the shadow transfer completes.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga1341abfd52a8165c7e1b5292033797ed">XMC_CCU4_SLICE_SetTimerPeriodMatch()</a>. </dd></dl>

</div>
</div>
<a id="gad164d9989a251f651159323c718965f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad164d9989a251f651159323c718965f1">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_GetTimerRepeatMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_c_u4.html#ga85c8c78c8c4ec52eae3d4654aa37ad9d">XMC_CCU4_SLICE_TIMER_REPEAT_MODE_t</a> XMC_CCU4_SLICE_GetTimerRepeatMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 <a class="el" href="group___c_c_u4.html#ga85c8c78c8c4ec52eae3d4654aa37ad9d">XMC_CCU4_SLICE_TIMER_REPEAT_MODE_t</a> returns XMC_CCU4_SLICE_TIMER_REPEAT_MODE_REPEAT if continuous mode is selected returns XMC_CCU4_SLICE_TIMER_REPEAT_MODE_SINGLE if single shot mode is selected</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Retrieves the Timer repeat mode, either Single shot mode or continuous mode, by reading CC4yTC.TSSM bit.<br />
<br />
The timer will count up to the terminal count as specified in the period register and stops immediately if the repeat mode has been set to single shot mode. In the continuous mode of operation, the timer starts counting all over again after reaching the terminal count.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gaaaceaa5953e0235db8f17592c3606aff">XMC_CCU4_SLICE_SetTimerRepeatMode()</a>. </dd></dl>

</div>
</div>
<a id="ga9d9be217f287f53b1e96e929753acf41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d9be217f287f53b1e96e929753acf41">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_GetTimerValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XMC_CCU4_SLICE_GetTimerValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 uint16_t returns the current timer value Range: [0x0 to 0xFFFF]</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Retrieves the latest timer value, from CC4yTIMER register.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gad654c695ac03c9218657816e4468d835">XMC_CCU4_SLICE_SetTimerValue()</a>. </dd></dl>

</div>
</div>
<a id="gaf9fa582be48916db21e086f073930ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9fa582be48916db21e086f073930ce2">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_IsExtendedCapReadEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_CCU4_SLICE_IsExtendedCapReadEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 bool would return true if the extended capture read back mode is enabled<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Checks if Extended capture mode read is enabled for particular slice or not, by reading CC4yTC.ECM bit.<br />
<br />
In this mode the there is only one associated read address for all the capture registers. Individual capture registers can still be accessed in this mode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>XMC_CCU4_GetCapturedValueFromFifo(). </dd></dl>

</div>
</div>
<a id="ga505356f6ed183985041548ee87abfa69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga505356f6ed183985041548ee87abfa69">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_IsTimerRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_CCU4_SLICE_IsTimerRunning </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 bool returns <b>true</b> if the Timer is running else it returns <b>false</b>.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the state of the timer (Either Running or stopped(idle)), by reading CC4yTCST.TRB bit.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga9997bb59706a4034e3e3be33a4935a7c">XMC_CCU4_SLICE_StartTimer()</a><br />
 <a class="el" href="group___c_c_u4.html#gac41eed8d2857f7c9d23567fa742a705c">XMC_CCU4_SLICE_StopTimer()</a>. </dd></dl>

</div>
</div>
<a id="ga2d77fccc50ddf0c24b4906fd1b4ba1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d77fccc50ddf0c24b4906fd1b4ba1ae">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_LoadConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_LoadConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>Map an External event to the External load Function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the Load Function for the slice, by configuring CC4yCMC.LDS bit.<br />
<br />
 Load function is mapped with one of the 3 events. Up on occurrence of the event,<br />
 if CC4yTCST.CDIR set to 0,CC4yTIMER register is reloaded with the value from compare register<br />
 if CC4yTCST.CDIR set to 1,CC4yTIMER register is reloaded with the value from period register<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga6417b3f8823b6c76ec44118fc9c1eeb7">XMC_CCU4_SLICE_ConfigureEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>. </dd></dl>

</div>
</div>
<a id="ga14933455fad7c724768f0cf8fbd61324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14933455fad7c724768f0cf8fbd61324">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_ModulationConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_ModulationConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gaba1abc67da718dd4dd0df6054aeda354">XMC_CCU4_SLICE_MODULATION_MODE_t</a>&#160;</td>
          <td class="paramname"><em>mod_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>synch_with_pwm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>Map an External event to the External Modulation Function </td></tr>
    <tr><td class="paramname">mod_mode</td><td>Desired Modulation mode </td></tr>
    <tr><td class="paramname">synch_with_pwm</td><td>Option to synchronize modulation with PWM start Pass <b>true</b> if the modulation needs to be synchronized with PWM signal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the Output Modulation Function of the slice, by configuring CCeyCMC.MOS, CC4yTC.EMT and CC4yTC.EMS bits.<br />
<br />
Modulation function is mapped with one of the 3 events. The output signal of the CCU can be modulated according to a external input. Additionally, the behaviour of the slice upon activation of the modulation function is configured as well.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga6417b3f8823b6c76ec44118fc9c1eeb7">XMC_CCU4_SLICE_ConfigureEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>. </dd></dl>

</div>
</div>
<a id="gac459b6e5e0efccd9bc762c5add86ca48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac459b6e5e0efccd9bc762c5add86ca48">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_SetDitherCompareValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_SetDitherCompareValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>comp_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">comp_val</td><td>Dither compare value Range: [0x0 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the dither spread/compare value, by setting CC4yDITS.DCVS bits.<br />
<br />
This value is the cornerstone of PWM dithering feature. Dithering is applied/done when the value in the dithering counter is less than this compare/spread value. For all dithering counter values greater than the spread value, there is no dithering. After setting the value <a class="el" href="group___c_c_u4.html#gadcfbaa660e4c008e78128b8deb4cc5c1">XMC_CCU4_EnableShadowTransfer()</a> has to be called with appropriate mask.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga726d7c99adf8d7f438f1f08ef2a9de1a">XMC_CCU4_SLICE_EnableDithering()</a>. </dd></dl>

</div>
</div>
<a id="gaa063b2ed84316c3dfb3f45b8cf2fcd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa063b2ed84316c3dfb3f45b8cf2fcd38">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_SetEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_SetEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga9b6b22c75755089c6c4038de4a5d213c">XMC_CCU4_SLICE_IRQ_ID_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>Event whose assertion can potentially lead to an interrupt </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Manually asserts the requested event, by setting CC4ySWS register.<br />
<br />
For an event to lead to an interrupt, it must first be enabled and bound to a service request line. The corresponding NVIC node must be enabled as well. This API manually asserts the requested event.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga08c882083ebd4d874a466b61d011e3f7">XMC_CCU4_SLICE_SetInterruptNode()</a><br />
 <a class="el" href="group___c_c_u4.html#ga70968924480cf3d06eb9381856a69b87">XMC_CCU4_SLICE_EnableEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#gadc79794c8392fdd71e843220786d8d99">XMC_CCU4_SLICE_EnableMultipleEvents()</a>. </dd></dl>

</div>
</div>
<a id="ga989c0d32380efe2053c259ff4e7d3c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga989c0d32380efe2053c259ff4e7d3c78">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_SetFloatingPrescalerCompareValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_SetFloatingPrescalerCompareValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>cmp_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">cmp_val</td><td>Prescaler divider compare value Range: [0x0 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Programs the slice specific prescaler divider compare value, by configuring CC4yFPCS register.<br />
<br />
The compare value is applicable only in floating mode of operation. The prescaler divider starts with an initial value and increments to the compare value steadily upon every period match. Once prescaler divider equals the prescaler divider compare value, the value in the former resets back to the PVAL (from FPC). After setting the value, <a class="el" href="group___c_c_u4.html#gadcfbaa660e4c008e78128b8deb4cc5c1">XMC_CCU4_EnableShadowTransfer()</a> has to be called with appropriate mask.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga24127bd989b62814c2ba0cc876b99473">XMC_CCU4_SLICE_SetPrescaler()</a>. </dd></dl>

</div>
</div>
<a id="ga28e214514acb1a75a67de63e6d74b167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28e214514acb1a75a67de63e6d74b167">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_SetInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_SetInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gaab7f7bcdc1aff8cc0beb2edae16a3cf3">XMC_CCU4_SLICE_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>The External Event which needs to be configured. </td></tr>
    <tr><td class="paramname">input</td><td>One of the 16 inputs meant to be mapped to the desired event </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Selects an input for an external event, by configuring CC4yINS register.<br />
<br />
It is possible to select one of the possible 16 input signals for a given Event. This configures the CC4yINS.EVxIS for the selected event.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#ga17330b4b761f443140b1c736c1a09840">XMC_CCU4_SLICE_StopConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#ga2d77fccc50ddf0c24b4906fd1b4ba1ae">XMC_CCU4_SLICE_LoadConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#ga14933455fad7c724768f0cf8fbd61324">XMC_CCU4_SLICE_ModulationConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#gaf312a02f00b3149c2f5cd3faea6f93c2">XMC_CCU4_SLICE_CountConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#gafbf3c4118d03da31af66baf439183cae">XMC_CCU4_SLICE_GateConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#ga3ed073924b8580efb863070ddf20426a">XMC_CCU4_SLICE_Capture0Config()</a><br />
 <a class="el" href="group___c_c_u4.html#ga01bd8510437249b1bc33eb5cd2da7b0f">XMC_CCU4_SLICE_Capture1Config()</a><br />
 <a class="el" href="group___c_c_u4.html#gac61d7dc678e8379b4afaa8d763975866">XMC_CCU4_SLICE_DirectionConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#ga8f1ff68c2bae61d72c539684a050553b">XMC_CCU4_SLICE_StatusBitOverrideConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#gab2d5615177cfa2f20c5f5655400f4a8e">XMC_CCU4_SLICE_TrapConfig()</a>. </dd></dl>

</div>
</div>
<a id="ga08c882083ebd4d874a466b61d011e3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08c882083ebd4d874a466b61d011e3f7">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_SetInterruptNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_SetInterruptNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga9b6b22c75755089c6c4038de4a5d213c">XMC_CCU4_SLICE_IRQ_ID_t</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga9de58e90257a0c33532f376c7c5f959e">XMC_CCU4_SLICE_SR_ID_t</a>&#160;</td>
          <td class="paramname"><em>sr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>Event which must be bound to a service request line </td></tr>
    <tr><td class="paramname">sr</td><td>The Service request line which is bound to the <b>event</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Binds requested event to a service request line, by configuring CC4ySRS register with respective event.<br />
<br />
For an event to lead to an interrupt, it must first be enabled and bound to a service request line. The corresponding NVIC node must be enabled as well. This API binds the requested event with the requested service request line(<b>sr</b>).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga70968924480cf3d06eb9381856a69b87">XMC_CCU4_SLICE_EnableEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#gaa063b2ed84316c3dfb3f45b8cf2fcd38">XMC_CCU4_SLICE_SetEvent()</a>. </dd></dl>

</div>
</div>
<a id="ga962a6a7402c99ec80359d3202ae9cd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga962a6a7402c99ec80359d3202ae9cd50">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_SetPassiveLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_SetPassiveLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gad1e13100aef87f3fdbffcd561b1d7e57">XMC_CCU4_SLICE_OUTPUT_PASSIVE_LEVEL_t</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">level</td><td>Slice output passive level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the passive level for the slice output, by setting CC4yPSL register.<br />
<br />
Defines the passive level for the timer slice output pin. Selects either level high is passive or level low is passive. This is the level of the output before the compare match is value changes it.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga70968924480cf3d06eb9381856a69b87">XMC_CCU4_SLICE_EnableEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#gaa063b2ed84316c3dfb3f45b8cf2fcd38">XMC_CCU4_SLICE_SetEvent()</a>. </dd></dl>

</div>
</div>
<a id="ga24127bd989b62814c2ba0cc876b99473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24127bd989b62814c2ba0cc876b99473">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_SetPrescaler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_SetPrescaler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga871bce3beb610d5e16b083c68381a60f">XMC_CCU4_SLICE_PRESCALER_t</a>&#160;</td>
          <td class="paramname"><em>div_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">div_val</td><td>Prescaler divider value. Accepts enum :: XMC_CCU4_SLICE_PRESCALER_t Range: [0x0 to 0xF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Programs the slice specific prescaler divider, by configuring the CC4yPSC and CC4yFPC registers.<br />
<br />
The prescaler divider may only be programmed after the prescaler run bit has been cleared by calling <a class="el" href="group___c_c_u4.html#gae3741bc9dc0cb9f565ade9182d73141f">XMC_CCU4_StopPrescaler()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga989c0d32380efe2053c259ff4e7d3c78">XMC_CCU4_SLICE_SetFloatingPrescalerCompareValue()</a>. </dd></dl>

</div>
</div>
<a id="ga8631a666973bd4471bb80d8f08ae99cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8631a666973bd4471bb80d8f08ae99cd">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_SetShadowTransferMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_SetShadowTransferMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga6b7d3d96e6ba78dd55ca0850379ebf9d">XMC_CCU4_SLICE_SHADOW_TRANSFER_MODE_t</a>&#160;</td>
          <td class="paramname"><em>shadow_transfer_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">shadow_transfer_mode</td><td>mode to be configured Use :: XMC_CCU4_SLICE_SHADOW_TRANSFER_MODE_t enum items for mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures when the shadow transfer has to occur, by setting STM bit in STC register.<br />
<br />
 After requesting for shadow transfer mode using <a class="el" href="group___c_c_u4.html#gadcfbaa660e4c008e78128b8deb4cc5c1">XMC_CCU4_EnableShadowTransfer()</a>, actual transfer occurs based on the selection done using this API (i.e. on period and One match, on Period match only, on One match only).</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>This is effective when the timer is configured in centre aligned mode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gadcfbaa660e4c008e78128b8deb4cc5c1">XMC_CCU4_EnableShadowTransfer()</a><br />
 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="ga7ae1adcaba614fa7d919221da9020a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ae1adcaba614fa7d919221da9020a57">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_SetTimerCompareMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_SetTimerCompareMatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>compare_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">compare_val</td><td>Timer compare value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Programs the timer compare value, by writing CC4yCRS register.<br />
<br />
 The PWM duty cycle is determined by this value. The compare value is written to a shadow register. Explicitly enable the shadow transfer for the the period/compare value by calling <a class="el" href="group___c_c_u4.html#gadcfbaa660e4c008e78128b8deb4cc5c1">XMC_CCU4_EnableShadowTransfer()</a> with appropriate mask.If shadow transfer is enabled and the timer is running, a period match transfers the value from the shadow register to the actual compare register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga33f030851ea5f6abc4d7e1ecd7de2906">XMC_CCU4_SLICE_GetTimerPeriodMatch()</a>. </dd></dl>

</div>
</div>
<a id="ga35b25352390bfa747b51ba511fe85c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35b25352390bfa747b51ba511fe85c57">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_SetTimerCountingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_SetTimerCountingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga488780142d4d7da249cbb6e2c16ec512">XMC_CCU4_SLICE_TIMER_COUNT_MODE_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">mode</td><td>Desired counting mode (Either Edge Aligned or Center Aligned) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the timer counting mode either Edge Aligned or Center Aligned, by configuring CC4yTC.TCM bit.<br />
<br />
In the edge aligned mode, the timer counts from 0 to the terminal count. Once the timer count has reached a preset compare value, the timer status output asserts itself. It will now deassert only after the timer count reaches the terminal count.<br />
 In the center aligned mode, the timer first counts from 0 to the terminal count and then back to 0. During this upward and downward counting, the timer status output stays asserted as long as the timer value is greater than the compare value.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gac330a353060ff06f84d2d9835716ea94">XMC_CCU4_SLICE_GetTimerCountingMode()</a>. </dd></dl>

</div>
</div>
<a id="ga1341abfd52a8165c7e1b5292033797ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1341abfd52a8165c7e1b5292033797ed">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_SetTimerPeriodMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_SetTimerPeriodMatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>period_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">period_val</td><td>Timer period value Range: [0x0 to 0xFFFF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Programs the timer period, by writing CC4yPRS register.<br />
<br />
The frequency of counting/ PWM frequency is determined by this value. The period value is written to a shadow register. Explicitly enable the shadow transfer for the the period value by calling <a class="el" href="group___c_c_u4.html#gadcfbaa660e4c008e78128b8deb4cc5c1">XMC_CCU4_EnableShadowTransfer()</a> with appropriate mask. If shadow transfer is enabled and the timer is running, a period match transfers the value from the shadow register to the actual period register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga33f030851ea5f6abc4d7e1ecd7de2906">XMC_CCU4_SLICE_GetTimerPeriodMatch()</a>. </dd></dl>

</div>
</div>
<a id="gaaaceaa5953e0235db8f17592c3606aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaceaa5953e0235db8f17592c3606aff">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_SetTimerRepeatMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_SetTimerRepeatMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga85c8c78c8c4ec52eae3d4654aa37ad9d">XMC_CCU4_SLICE_TIMER_REPEAT_MODE_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">mode</td><td>Desired repetition mode (Either single shot or Continuous) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the Timer to either Single shot mode or continuous mode, by configuring CC4yTC.TSSM bit.<br />
<br />
The timer will count up to the terminal count as specified in the period register and stops immediately if the repeat mode has been set to single shot. In the continuous mode of operation, the timer starts counting all over again after reaching the terminal count.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gad164d9989a251f651159323c718965f1">XMC_CCU4_SLICE_GetTimerRepeatMode()</a>. </dd></dl>

</div>
</div>
<a id="gad654c695ac03c9218657816e4468d835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad654c695ac03c9218657816e4468d835">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_SetTimerValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_SetTimerValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>timer_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">timer_val</td><td>The new timer value that has to be loaded into the TIMER register. Range: [0x0 to 0xFFFF] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Loads a new timer value, by setting CC4yTIMER register.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Request to load is ignored if the timer is running.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga9d9be217f287f53b1e96e929753acf41">XMC_CCU4_SLICE_GetTimerValue()</a>. </dd></dl>

</div>
</div>
<a id="gac029dc08c5d54be8e773df0de9641691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac029dc08c5d54be8e773df0de9641691">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_StartConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_StartConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#ga665528c9d6bedf104384b20797e892c3">XMC_CCU4_SLICE_START_MODE_t</a>&#160;</td>
          <td class="paramname"><em>start_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>Map an External event to the External Start Function </td></tr>
    <tr><td class="paramname">start_mode</td><td>Behavior of slice when the start function is activated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the Start Function of the slice, by configuring CC4yCMC.ENDS and CC4yTC.ENDM bits.<br />
<br />
 Start function is mapped with one of the 3 events. An external signal can control when a CC4 timer should start. Additionally, the behaviour of the slice upon activation of the start function is configured as well.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga17330b4b761f443140b1c736c1a09840">XMC_CCU4_SLICE_StopConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#ga6417b3f8823b6c76ec44118fc9c1eeb7">XMC_CCU4_SLICE_ConfigureEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>. </dd></dl>

</div>
</div>
<a id="ga9997bb59706a4034e3e3be33a4935a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9997bb59706a4034e3e3be33a4935a7c">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_StartTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_StartTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Starts the timer counting operation, by setting CC4yTCSET.TRBS bit.<br />
<br />
It is necessary to have configured the CC4 slice before starting its timer. Before the Timer is started ensure that the clock is provided to the slice.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gac41eed8d2857f7c9d23567fa742a705c">XMC_CCU4_SLICE_StopTimer()</a>. </dd></dl>

</div>
</div>
<a id="ga8f1ff68c2bae61d72c539684a050553b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f1ff68c2bae61d72c539684a050553b">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_StatusBitOverrideConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_StatusBitOverrideConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the status bit override Function of the slice, by configuring CC4yCMC.OFS bit.<br />
<br />
Status bit override function is mapped with one of the 3 events. A slice can be configured to change the output of the timer's CC4yST signal depending on an external signal.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga0b084822487e0ca0a4a950c7d0f36fa7">XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent()</a>. </dd></dl>

</div>
</div>
<a id="ga9bd3401eb3b8744163b730998e5e3f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bd3401eb3b8744163b730998e5e3f7a">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_StopClearTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_StopClearTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Stops and resets the timer count to zero, by setting CC4yTCCLR.TCC and CC4yTCCLR.TRBC bit.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga9997bb59706a4034e3e3be33a4935a7c">XMC_CCU4_SLICE_StartTimer()</a>. </dd></dl>

</div>
</div>
<a id="ga17330b4b761f443140b1c736c1a09840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17330b4b761f443140b1c736c1a09840">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_StopConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_StopConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gacc266caa550eca30994d968fa3b82b94">XMC_CCU4_SLICE_EVENT_t</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gaed08e3fd07e061ccb45377415a958c6a">XMC_CCU4_SLICE_END_MODE_t</a>&#160;</td>
          <td class="paramname"><em>end_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">event</td><td>Map an External event to the External Stop Function </td></tr>
    <tr><td class="paramname">end_mode</td><td>Behavior of slice when the stop function is activated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the Stop function for the slice, by configuring CC4yCMC.STRTS and CC4yTC.STRM bits.<br />
<br />
Stop function is mapped with one of the 3 events. An external signal can control when a CCU4 timer should stop. Additionally, the behaviour of the slice upon activation of the stop function is configured as well.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gac029dc08c5d54be8e773df0de9641691">XMC_CCU4_SLICE_StartConfig()</a><br />
 <a class="el" href="group___c_c_u4.html#ga6417b3f8823b6c76ec44118fc9c1eeb7">XMC_CCU4_SLICE_ConfigureEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>. </dd></dl>

</div>
</div>
<a id="gac41eed8d2857f7c9d23567fa742a705c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac41eed8d2857f7c9d23567fa742a705c">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_StopTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_StopTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Stops the Timer.<br />
<br />
Timer counting operation can be stopped by invoking this API, by setting CC4yTCCLR.TRBC bit.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga9997bb59706a4034e3e3be33a4935a7c">XMC_CCU4_SLICE_StartTimer()</a>. </dd></dl>

</div>
</div>
<a id="gab2d5615177cfa2f20c5f5655400f4a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2d5615177cfa2f20c5f5655400f4a8e">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_TrapConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_TrapConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_c_u4.html#gafc3c6b390f18574d954473174a595eb2">XMC_CCU4_SLICE_TRAP_EXIT_MODE_t</a>&#160;</td>
          <td class="paramname"><em>exit_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>synch_with_pwm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">exit_mode</td><td>How should a previously logged trap state be exited? </td></tr>
    <tr><td class="paramname">synch_with_pwm</td><td>Should exit of trap state be synchronized with PWM cycle start? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the Trap Function of the slice, by configuring CC4yCMC.TS, CC4yTC.TRPSE, and CC4yTC.TRPSW bits.<br />
<br />
Trap function is mapped with Event-2. Criteria for exiting the trap state is configured. This trap function allows PWM outputs to react on the state of an input pin. Thus PWM output can be forced to inactive state upon detection of a trap. It is also possible to synchronize the trap function with the PWM signal using the <b>synch_with_pwm</b>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga6417b3f8823b6c76ec44118fc9c1eeb7">XMC_CCU4_SLICE_ConfigureEvent()</a><br />
 <a class="el" href="group___c_c_u4.html#ga28e214514acb1a75a67de63e6d74b167">XMC_CCU4_SLICE_SetInput()</a>. </dd></dl>

</div>
</div>
<a id="ga416ddf2d93e243f85ecbf5b087b4672f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga416ddf2d93e243f85ecbf5b087b4672f">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_WriteCoherentlyWithPWMCycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_WriteCoherentlyWithPWMCycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>coherent_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">coherent_write</td><td>specifies for what fields this mode has to be applied Use :: XMC_CCU4_SLICE_WRITE_INTO_t enum items to create a mask of choice, using a bit wise OR operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the specified fields shadow value to be updated in synchronous with PWM after shadow transfer request, by clearing IRPC, IRCC1, IRCC2, IRLC, IRDC, IRFC bits in STC register.<br />
<br />
 When coherent shadow is enabled, after calling <a class="el" href="group___c_c_u4.html#gadcfbaa660e4c008e78128b8deb4cc5c1">XMC_CCU4_EnableShadowTransfer()</a>, the value which are written in the respective shadow registers get updated according the configuration done using <a class="el" href="group___c_c_u4.html#ga8631a666973bd4471bb80d8f08ae99cd">XMC_CCU4_SLICE_SetShadowTransferMode()</a> API. </dd></dl>
<dl class="section user"><dt>Note:</dt><dd></dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gadcfbaa660e4c008e78128b8deb4cc5c1">XMC_CCU4_EnableShadowTransfer()</a>, <a class="el" href="group___c_c_u4.html#ga8631a666973bd4471bb80d8f08ae99cd">XMC_CCU4_SLICE_SetShadowTransferMode()</a><br />
 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="ga5048bfa6fbbcc4752d137f32c141743c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5048bfa6fbbcc4752d137f32c141743c">&#9670;&nbsp;</a></span>XMC_CCU4_SLICE_WriteImmediateAfterShadowTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_SLICE_WriteImmediateAfterShadowTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#ga759d9cc26009d3567612d196ac3f3969">XMC_CCU4_SLICE_t</a> *const&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>immediate_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>Constant pointer to CC4 Slice </td></tr>
    <tr><td class="paramname">immediate_write</td><td>specifies for what fields this mode has to be applied Use :: XMC_CCU4_SLICE_WRITE_INTO_t enum items to create a mask of choice, using a bit wise OR operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the specified fields shadow value to be updated immediately after shadow transfer request, by setting IRPC, IRCC1, IRCC2, IRLC, IRDC, IRFC bits in STC register.<br />
<br />
 When immediate shadow is enabled, by calling <a class="el" href="group___c_c_u4.html#gadcfbaa660e4c008e78128b8deb4cc5c1">XMC_CCU4_EnableShadowTransfer()</a> the value which are written in the shadow registers get updated to the actual registers immediately. </dd></dl>
<dl class="section user"><dt>Note:</dt><dd></dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#gadcfbaa660e4c008e78128b8deb4cc5c1">XMC_CCU4_EnableShadowTransfer()</a><br />
 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available for XMC1400 series </dd></dl>

</div>
</div>
<a id="gad492e0c49bfa5b89b01d6dd5a43a1e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad492e0c49bfa5b89b01d6dd5a43a1e1b">&#9670;&nbsp;</a></span>XMC_CCU4_StartPrescaler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_StartPrescaler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>Constant pointer to CCU4 module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Starts the prescaler and restores clocks to the timer slices, by setting GIDLC.SPRB bit.<br />
<br />
 Once the input to the prescaler has been chosen and the prescaler divider of all slices programmed, the prescaler itself may be started. Invoke this API after <a class="el" href="group___c_c_u4.html#ga6ab30100f7e86a8f47095282a123d071">XMC_CCU4_Init()</a> (Mandatory to fully initialize the module).Directly accessed register is GIDLC.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga6ab30100f7e86a8f47095282a123d071">XMC_CCU4_Init()</a><br />
 <a class="el" href="group___c_c_u4.html#ga1809347868d61b8627442802601fb863">XMC_CCU4_EnableClock()</a><br />
 <a class="el" href="group___c_c_u4.html#ga58ad9c171f730ad379f349aac4e78009">XMC_CCU4_DisableClock()</a><br />
 <a class="el" href="group___c_c_u4.html#gad492e0c49bfa5b89b01d6dd5a43a1e1b">XMC_CCU4_StartPrescaler()</a><br />
 <a class="el" href="group___c_c_u4.html#gae3741bc9dc0cb9f565ade9182d73141f">XMC_CCU4_StopPrescaler()</a>. </dd></dl>

</div>
</div>
<a id="gae3741bc9dc0cb9f565ade9182d73141f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3741bc9dc0cb9f565ade9182d73141f">&#9670;&nbsp;</a></span>XMC_CCU4_StopPrescaler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_CCU4_StopPrescaler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_c_u4.html#gabc8c277fccba02adfd4c57fdbf66df71">XMC_CCU4_MODULE_t</a> *const&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>Constant pointer to CCU4 module </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Stops the prescaler and blocks clocks to the timer slices, by setting GIDLS.CPRB bit.<br />
<br />
Opposite of the StartPrescaler routine. Clears the run bit of the prescaler. Ensures that the module clock is not supplied to the slices of the module.Registers directly accessed is GIDLS.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_c_u4.html#ga1809347868d61b8627442802601fb863">XMC_CCU4_EnableClock()</a><br />
 <a class="el" href="group___c_c_u4.html#ga58ad9c171f730ad379f349aac4e78009">XMC_CCU4_DisableClock()</a><br />
 <a class="el" href="group___c_c_u4.html#gad492e0c49bfa5b89b01d6dd5a43a1e1b">XMC_CCU4_StartPrescaler()</a><br />
 <a class="el" href="group___c_c_u4.html#gae3741bc9dc0cb9f565ade9182d73141f">XMC_CCU4_StopPrescaler()</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 15 2020 05:49:22 for XMC Peripheral Library for XMC4000 Family by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
