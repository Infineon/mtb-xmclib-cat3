<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XMC Peripheral Library for XMC4000 Family: High Resolution PWM Unit (HRPWM)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC4000 Family</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___h_r_p_w_m.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">High Resolution PWM Unit (HRPWM)</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___c_m_p__t.html">XMC_HRPWM_CSG_CMP_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___d_a_c__t.html">XMC_HRPWM_CSG_DAC_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___i_n_p_u_t___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_INPUT_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___s_g_e_n__t.html">XMC_HRPWM_CSG_SGEN_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___h_r_p_w_m___h_r_c___c_o_n_f_i_g__t.html">XMC_HRPWM_HRC_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___h_r_p_w_m___h_r_c___s_r_c___c_o_n_f_i_g__t.html">XMC_HRPWM_HRC_SRC_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga3acaa9244c28bd19d7c2bff6764edfec"><td class="memItemLeft" align="right" valign="top">typedef HRPWM0_CSG_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a></td></tr>
<tr class="separator:ga3acaa9244c28bd19d7c2bff6764edfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a5ed62e672427731f694ea08a9e32b4"><td class="memItemLeft" align="right" valign="top">typedef HRPWM0_HRC_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a></td></tr>
<tr class="separator:ga1a5ed62e672427731f694ea08a9e32b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45de914982446332346b0ed2e298a464"><td class="memItemLeft" align="right" valign="top">typedef HRPWM0_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a></td></tr>
<tr class="separator:ga45de914982446332346b0ed2e298a464"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5cd683d357b3e616029c499dbde6ff5d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga5cd683d357b3e616029c499dbde6ff5d">XMC_HRPWM_CLK_FREQ_t</a> </td></tr>
<tr class="separator:ga5cd683d357b3e616029c499dbde6ff5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa330fc9a084b311a86fc3dd42e0eccce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gaa330fc9a084b311a86fc3dd42e0eccce">XMC_HRPWM_CSG_CLK_INPUT_t</a> </td></tr>
<tr class="separator:gaa330fc9a084b311a86fc3dd42e0eccce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf65bccdc3328dbd26b681fb5d0304c4d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gaf65bccdc3328dbd26b681fb5d0304c4d">XMC_HRPWM_CSG_CLK_t</a> </td></tr>
<tr class="separator:gaf65bccdc3328dbd26b681fb5d0304c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd4884f6c1a92640cfc91ea62556f47"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga7bd4884f6c1a92640cfc91ea62556f47">XMC_HRPWM_CSG_CMP_FILTER_WINDOW_t</a> </td></tr>
<tr class="separator:ga7bd4884f6c1a92640cfc91ea62556f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5da5acbc4ffb20968d49a8b9c3a0f3c5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga5da5acbc4ffb20968d49a8b9c3a0f3c5">XMC_HRPWM_CSG_CMP_INPUT_t</a> </td></tr>
<tr class="separator:ga5da5acbc4ffb20968d49a8b9c3a0f3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc3a43d988fe0e66e4d4d8d85756676a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gabc3a43d988fe0e66e4d4d8d85756676a">XMC_HRPWM_CSG_CMP_INVERTING_INPUT_t</a> </td></tr>
<tr class="separator:gabc3a43d988fe0e66e4d4d8d85756676a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2717581e740ad6f1dd2ad44db0674d9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gab2717581e740ad6f1dd2ad44db0674d9">XMC_HRPWM_CSG_EDGE_SEL_t</a> </td></tr>
<tr class="separator:gab2717581e740ad6f1dd2ad44db0674d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37b76dfd8cf0debb56c2534914fb405c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga37b76dfd8cf0debb56c2534914fb405c">XMC_HRPWM_CSG_INPUT_SEL_t</a> </td></tr>
<tr class="separator:ga37b76dfd8cf0debb56c2534914fb405c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga436f2a6ad7ee2320f30163997c9d8cd4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga436f2a6ad7ee2320f30163997c9d8cd4">XMC_HRPWM_CSG_IRQ_ID_t</a> </td></tr>
<tr class="separator:ga436f2a6ad7ee2320f30163997c9d8cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74fab5ae35406664bf3be96687597b13"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga74fab5ae35406664bf3be96687597b13">XMC_HRPWM_CSG_IRQ_SR_LINE_t</a> </td></tr>
<tr class="separator:ga74fab5ae35406664bf3be96687597b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1274dea1f81c40a35649162cd449b81"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gae1274dea1f81c40a35649162cd449b81">XMC_HRPWM_CSG_LVL_SEL_t</a> </td></tr>
<tr class="separator:gae1274dea1f81c40a35649162cd449b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa200a6a7a4cbfb74537076c89a7aa4be"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gaa200a6a7a4cbfb74537076c89a7aa4be">XMC_HRPWM_CSG_POWER_MODE_t</a> </td></tr>
<tr class="separator:gaa200a6a7a4cbfb74537076c89a7aa4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60a76ed4786b9f2f83a6e55ab840b220"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga60a76ed4786b9f2f83a6e55ab840b220">XMC_HRPWM_CSG_PRESCALER_CLR_t</a> </td></tr>
<tr class="separator:ga60a76ed4786b9f2f83a6e55ab840b220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga667011f4c74780559bac6963d2774553"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga667011f4c74780559bac6963d2774553">XMC_HRPWM_CSG_PRESCALER_DIVISION_t</a> </td></tr>
<tr class="separator:ga667011f4c74780559bac6963d2774553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga627a4aaf52c1bda8cf8ce7039763af93"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga627a4aaf52c1bda8cf8ce7039763af93">XMC_HRPWM_CSG_PRESCALER_EXT_START_t</a> </td></tr>
<tr class="separator:ga627a4aaf52c1bda8cf8ce7039763af93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dfa4483749fda4b6e87ec6f1ac44a54"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga9dfa4483749fda4b6e87ec6f1ac44a54">XMC_HRPWM_CSG_PRESCALER_EXT_STOP_t</a> </td></tr>
<tr class="separator:ga9dfa4483749fda4b6e87ec6f1ac44a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2afbc1fbd9f9004061420fea8603b67"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gac2afbc1fbd9f9004061420fea8603b67">XMC_HRPWM_CSG_PRESCALER_START_t</a> </td></tr>
<tr class="separator:gac2afbc1fbd9f9004061420fea8603b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb53cbfc6388b50d5708abf4652823e5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gacb53cbfc6388b50d5708abf4652823e5">XMC_HRPWM_CSG_PRESCALER_STATUS_t</a> </td></tr>
<tr class="separator:gacb53cbfc6388b50d5708abf4652823e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd216b6c73d586c8c407965d3a5288ca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gacd216b6c73d586c8c407965d3a5288ca">XMC_HRPWM_CSG_PRESCALER_STOP_t</a> </td></tr>
<tr class="separator:gacd216b6c73d586c8c407965d3a5288ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f5cb84356dd14d33e4172435a921082"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga8f5cb84356dd14d33e4172435a921082">XMC_HRPWM_CSG_RUN_BIT_t</a> </td></tr>
<tr class="separator:ga8f5cb84356dd14d33e4172435a921082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f816529f1530081745540ca81fa808b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga4f816529f1530081745540ca81fa808b">XMC_HRPWM_CSG_SLICE_t</a> </td></tr>
<tr class="separator:ga4f816529f1530081745540ca81fa808b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2155fcd8e21549783e868c3962d63965"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga2155fcd8e21549783e868c3962d63965">XMC_HRPWM_CSG_SLOPE_CTRL_MODE_t</a> </td></tr>
<tr class="separator:ga2155fcd8e21549783e868c3962d63965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e2831acbfa421bc6ee4d92305afa7d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga60e2831acbfa421bc6ee4d92305afa7d">XMC_HRPWM_CSG_SLOPE_EXT_START_t</a> </td></tr>
<tr class="separator:ga60e2831acbfa421bc6ee4d92305afa7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1d906442d8114ef2b5019f3933694dd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gab1d906442d8114ef2b5019f3933694dd">XMC_HRPWM_CSG_SLOPE_EXT_STOP_t</a> </td></tr>
<tr class="separator:gab1d906442d8114ef2b5019f3933694dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1291723b296aeacb9832915604baebaa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga1291723b296aeacb9832915604baebaa">XMC_HRPWM_CSG_SLOPE_START_t</a> </td></tr>
<tr class="separator:ga1291723b296aeacb9832915604baebaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbfe1cccf9f90e5f91d492c67907ba3a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gafbfe1cccf9f90e5f91d492c67907ba3a">XMC_HRPWM_CSG_SLOPE_STEP_GAIN_t</a> </td></tr>
<tr class="separator:gafbfe1cccf9f90e5f91d492c67907ba3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab291d73c3f778be105bdd3f582e2756e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gab291d73c3f778be105bdd3f582e2756e">XMC_HRPWM_CSG_SLOPE_STOP_t</a> </td></tr>
<tr class="separator:gab291d73c3f778be105bdd3f582e2756e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga551133de6601253b0f9bf43fc9772f15"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga551133de6601253b0f9bf43fc9772f15">XMC_HRPWM_CSG_SWITCH_CMP_INPUT_t</a> </td></tr>
<tr class="separator:ga551133de6601253b0f9bf43fc9772f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfaa9ad3d5d14d786ac920e411b1a4ce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gadfaa9ad3d5d14d786ac920e411b1a4ce">XMC_HRPWM_CSG_SWSM_t</a> </td></tr>
<tr class="separator:gadfaa9ad3d5d14d786ac920e411b1a4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacab1ecd6e6319fac1fd6b005d9ee79bd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gacab1ecd6e6319fac1fd6b005d9ee79bd">XMC_HRPWM_DAC_SLOPE_GEN_STATUS_t</a> </td></tr>
<tr class="separator:gacab1ecd6e6319fac1fd6b005d9ee79bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92348e75fa87c899d8e1e42b17ade149"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga92348e75fa87c899d8e1e42b17ade149">XMC_HRPWM_FUNC_STATUS_t</a> </td></tr>
<tr class="separator:ga92348e75fa87c899d8e1e42b17ade149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfc15f0691fb89b0cfecc46a8422a39c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gadfc15f0691fb89b0cfecc46a8422a39c">XMC_HRPWM_HR_LOGIC_t</a> </td></tr>
<tr class="separator:gadfc15f0691fb89b0cfecc46a8422a39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc779de5e6350ba1fffe4a4de2e5bfba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gacc779de5e6350ba1fffe4a4de2e5bfba">XMC_HRPWM_HR_PATH_t</a> </td></tr>
<tr class="separator:gacc779de5e6350ba1fffe4a4de2e5bfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac26495c9b452d11e893e55a996d1cdd2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gac26495c9b452d11e893e55a996d1cdd2">XMC_HRPWM_HRC_CMP_SEL_t</a> </td></tr>
<tr class="separator:gac26495c9b452d11e893e55a996d1cdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184f2491fe7a58b2e674dbda3d73117a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga184f2491fe7a58b2e674dbda3d73117a">XMC_HRPWM_HRC_DT_TR_SEL_t</a> </td></tr>
<tr class="separator:ga184f2491fe7a58b2e674dbda3d73117a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16f08ec4aff668ebdebfd70a349cbd1f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga16f08ec4aff668ebdebfd70a349cbd1f">XMC_HRPWM_HRC_HR_EDGE_t</a> </td></tr>
<tr class="separator:ga16f08ec4aff668ebdebfd70a349cbd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eb1fabdd95cf5e09fcb2d5eb8d52b9a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga6eb1fabdd95cf5e09fcb2d5eb8d52b9a">XMC_HRPWM_HRC_OUT_PASSIVE_LVL_t</a> </td></tr>
<tr class="separator:ga6eb1fabdd95cf5e09fcb2d5eb8d52b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1430f4a0749968e47a744fc40009384b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga1430f4a0749968e47a744fc40009384b">XMC_HRPWM_HRC_SHADOW_TX_t</a> </td></tr>
<tr class="separator:ga1430f4a0749968e47a744fc40009384b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga723536b1c6bed71c7369defade462741"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga723536b1c6bed71c7369defade462741">XMC_HRPWM_HRC_SOURCE_t</a> </td></tr>
<tr class="separator:ga723536b1c6bed71c7369defade462741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga898488583126f170c29de20ad78e7f96"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga898488583126f170c29de20ad78e7f96">XMC_HRPWM_HRC_SRC_EDGE_SEL_t</a> </td></tr>
<tr class="separator:ga898488583126f170c29de20ad78e7f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab18b9caec75ff8940a250d265706f3c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gaab18b9caec75ff8940a250d265706f3c">XMC_HRPWM_HRC_SRC_INPUT_t</a> </td></tr>
<tr class="separator:gaab18b9caec75ff8940a250d265706f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0bbc6eaf0460ede1b5331a0ddb8d23b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gae0bbc6eaf0460ede1b5331a0ddb8d23b">XMC_HRPWM_HRC_TIMER_SEL_t</a> </td></tr>
<tr class="separator:gae0bbc6eaf0460ede1b5331a0ddb8d23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga672aedcae59032f2f63c9096b6bb4c46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga672aedcae59032f2f63c9096b6bb4c46">XMC_HRPWM_SHADOW_TX_DAC_t</a> </td></tr>
<tr class="separator:ga672aedcae59032f2f63c9096b6bb4c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebcd5453412b9ad26fd5ead0b712a377"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gaebcd5453412b9ad26fd5ead0b712a377">XMC_HRPWM_STATUS_t</a> </td></tr>
<tr class="separator:gaebcd5453412b9ad26fd5ead0b712a377"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf3a5ac7570e49d783ed75a12cdf88f78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gaf3a5ac7570e49d783ed75a12cdf88f78">XMC_HRPWM_ClampComparatorOutput</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:gaf3a5ac7570e49d783ed75a12cdf88f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf357ce24027e53b8b4193ee77ca59455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gaf357ce24027e53b8b4193ee77ca59455">XMC_HRPWM_ClearPreScaler</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:gaf357ce24027e53b8b4193ee77ca59455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40d3c775623a29d040dedd36396f0d93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga40d3c775623a29d040dedd36396f0d93">XMC_HRPWM_CSG_ClrEventSW</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, <a class="el" href="group___h_r_p_w_m.html#ga436f2a6ad7ee2320f30163997c9d8cd4">XMC_HRPWM_CSG_IRQ_ID_t</a> event)</td></tr>
<tr class="separator:ga40d3c775623a29d040dedd36396f0d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga273e4eb2aa12fbcc959aa6ab5e69ea2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga273e4eb2aa12fbcc959aa6ab5e69ea2a">XMC_HRPWM_CSG_DACRefValSwitchingConfig</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, const <a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___i_n_p_u_t___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_INPUT_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga273e4eb2aa12fbcc959aa6ab5e69ea2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c677e919aaf2c8fb77665abc0151eb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga0c677e919aaf2c8fb77665abc0151eb8">XMC_HRPWM_CSG_DisableEvent</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, <a class="el" href="group___h_r_p_w_m.html#ga436f2a6ad7ee2320f30163997c9d8cd4">XMC_HRPWM_CSG_IRQ_ID_t</a> event)</td></tr>
<tr class="separator:ga0c677e919aaf2c8fb77665abc0151eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f88106af0b4f60104671a8b83fa9a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga9f88106af0b4f60104671a8b83fa9a22">XMC_HRPWM_CSG_EnableEvent</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, <a class="el" href="group___h_r_p_w_m.html#ga436f2a6ad7ee2320f30163997c9d8cd4">XMC_HRPWM_CSG_IRQ_ID_t</a> event)</td></tr>
<tr class="separator:ga9f88106af0b4f60104671a8b83fa9a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60db4fb03cc3b1e408176c256b76a054"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga60db4fb03cc3b1e408176c256b76a054">XMC_HRPWM_CSG_GetEventStatus</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, const uint32_t mask)</td></tr>
<tr class="separator:ga60db4fb03cc3b1e408176c256b76a054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83cd1efa3726db819166c61f6604fbf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga83cd1efa3726db819166c61f6604fbf0">XMC_HRPWM_CSG_Init</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, const <a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga83cd1efa3726db819166c61f6604fbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f6e3566f854fe75f9fb50e39b37a43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga78f6e3566f854fe75f9fb50e39b37a43">XMC_HRPWM_CSG_SelBlankingInput</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, const <a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___i_n_p_u_t___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_INPUT_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga78f6e3566f854fe75f9fb50e39b37a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03b62754415e1b809501ebac0c3a7fa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga03b62754415e1b809501ebac0c3a7fa1">XMC_HRPWM_CSG_SelClampingInput</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, const <a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___i_n_p_u_t___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_INPUT_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga03b62754415e1b809501ebac0c3a7fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6158089646f9e247a10868f690da809c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga6158089646f9e247a10868f690da809c">XMC_HRPWM_CSG_SelSlopeGenClkInput</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, const <a class="el" href="group___h_r_p_w_m.html#gaa330fc9a084b311a86fc3dd42e0eccce">XMC_HRPWM_CSG_CLK_INPUT_t</a> input_clk)</td></tr>
<tr class="separator:ga6158089646f9e247a10868f690da809c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga805831cc2749a83373f6d0b0006bac38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga805831cc2749a83373f6d0b0006bac38">XMC_HRPWM_CSG_SetCMPInput</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, const <a class="el" href="group___h_r_p_w_m.html#ga5da5acbc4ffb20968d49a8b9c3a0f3c5">XMC_HRPWM_CSG_CMP_INPUT_t</a> input)</td></tr>
<tr class="separator:ga805831cc2749a83373f6d0b0006bac38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga394b6ac2f679d704cedad3c2c101825b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga394b6ac2f679d704cedad3c2c101825b">XMC_HRPWM_CSG_SetEventSW</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, <a class="el" href="group___h_r_p_w_m.html#ga436f2a6ad7ee2320f30163997c9d8cd4">XMC_HRPWM_CSG_IRQ_ID_t</a> event)</td></tr>
<tr class="separator:ga394b6ac2f679d704cedad3c2c101825b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8521d4a0084ae0f6b40c123766001508"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga8521d4a0084ae0f6b40c123766001508">XMC_HRPWM_CSG_SetSRNode</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, const <a class="el" href="group___h_r_p_w_m.html#ga436f2a6ad7ee2320f30163997c9d8cd4">XMC_HRPWM_CSG_IRQ_ID_t</a> event, const <a class="el" href="group___h_r_p_w_m.html#ga74fab5ae35406664bf3be96687597b13">XMC_HRPWM_CSG_IRQ_SR_LINE_t</a> sr)</td></tr>
<tr class="separator:ga8521d4a0084ae0f6b40c123766001508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb0c65380f210e989267c42099b28b56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gadb0c65380f210e989267c42099b28b56">XMC_HRPWM_CSG_StartSlopeGenConfig</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, const <a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___i_n_p_u_t___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_INPUT_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:gadb0c65380f210e989267c42099b28b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7da6d834d100038306930f455459d17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gaa7da6d834d100038306930f455459d17">XMC_HRPWM_CSG_StopSlopeGenConfig</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, const <a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___i_n_p_u_t___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_INPUT_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:gaa7da6d834d100038306930f455459d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cf121ecbb1cd7332e49b82ffe2f972b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga4cf121ecbb1cd7332e49b82ffe2f972b">XMC_HRPWM_CSG_TriggerDACConvConfig</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, const <a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___i_n_p_u_t___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_INPUT_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga4cf121ecbb1cd7332e49b82ffe2f972b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad6ba2cd0b1ce2b037b1d54435ea214c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gaad6ba2cd0b1ce2b037b1d54435ea214c">XMC_HRPWM_CSG_TriggerShadowXferConfig</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, const <a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___i_n_p_u_t___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_INPUT_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:gaad6ba2cd0b1ce2b037b1d54435ea214c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bb9d294b29b27fcf713f23da951c116"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga9bb9d294b29b27fcf713f23da951c116">XMC_HRPWM_CSG_UpdateBlankingValue</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, uint8_t value)</td></tr>
<tr class="separator:ga9bb9d294b29b27fcf713f23da951c116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9667846d88cec6c51618bf2d239f5a8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga9667846d88cec6c51618bf2d239f5a8c">XMC_HRPWM_CSG_UpdateDACPrescaler</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, <a class="el" href="group___h_r_p_w_m.html#ga667011f4c74780559bac6963d2774553">XMC_HRPWM_CSG_PRESCALER_DIVISION_t</a> div_value)</td></tr>
<tr class="separator:ga9667846d88cec6c51618bf2d239f5a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08079e3c838977218a439da7476c16d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga08079e3c838977218a439da7476c16d8">XMC_HRPWM_CSG_UpdateDACRefDSV1</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, uint32_t value)</td></tr>
<tr class="separator:ga08079e3c838977218a439da7476c16d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c3541e919f14b6a7c58d22c39bbbcd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga0c3541e919f14b6a7c58d22c39bbbcd6">XMC_HRPWM_CSG_UpdateDACRefDSV2</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, uint32_t value)</td></tr>
<tr class="separator:ga0c3541e919f14b6a7c58d22c39bbbcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33d76f330edc72e2604b3d92c1e67628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga33d76f330edc72e2604b3d92c1e67628">XMC_HRPWM_CSG_UpdateDACStepGain</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, <a class="el" href="group___h_r_p_w_m.html#gafbfe1cccf9f90e5f91d492c67907ba3a">XMC_HRPWM_CSG_SLOPE_STEP_GAIN_t</a> gain)</td></tr>
<tr class="separator:ga33d76f330edc72e2604b3d92c1e67628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9841d1826a3ee415c1feee990c341f65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga9841d1826a3ee415c1feee990c341f65">XMC_HRPWM_CSG_UpdateFilterWindow</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, <a class="el" href="group___h_r_p_w_m.html#ga7bd4884f6c1a92640cfc91ea62556f47">XMC_HRPWM_CSG_CMP_FILTER_WINDOW_t</a> window)</td></tr>
<tr class="separator:ga9841d1826a3ee415c1feee990c341f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga464b5b593e11eaa98fb82827ee014a46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga464b5b593e11eaa98fb82827ee014a46">XMC_HRPWM_CSG_UpdatePulseClk</a> (<a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const csg, uint32_t value)</td></tr>
<tr class="separator:ga464b5b593e11eaa98fb82827ee014a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a85578ea5b24d2d2c697d17f182bf91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga3a85578ea5b24d2d2c697d17f182bf91">XMC_HRPWM_DisableBias</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm)</td></tr>
<tr class="separator:ga3a85578ea5b24d2d2c697d17f182bf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d9504e5573ab6ed0e2f1b07f67831d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga3d9504e5573ab6ed0e2f1b07f67831d6">XMC_HRPWM_DisableComparatorShadowTransfer</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, uint32_t mask)</td></tr>
<tr class="separator:ga3d9504e5573ab6ed0e2f1b07f67831d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54a7856ac4e8d8a68fb91a850cb727b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga54a7856ac4e8d8a68fb91a850cb727b2">XMC_HRPWM_DisableCsgClock</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:ga54a7856ac4e8d8a68fb91a850cb727b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65994066d50af817523e4bd23284073c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga65994066d50af817523e4bd23284073c">XMC_HRPWM_DisableGlobalHR</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm)</td></tr>
<tr class="separator:ga65994066d50af817523e4bd23284073c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b7cea1c88b33f35c15e928fc88d8d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gad5b7cea1c88b33f35c15e928fc88d8d5">XMC_HRPWM_DisableHighResolutionPath</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:gad5b7cea1c88b33f35c15e928fc88d8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4878a32203c629ac659aef582fc1a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga5a4878a32203c629ac659aef582fc1a1">XMC_HRPWM_DisableHighResolutionShadowTransfer</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:ga5a4878a32203c629ac659aef582fc1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06c6e822633e604ddab01f871bf25574"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga06c6e822633e604ddab01f871bf25574">XMC_HRPWM_DisableHRPowerMode</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm)</td></tr>
<tr class="separator:ga06c6e822633e604ddab01f871bf25574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b43ac44b227a27a44628b87b0e46f11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga7b43ac44b227a27a44628b87b0e46f11">XMC_HRPWM_DisableLowResolutionPath</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:ga7b43ac44b227a27a44628b87b0e46f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad10658881a91d3000301eff5df84ac17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gad10658881a91d3000301eff5df84ac17">XMC_HRPWM_EnableBias</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm)</td></tr>
<tr class="separator:gad10658881a91d3000301eff5df84ac17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad476f8353f1345158a0f55b3ccb4da98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gad476f8353f1345158a0f55b3ccb4da98">XMC_HRPWM_EnableComparatorShadowTransfer</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:gad476f8353f1345158a0f55b3ccb4da98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga061facdca6896f543e7a10ecc1eed696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga061facdca6896f543e7a10ecc1eed696">XMC_HRPWM_EnableGlobalHR</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm)</td></tr>
<tr class="separator:ga061facdca6896f543e7a10ecc1eed696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b02902e05248a345d3a75226ab2eb76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga6b02902e05248a345d3a75226ab2eb76">XMC_HRPWM_EnableHighResolutionPath</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:ga6b02902e05248a345d3a75226ab2eb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga445cb2483edf80fa5b1a8c6fd74948e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga445cb2483edf80fa5b1a8c6fd74948e0">XMC_HRPWM_EnableHighResolutionShadowTransfer</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:ga445cb2483edf80fa5b1a8c6fd74948e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabcf1cff107c2ae113407befb7b0412a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gaabcf1cff107c2ae113407befb7b0412a">XMC_HRPWM_EnableHRPowerMode</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm)</td></tr>
<tr class="separator:gaabcf1cff107c2ae113407befb7b0412a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf027dc9fd7d9c64c7316e2bc2874ebf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gaf027dc9fd7d9c64c7316e2bc2874ebf2">XMC_HRPWM_EnableLowResolutionPath</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:gaf027dc9fd7d9c64c7316e2bc2874ebf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad197514e3c3e7f409ea3b98422085be5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gad197514e3c3e7f409ea3b98422085be5">XMC_HRPWM_GetCMPInput</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:gad197514e3c3e7f409ea3b98422085be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d54d78a8f4e342eafed7040e2f9d43"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gac9d54d78a8f4e342eafed7040e2f9d43">XMC_HRPWM_GetComparatorShadowTransferStatus</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm)</td></tr>
<tr class="separator:gac9d54d78a8f4e342eafed7040e2f9d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80c1e83e5135d8548b33f4fba38d626b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga80c1e83e5135d8548b33f4fba38d626b">XMC_HRPWM_GetHighResolutionShadowTransferStatus</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:ga80c1e83e5135d8548b33f4fba38d626b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6a93e24f3e2668cb2a4e38e44f8f96e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_r_p_w_m.html#gadfc15f0691fb89b0cfecc46a8422a39c">XMC_HRPWM_HR_LOGIC_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gab6a93e24f3e2668cb2a4e38e44f8f96e">XMC_HRPWM_GetHRGenReadyStatus</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm)</td></tr>
<tr class="separator:gab6a93e24f3e2668cb2a4e38e44f8f96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa297fb77b955ee067b7665c6540876e2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gaa297fb77b955ee067b7665c6540876e2">XMC_HRPWM_GetRunBitStatus</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:gaa297fb77b955ee067b7665c6540876e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae373f3148dcac7511e56b5cc6dd98a09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gae373f3148dcac7511e56b5cc6dd98a09">XMC_HRPWM_HRC_ConfigSourceSelect0</a> (<a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a> *const hrc, const <a class="el" href="struct_x_m_c___h_r_p_w_m___h_r_c___s_r_c___c_o_n_f_i_g__t.html">XMC_HRPWM_HRC_SRC_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:gae373f3148dcac7511e56b5cc6dd98a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fd6d77ee95cee8a52216e17c86d6af4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga2fd6d77ee95cee8a52216e17c86d6af4">XMC_HRPWM_HRC_ConfigSourceSelect1</a> (<a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a> *const hrc, const <a class="el" href="struct_x_m_c___h_r_p_w_m___h_r_c___s_r_c___c_o_n_f_i_g__t.html">XMC_HRPWM_HRC_SRC_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga2fd6d77ee95cee8a52216e17c86d6af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a09b6807a5fd6f321eed7a8a970446"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga55a09b6807a5fd6f321eed7a8a970446">XMC_HRPWM_HRC_Init</a> (<a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a> *const hrc, const <a class="el" href="struct_x_m_c___h_r_p_w_m___h_r_c___c_o_n_f_i_g__t.html">XMC_HRPWM_HRC_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga55a09b6807a5fd6f321eed7a8a970446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga662c21ff0c66afdb96e049f45d6a67ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga662c21ff0c66afdb96e049f45d6a67ea">XMC_HRPWM_HRC_Set_HR_Source</a> (<a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a> *const hrc, <a class="el" href="group___h_r_p_w_m.html#ga723536b1c6bed71c7369defade462741">XMC_HRPWM_HRC_SOURCE_t</a> source)</td></tr>
<tr class="separator:ga662c21ff0c66afdb96e049f45d6a67ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35eaab412824cc2cc2a8521196e56d5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga35eaab412824cc2cc2a8521196e56d5c">XMC_HRPWM_HRC_SetCompare1</a> (<a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a> *const hrc, const uint8_t cr1_value)</td></tr>
<tr class="separator:ga35eaab412824cc2cc2a8521196e56d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a520049dd9aa004faaf0427435a75a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga9a520049dd9aa004faaf0427435a75a3">XMC_HRPWM_HRC_SetCompare2</a> (<a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a> *const hrc, const uint8_t cr2_value)</td></tr>
<tr class="separator:ga9a520049dd9aa004faaf0427435a75a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdfed01719f6ee374bb928e39d7b60c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gafdfed01719f6ee374bb928e39d7b60c3">XMC_HRPWM_HRC_SetDeadTimeFalling</a> (<a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a> *const hrc, uint16_t dcf_value)</td></tr>
<tr class="separator:gafdfed01719f6ee374bb928e39d7b60c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1ae69aff7172b27d30f03aaba531c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga0d1ae69aff7172b27d30f03aaba531c1">XMC_HRPWM_HRC_SetDeadTimeRising</a> (<a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a> *const hrc, uint16_t dcr_value)</td></tr>
<tr class="separator:ga0d1ae69aff7172b27d30f03aaba531c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87dbc2328d96a26fa55d35d9bfe853a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___h_r_p_w_m.html#gaebcd5453412b9ad26fd5ead0b712a377">XMC_HRPWM_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga87dbc2328d96a26fa55d35d9bfe853a8">XMC_HRPWM_Init</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm)</td></tr>
<tr class="separator:ga87dbc2328d96a26fa55d35d9bfe853a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e042c070a7387a6a751f5cb58d05a8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gaa2e042c070a7387a6a751f5cb58d05a8">XMC_HRPWM_IsComparatorClamped</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:gaa2e042c070a7387a6a751f5cb58d05a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b0bc4b90b8091d58d356cf21c091bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gaf3b0bc4b90b8091d58d356cf21c091bf">XMC_HRPWM_IsComparatorRunning</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:gaf3b0bc4b90b8091d58d356cf21c091bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56e64bc4f4e7af2ae753c045c0a9f62"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gab56e64bc4f4e7af2ae753c045c0a9f62">XMC_HRPWM_IsDacRunning</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:gab56e64bc4f4e7af2ae753c045c0a9f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eef87ede9768c817a6db40515146c6c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga9eef87ede9768c817a6db40515146c6c">XMC_HRPWM_IsPrescalerRunning</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:ga9eef87ede9768c817a6db40515146c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9948d05a763e18e8467ddc8363c051"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga6c9948d05a763e18e8467ddc8363c051">XMC_HRPWM_IsSlopeGenerationRunning</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:ga6c9948d05a763e18e8467ddc8363c051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga344cdb322dc26cea959f5d0129c0ece1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga344cdb322dc26cea959f5d0129c0ece1">XMC_HRPWM_ModuleClkFreq</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const <a class="el" href="group___h_r_p_w_m.html#ga5cd683d357b3e616029c499dbde6ff5d">XMC_HRPWM_CLK_FREQ_t</a> clk_freq)</td></tr>
<tr class="separator:ga344cdb322dc26cea959f5d0129c0ece1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfdb7f2f27dc19c46a80f4a14bf4a4ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gabfdb7f2f27dc19c46a80f4a14bf4a4ca">XMC_HRPWM_SetCsgPowerMode</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const <a class="el" href="group___h_r_p_w_m.html#ga4f816529f1530081745540ca81fa808b">XMC_HRPWM_CSG_SLICE_t</a> slice, const <a class="el" href="group___h_r_p_w_m.html#gaa200a6a7a4cbfb74537076c89a7aa4be">XMC_HRPWM_CSG_POWER_MODE_t</a> power_mode)</td></tr>
<tr class="separator:gabfdb7f2f27dc19c46a80f4a14bf4a4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04e267b78b1687f5718629b0677feb6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga04e267b78b1687f5718629b0677feb6f">XMC_HRPWM_StartComparator</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:ga04e267b78b1687f5718629b0677feb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbebb06d6614c718f7c79537910719aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gadbebb06d6614c718f7c79537910719aa">XMC_HRPWM_StartDac</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:gadbebb06d6614c718f7c79537910719aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c36905fafe437df01d4b049d4989962"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga5c36905fafe437df01d4b049d4989962">XMC_HRPWM_StartSlopeGeneration</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:ga5c36905fafe437df01d4b049d4989962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61e02555559df57238c3c95f78805723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga61e02555559df57238c3c95f78805723">XMC_HRPWM_StopComparator</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:ga61e02555559df57238c3c95f78805723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf85b9ae687f8831159c11b8480fc986e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#gaf85b9ae687f8831159c11b8480fc986e">XMC_HRPWM_StopDac</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:gaf85b9ae687f8831159c11b8480fc986e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cba81f02e8db279bbf0fe4a42646ba6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga9cba81f02e8db279bbf0fe4a42646ba6">XMC_HRPWM_StopSlopeGeneration</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:ga9cba81f02e8db279bbf0fe4a42646ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29de546fde9846b8f575687d58003c19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_r_p_w_m.html#ga29de546fde9846b8f575687d58003c19">XMC_HRPWM_UnClampComparatorOutput</a> (<a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const hrpwm, const uint32_t mask)</td></tr>
<tr class="separator:ga29de546fde9846b8f575687d58003c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The HRPWM extends the capabilities of the associated Capture/Compare Unit(CCU8), that simplifies the design various of SMPS. It allows easy and fast implementation of control loop, reduced total number of external components, avoid susceptibility to environmental and process variations there by reducing the size of the power supply.<br />
</p>
<p><b>Comparator Slope Generator(CSG)</b><br />
 HRPWM module consists 3 Comparator Slope Generator(CSG) units. Each CSG unit comprised of one High Speed Comparator, a dedicated 10 bit 30 MS/s DAC and one hardware controlled Slope Compensation module.<br />
</p>
<p><b>CSG features include:</b><br />
 </p><ol>
<li>
3 High Speed Comparators, that can be use to compare an external signal against the DAC value<br />
 </li>
<li>
3 (30MS/s) 10 bit DAC<br />
 </li>
<li>
3 Slope generation blocks, that are used to generate the DAC input value<br />
 </li>
<li>
different slope generations schemes, for a flexible and automated DAC voltage generation<br />
 </li>
<li>
2 DAC reference values, to allow flexible hysteretic mode control<br />
 </li>
<li>
Input multiplexer for the inverting comparator input, allowing several analog inputs to be connected to each comparator and also dynamic input switching.<br />
 </li>
<li>
blanking compare mode, to avoid premature switch OFF due to noise<br />
 </li>
<li>
a dedicated output per Comparator<br />
 </li>
<li>
programmable clock prescaler<br />
 </li>
<li>
programmable clock pulse swallower for slope linearization with uneven clock scale<br />
 </li>
<li>
different slope generation schemes:<br />
 – incrementing mode<br />
 – decrementing mode<br />
 – triangular mode<br />
 </li>
<li>
shadow transfer for one DAC reference value<br />
 </li>
<li>
external trigger for the DAC<br />
 </li>
<li>
external control for the DAC reference values<br />
 </li>
<li>
four dedicated service request lines<br />
 </li>
</ol>
<p><b>High Resolution Channel unit(HRC)</b><br />
 It also has 4 High Resolution Channel unit(HRC) that upgrades 4 compare channels of a Capture/Compare unit (CCU8), enabling generation of PWM with 150ps resolution. ie; the rise time and/or fall time of PWM can be changed in steps of 150ps.<br />
</p>
<p><b>HRC features include:</b><br />
 </p><ol>
<li>
Upgrade up to 4 PWM signals of CCU8 outputs for high resolution positioning.<br />
 </li>
<li>
Independent control of PWM set and reset.<br />
 </li>
<li>
Delay the PWM rise time in steps of 150ps. This does not insert dead time.<br />
 </li>
<li>
Extent the fall time of PWM in steps of 150ps. This does not insert dead time.<br />
 </li>
<li>
Dead time insertion on complementary signals<br />
 </li>
<li>
Passive level selection on outputs.<br />
 </li>
</ol>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga3acaa9244c28bd19d7c2bff6764edfec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3acaa9244c28bd19d7c2bff6764edfec">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef HRPWM0_CSG_Type <a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef for CSG unit registers data structure </p>

</div>
</div>
<a id="ga1a5ed62e672427731f694ea08a9e32b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a5ed62e672427731f694ea08a9e32b4">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef HRPWM0_HRC_Type <a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef for HRPWM high resolution channel registers data structure </p>

</div>
</div>
<a id="ga45de914982446332346b0ed2e298a464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45de914982446332346b0ed2e298a464">&#9670;&nbsp;</a></span>XMC_HRPWM_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef HRPWM0_Type <a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef for HRPWM Global registers data structure </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga5cd683d357b3e616029c499dbde6ff5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cd683d357b3e616029c499dbde6ff5d">&#9670;&nbsp;</a></span>XMC_HRPWM_CLK_FREQ_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga5cd683d357b3e616029c499dbde6ff5d">XMC_HRPWM_CLK_FREQ_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM module clock frequency </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5cd683d357b3e616029c499dbde6ff5da55a88b5326c43549c499d7343e0d1991"></a>XMC_HRPWM_CLK_FREQ_NONE&#160;</td><td class="fielddoc"><p>No clock frequency is selected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5cd683d357b3e616029c499dbde6ff5da81ebcaf4e04c03a7b6ee8ddf867f22ee"></a>XMC_HRPWM_CLK_FREQ_180MHZ&#160;</td><td class="fielddoc"><p>Module clock frequency is 180MHz </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5cd683d357b3e616029c499dbde6ff5dae0f3e078a0d8775b90e825823116d6f1"></a>XMC_HRPWM_CLK_FREQ_120MHZ&#160;</td><td class="fielddoc"><p>Module clock frequency is 120MHz </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5cd683d357b3e616029c499dbde6ff5da170ad1cb2c47fe26fbd60a16c96feba3"></a>XMC_HRPWM_CLK_FREQ_80MHZ&#160;</td><td class="fielddoc"><p>Module clock frequency is 80MHz </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa330fc9a084b311a86fc3dd42e0eccce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa330fc9a084b311a86fc3dd42e0eccce">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_CLK_INPUT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gaa330fc9a084b311a86fc3dd42e0eccce">XMC_HRPWM_CSG_CLK_INPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CSG - Slope Generation clock selection </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa330fc9a084b311a86fc3dd42e0eccceacfc4f7f6031b57b87ee9cc3d086fa8de"></a>XMC_HRPWM_CSG_CLK_INPUT_MCLK&#160;</td><td class="fielddoc"><p>Clock for CSG is module clock </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa330fc9a084b311a86fc3dd42e0ecccea12aa283fdc530c770f5bb0589d8927f0"></a>XMC_HRPWM_CSG_CLK_INPUT_ECLKA&#160;</td><td class="fielddoc"><p>Clock for CSG is external clock A </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa330fc9a084b311a86fc3dd42e0eccceac7fdf1ecfc4a8d21c7b9b1513b05050b"></a>XMC_HRPWM_CSG_CLK_INPUT_ECLKB&#160;</td><td class="fielddoc"><p>Clock for CSG is external clock B </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa330fc9a084b311a86fc3dd42e0eccceac0e4306d95599b0e543c9fd8c268d14b"></a>XMC_HRPWM_CSG_CLK_INPUT_ECLKC&#160;</td><td class="fielddoc"><p>Clock for CSG is external clock C </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf65bccdc3328dbd26b681fb5d0304c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf65bccdc3328dbd26b681fb5d0304c4d">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_CLK_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gaf65bccdc3328dbd26b681fb5d0304c4d">XMC_HRPWM_CSG_CLK_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CSG - Configuration for Clock disable </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf65bccdc3328dbd26b681fb5d0304c4dadd7fb695f3e0f0fd53a4319888b0e513"></a>XMC_HRPWM_CSG_CLK_CSG0&#160;</td><td class="fielddoc"><p>CSG0 clock mask </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf65bccdc3328dbd26b681fb5d0304c4daf0c72d7235b9517d97b2617b95684c79"></a>XMC_HRPWM_CSG_CLK_CSG1&#160;</td><td class="fielddoc"><p>CSG1 clock mask </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf65bccdc3328dbd26b681fb5d0304c4da1d7021a2c2db696025e2d3f093904035"></a>XMC_HRPWM_CSG_CLK_CSG2&#160;</td><td class="fielddoc"><p>CSG2 clock mask </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7bd4884f6c1a92640cfc91ea62556f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bd4884f6c1a92640cfc91ea62556f47">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga7bd4884f6c1a92640cfc91ea62556f47">XMC_HRPWM_CSG_CMP_FILTER_WINDOW_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CSG - Comparator output filter window </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7bd4884f6c1a92640cfc91ea62556f47aaed8dcd3a54f0b5e4f57c28b3d70630a"></a>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_2_CLK_CYCLES&#160;</td><td class="fielddoc"><p>Needs to be stable for 2 clk cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7bd4884f6c1a92640cfc91ea62556f47ae180304341c5fb17e18bc0e2f3d9a40f"></a>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_3_CLK_CYCLES&#160;</td><td class="fielddoc"><p>Needs to be stable for 3 clk cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7bd4884f6c1a92640cfc91ea62556f47a5ee3cc5ea7ef391a80756033305b9e99"></a>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_4_CLK_CYCLES&#160;</td><td class="fielddoc"><p>Needs to be stable for 4 clk cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7bd4884f6c1a92640cfc91ea62556f47a29bd2473ad2449623e4fed1941bc70f3"></a>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_5_CLK_CYCLES&#160;</td><td class="fielddoc"><p>Needs to be stable for 5 clk cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7bd4884f6c1a92640cfc91ea62556f47a5933fc14a86fd4a5c59dd559f660fcbd"></a>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_6_CLK_CYCLES&#160;</td><td class="fielddoc"><p>Needs to be stable for 6 clk cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7bd4884f6c1a92640cfc91ea62556f47a53975e5f78fcff87003a1526ef551e11"></a>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_7_CLK_CYCLES&#160;</td><td class="fielddoc"><p>Needs to be stable for 7 clk cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7bd4884f6c1a92640cfc91ea62556f47abb1da2b5ae06bd5808753a895366863e"></a>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_8_CLK_CYCLES&#160;</td><td class="fielddoc"><p>Needs to be stable for 8 clk cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7bd4884f6c1a92640cfc91ea62556f47aa5e1462a438e6a6de922cf95fe9a994e"></a>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_9_CLK_CYCLES&#160;</td><td class="fielddoc"><p>Needs to be stable for 9 clk cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7bd4884f6c1a92640cfc91ea62556f47ac43ad83b14b08a2726c2a76a11ae0375"></a>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_10_CLK_CYCLES&#160;</td><td class="fielddoc"><p>Needs to be stable for 10 clk cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7bd4884f6c1a92640cfc91ea62556f47a771b2d14829e1fab6843f1819076b4fe"></a>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_11_CLK_CYCLES&#160;</td><td class="fielddoc"><p>Needs to be stable for 11 clk cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7bd4884f6c1a92640cfc91ea62556f47ad37f87894a0904a37b3dba5290ee60f9"></a>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_12_CLK_CYCLES&#160;</td><td class="fielddoc"><p>Needs to be stable for 12 clk cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7bd4884f6c1a92640cfc91ea62556f47ad8341386c2d33395e61e6daf10cae8af"></a>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_13_CLK_CYCLES&#160;</td><td class="fielddoc"><p>Needs to be stable for 13 clk cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7bd4884f6c1a92640cfc91ea62556f47a331adb74dbff55d2adcfe0b66696b528"></a>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_14_CLK_CYCLES&#160;</td><td class="fielddoc"><p>Needs to be stable for 14 clk cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7bd4884f6c1a92640cfc91ea62556f47a634d2ca9527a400f7fc8ece96006c89b"></a>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_15_CLK_CYCLES&#160;</td><td class="fielddoc"><p>Needs to be stable for 15 clk cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7bd4884f6c1a92640cfc91ea62556f47a68a51866cb983de22b54bcf58a22ebef"></a>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_16_CLK_CYCLES&#160;</td><td class="fielddoc"><p>Needs to be stable for 16 clk cycles </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7bd4884f6c1a92640cfc91ea62556f47afe8bb8a7d87fbf4db71a43dd1071932b"></a>XMC_HRPWM_CSG_CMP_FILTER_WINDOW_32_CLK_CYCLES&#160;</td><td class="fielddoc"><p>Needs to be stable for 32 clk cycles </p>
</td></tr>
</table>

</div>
</div>
<a id="ga5da5acbc4ffb20968d49a8b9c3a0f3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5da5acbc4ffb20968d49a8b9c3a0f3c5">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_CMP_INPUT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga5da5acbc4ffb20968d49a8b9c3a0f3c5">XMC_HRPWM_CSG_CMP_INPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparator inputs </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5da5acbc4ffb20968d49a8b9c3a0f3c5a80ae7ae3c466f7caad40484dd48ae6ef"></a>XMC_HRPWM_CSG_CMP_INPUT_CINA&#160;</td><td class="fielddoc"><p>Input for comparator is CINA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5da5acbc4ffb20968d49a8b9c3a0f3c5a8d9c1ffe7919d1aba1e3dba8e540e65b"></a>XMC_HRPWM_CSG_CMP_INPUT_CINB&#160;</td><td class="fielddoc"><p>Input for comparator is CINB </p>
</td></tr>
</table>

</div>
</div>
<a id="gabc3a43d988fe0e66e4d4d8d85756676a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc3a43d988fe0e66e4d4d8d85756676a">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_CMP_INVERTING_INPUT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gabc3a43d988fe0e66e4d4d8d85756676a">XMC_HRPWM_CSG_CMP_INVERTING_INPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CSG comparator input switch request </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabc3a43d988fe0e66e4d4d8d85756676aa61dd6c9f2afcd141f4cf47a78c41ee55"></a>XMC_HRPWM_CSG_CMP_INVERTING_INPUT_CMP0&#160;</td><td class="fielddoc"><p>Comparator 0 inverting input connection </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabc3a43d988fe0e66e4d4d8d85756676aaa69e7658801538ccaee149ebe8e0e0af"></a>XMC_HRPWM_CSG_CMP_INVERTING_INPUT_CMP1&#160;</td><td class="fielddoc"><p>Comparator 1 inverting input connection </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabc3a43d988fe0e66e4d4d8d85756676aa6a597bc50d1b8524130bb8bb5427d923"></a>XMC_HRPWM_CSG_CMP_INVERTING_INPUT_CMP2&#160;</td><td class="fielddoc"><p>Comparator 2 inverting input connection </p>
</td></tr>
</table>

</div>
</div>
<a id="gab2717581e740ad6f1dd2ad44db0674d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2717581e740ad6f1dd2ad44db0674d9">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_EDGE_SEL_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gab2717581e740ad6f1dd2ad44db0674d9">XMC_HRPWM_CSG_EDGE_SEL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CSG - Selection of edge sensitivity </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab2717581e740ad6f1dd2ad44db0674d9a1af076541283b1b3784d9d3109a4ab49"></a>XMC_HRPWM_CSG_EDGE_SEL_DISABLED&#160;</td><td class="fielddoc"><p>Trigger event not generated </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2717581e740ad6f1dd2ad44db0674d9a45ab928b8ae674c4969746c02df52c38"></a>XMC_HRPWM_CSG_EDGE_SEL_RISING_EDGE&#160;</td><td class="fielddoc"><p>Trigger event not generated in rising edge </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2717581e740ad6f1dd2ad44db0674d9a972ec543f1bcd479a9bcb7fa9cf8c9af"></a>XMC_HRPWM_CSG_EDGE_SEL_FALLING_EDGE&#160;</td><td class="fielddoc"><p>Trigger event not generated in falling edge </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2717581e740ad6f1dd2ad44db0674d9ace119f5cea4409314ff4eecc1a5b1b07"></a>XMC_HRPWM_CSG_EDGE_SEL_BOTH_EDGE&#160;</td><td class="fielddoc"><p>Trigger event not generated in both edges </p>
</td></tr>
</table>

</div>
</div>
<a id="ga37b76dfd8cf0debb56c2534914fb405c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37b76dfd8cf0debb56c2534914fb405c">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_INPUT_SEL_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga37b76dfd8cf0debb56c2534914fb405c">XMC_HRPWM_CSG_INPUT_SEL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input list to CSG </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga37b76dfd8cf0debb56c2534914fb405cafa92b6c3ad3a96d06f956979df291e6a"></a>XMC_HRPWM_CSG_INPUT_SEL_IA&#160;</td><td class="fielddoc"><p>Input selected for blanking or comparator switch: Input-A </p>
</td></tr>
<tr><td class="fieldname"><a id="gga37b76dfd8cf0debb56c2534914fb405cabfa5ec03ebc3c9e17dcec893f09ca916"></a>XMC_HRPWM_CSG_INPUT_SEL_IB&#160;</td><td class="fielddoc"><p>Input selected for blanking or comparator switch: Input-B </p>
</td></tr>
<tr><td class="fieldname"><a id="gga37b76dfd8cf0debb56c2534914fb405ca57e62333363337c4bbcaf589c6360375"></a>XMC_HRPWM_CSG_INPUT_SEL_IC&#160;</td><td class="fielddoc"><p>Input selected for blanking or comparator switch: Input-C </p>
</td></tr>
<tr><td class="fieldname"><a id="gga37b76dfd8cf0debb56c2534914fb405ca9ea98984f1e11fc3494e1572dfc08c16"></a>XMC_HRPWM_CSG_INPUT_SEL_ID&#160;</td><td class="fielddoc"><p>Input selected for blanking or comparator switch: Input-D </p>
</td></tr>
<tr><td class="fieldname"><a id="gga37b76dfd8cf0debb56c2534914fb405ca63414c8e2d0d8467c09d2c89aa2ab159"></a>XMC_HRPWM_CSG_INPUT_SEL_IE&#160;</td><td class="fielddoc"><p>Input selected for blanking or comparator switch: Input-E </p>
</td></tr>
<tr><td class="fieldname"><a id="gga37b76dfd8cf0debb56c2534914fb405cac64bcc6e4ba8d94b5fd6d8fbb5b9a1f1"></a>XMC_HRPWM_CSG_INPUT_SEL_IF&#160;</td><td class="fielddoc"><p>Input selected for blanking or comparator switch: Input-F </p>
</td></tr>
<tr><td class="fieldname"><a id="gga37b76dfd8cf0debb56c2534914fb405ca5771659fd7d4645382967b5d7257a830"></a>XMC_HRPWM_CSG_INPUT_SEL_IG&#160;</td><td class="fielddoc"><p>Input selected for blanking or comparator switch: Input-G </p>
</td></tr>
<tr><td class="fieldname"><a id="gga37b76dfd8cf0debb56c2534914fb405ca68e6389f1e4b199d6fdfb1ceb4785a3c"></a>XMC_HRPWM_CSG_INPUT_SEL_IH&#160;</td><td class="fielddoc"><p>Input selected for blanking or comparator switch: Input-H </p>
</td></tr>
<tr><td class="fieldname"><a id="gga37b76dfd8cf0debb56c2534914fb405cadda4e732a57a0a0aa41229031458dfaa"></a>XMC_HRPWM_CSG_INPUT_SEL_II&#160;</td><td class="fielddoc"><p>Input selected for blanking or comparator switch: Input-I </p>
</td></tr>
<tr><td class="fieldname"><a id="gga37b76dfd8cf0debb56c2534914fb405ca544e98f11cb67193093571962c70ef5e"></a>XMC_HRPWM_CSG_INPUT_SEL_IJ&#160;</td><td class="fielddoc"><p>Input selected for blanking or comparator switch: Input-J </p>
</td></tr>
<tr><td class="fieldname"><a id="gga37b76dfd8cf0debb56c2534914fb405ca81158a83f6f423d3807347edd35aaeba"></a>XMC_HRPWM_CSG_INPUT_SEL_IK&#160;</td><td class="fielddoc"><p>Input selected for blanking or comparator switch: Input-K </p>
</td></tr>
<tr><td class="fieldname"><a id="gga37b76dfd8cf0debb56c2534914fb405ca24a862623aa750841b605a25281e3459"></a>XMC_HRPWM_CSG_INPUT_SEL_IL&#160;</td><td class="fielddoc"><p>Input selected for blanking or comparator switch: Input-L </p>
</td></tr>
<tr><td class="fieldname"><a id="gga37b76dfd8cf0debb56c2534914fb405cadf3d7c73b7f086e1ba8b2a220a5e14c9"></a>XMC_HRPWM_CSG_INPUT_SEL_IM&#160;</td><td class="fielddoc"><p>Input selected for blanking or comparator switch: Input-M </p>
</td></tr>
<tr><td class="fieldname"><a id="gga37b76dfd8cf0debb56c2534914fb405ca7da165fc2d244abbfb3a1c7b38587f5e"></a>XMC_HRPWM_CSG_INPUT_SEL_IN&#160;</td><td class="fielddoc"><p>Input selected for blanking or comparator switch: Input-N </p>
</td></tr>
<tr><td class="fieldname"><a id="gga37b76dfd8cf0debb56c2534914fb405ca3e7c44d9fd56ad3ba0a73c19fc755a0b"></a>XMC_HRPWM_CSG_INPUT_SEL_IO&#160;</td><td class="fielddoc"><p>Input selected for blanking or comparator switch: Input-O </p>
</td></tr>
<tr><td class="fieldname"><a id="gga37b76dfd8cf0debb56c2534914fb405caffc584bb22fa6e9041523883016ae93b"></a>XMC_HRPWM_CSG_INPUT_SEL_IP&#160;</td><td class="fielddoc"><p>Input selected for blanking or comparator switch: Input-P </p>
</td></tr>
</table>

</div>
</div>
<a id="ga436f2a6ad7ee2320f30163997c9d8cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga436f2a6ad7ee2320f30163997c9d8cd4">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_IRQ_ID_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga436f2a6ad7ee2320f30163997c9d8cd4">XMC_HRPWM_CSG_IRQ_ID_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CSG - IRQ Event Id The enum is used to access the bitfields of registers CSGySRE, CSGySRS, CSGySWS, CSGySWC, CSGyISTAT </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga436f2a6ad7ee2320f30163997c9d8cd4ad0d4d0dc2d62eac194de89d0d1bea141"></a>XMC_HRPWM_CSG_IRQ_ID_VLS1&#160;</td><td class="fielddoc"><p>Interrupt on DAC value switch from CSGyDSV1 to CSGyDSV2 interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="gga436f2a6ad7ee2320f30163997c9d8cd4ac9ce11b6d6485f1ded61167f9cb19486"></a>XMC_HRPWM_CSG_IRQ_ID_VLS2&#160;</td><td class="fielddoc"><p>Interrupt on DAC value switch from CSGyDSV2 to CSGyDSV1 interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="gga436f2a6ad7ee2320f30163997c9d8cd4a3f5b22409f9989661b3c959b8011b7c6"></a>XMC_HRPWM_CSG_IRQ_ID_TRGS&#160;</td><td class="fielddoc"><p>Interrupt on DAC conversion trigger </p>
</td></tr>
<tr><td class="fieldname"><a id="gga436f2a6ad7ee2320f30163997c9d8cd4a4bbe8cdf4a4f9ffe672b612734dd0130"></a>XMC_HRPWM_CSG_IRQ_ID_STRS&#160;</td><td class="fielddoc"><p>Interrupt on DAC start trigger </p>
</td></tr>
<tr><td class="fieldname"><a id="gga436f2a6ad7ee2320f30163997c9d8cd4a9dc48a09eb0d237802bd44717eeccc0a"></a>XMC_HRPWM_CSG_IRQ_ID_STPS&#160;</td><td class="fielddoc"><p>Interrupt on DAC stop trigger </p>
</td></tr>
<tr><td class="fieldname"><a id="gga436f2a6ad7ee2320f30163997c9d8cd4afd98062cfac290a3014eedf23d645932"></a>XMC_HRPWM_CSG_IRQ_ID_STD&#160;</td><td class="fielddoc"><p>Interrupt on DAC shadow transfer </p>
</td></tr>
<tr><td class="fieldname"><a id="gga436f2a6ad7ee2320f30163997c9d8cd4a9a0d96e5bcb3c9629a178bb581e85c77"></a>XMC_HRPWM_CSG_IRQ_ID_CRSE&#160;</td><td class="fielddoc"><p>Interrupt on comparator output rise edge </p>
</td></tr>
<tr><td class="fieldname"><a id="gga436f2a6ad7ee2320f30163997c9d8cd4ab21a76f2f762c6aa5df9612cae5853e0"></a>XMC_HRPWM_CSG_IRQ_ID_CFSE&#160;</td><td class="fielddoc"><p>Interrupt on comparator output fall edge </p>
</td></tr>
<tr><td class="fieldname"><a id="gga436f2a6ad7ee2320f30163997c9d8cd4afeb37d595486300ac97acc7e37f5d9c8"></a>XMC_HRPWM_CSG_IRQ_ID_CSEE&#160;</td><td class="fielddoc"><p>Interrupt on comparator output clamped state </p>
</td></tr>
</table>

</div>
</div>
<a id="ga74fab5ae35406664bf3be96687597b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74fab5ae35406664bf3be96687597b13">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_IRQ_SR_LINE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga74fab5ae35406664bf3be96687597b13">XMC_HRPWM_CSG_IRQ_SR_LINE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CSG - Service request line </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga74fab5ae35406664bf3be96687597b13ae138138104ec227b8dc003d567fe4ae6"></a>XMC_HRPWM_CSG_IRQ_SR_LINE_0&#160;</td><td class="fielddoc"><p>CSG - Service request SR-0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga74fab5ae35406664bf3be96687597b13a960f56aab9debaedd46290953a082a48"></a>XMC_HRPWM_CSG_IRQ_SR_LINE_1&#160;</td><td class="fielddoc"><p>CSG - Service request SR-1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga74fab5ae35406664bf3be96687597b13aa0a2dfef96e33ccff8ca613fabda5682"></a>XMC_HRPWM_CSG_IRQ_SR_LINE_2&#160;</td><td class="fielddoc"><p>CSG - Service request SR-2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga74fab5ae35406664bf3be96687597b13ad538c53e9cc01477f104907a191a5cc7"></a>XMC_HRPWM_CSG_IRQ_SR_LINE_3&#160;</td><td class="fielddoc"><p>CSG - Service request SR-3 </p>
</td></tr>
</table>

</div>
</div>
<a id="gae1274dea1f81c40a35649162cd449b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1274dea1f81c40a35649162cd449b81">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_LVL_SEL_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gae1274dea1f81c40a35649162cd449b81">XMC_HRPWM_CSG_LVL_SEL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CSG - Selection of level sensitivity </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae1274dea1f81c40a35649162cd449b81a4ec453bfdfb771f990ca31c5a0766b4b"></a>XMC_HRPWM_CSG_LVL_SEL_DISABLED&#160;</td><td class="fielddoc"><p>Level sensitivity is disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae1274dea1f81c40a35649162cd449b81aa7b63fc7cc78a8ff5333e6a4cd6410ec"></a>XMC_HRPWM_CSG_LVL_SEL_HIGH&#160;</td><td class="fielddoc"><p>Level sensitivity is High </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae1274dea1f81c40a35649162cd449b81a4c78a3cac9dbcd5d14c2f2adb78cfd06"></a>XMC_HRPWM_CSG_LVL_SEL_LOW&#160;</td><td class="fielddoc"><p>Level sensitivity is Low </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa200a6a7a4cbfb74537076c89a7aa4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa200a6a7a4cbfb74537076c89a7aa4be">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_POWER_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gaa200a6a7a4cbfb74537076c89a7aa4be">XMC_HRPWM_CSG_POWER_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CSG power modes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa200a6a7a4cbfb74537076c89a7aa4beaa1a5346b6cfe577b91d22a544d091204"></a>XMC_HRPWM_CSG_POWER_MODE_OFF&#160;</td><td class="fielddoc"><p>Comparator slope generator turned off </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa200a6a7a4cbfb74537076c89a7aa4bea2420213a408ed8e6839efd94071f79da"></a>XMC_HRPWM_CSG_POWER_MODE_LOW_SPEED&#160;</td><td class="fielddoc"><p>Comparator slope generator in low speed mode </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa200a6a7a4cbfb74537076c89a7aa4beaa170aadb39a53cf757a4740c6337f2d7"></a>XMC_HRPWM_CSG_POWER_MODE_HI_SPEED&#160;</td><td class="fielddoc"><p>Comparator slope generator in high speed mode </p>
</td></tr>
</table>

</div>
</div>
<a id="ga60a76ed4786b9f2f83a6e55ab840b220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60a76ed4786b9f2f83a6e55ab840b220">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_PRESCALER_CLR_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga60a76ed4786b9f2f83a6e55ab840b220">XMC_HRPWM_CSG_PRESCALER_CLR_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear prescaler in CSG </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga60a76ed4786b9f2f83a6e55ab840b220a90d1a55da7b83f8f5d808203070621d9"></a>XMC_HRPWM_CSG_PRESCALER_CLR_CSG0&#160;</td><td class="fielddoc"><p>Clear prescaler of CSG0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga60a76ed4786b9f2f83a6e55ab840b220a988200a5d9ad965f88c5138207c3400f"></a>XMC_HRPWM_CSG_PRESCALER_CLR_CSG1&#160;</td><td class="fielddoc"><p>Clear prescaler of CSG1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga60a76ed4786b9f2f83a6e55ab840b220a18cdeb15d32be1be91bc3007130cd4a9"></a>XMC_HRPWM_CSG_PRESCALER_CLR_CSG2&#160;</td><td class="fielddoc"><p>Clear prescaler of CSG2 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga667011f4c74780559bac6963d2774553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga667011f4c74780559bac6963d2774553">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_PRESCALER_DIVISION_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga667011f4c74780559bac6963d2774553">XMC_HRPWM_CSG_PRESCALER_DIVISION_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CSG - Slope step gain </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga667011f4c74780559bac6963d2774553ab1e91ae7639b2afb81e386700f59b2d0"></a>XMC_HRPWM_CSG_PRESCALER_DIVISION_BY_1&#160;</td><td class="fielddoc"><p>Division by 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga667011f4c74780559bac6963d2774553a37b25b1a925bdd75ef0dc7f89e50bee1"></a>XMC_HRPWM_CSG_PRESCALER_DIVISION_BY_2&#160;</td><td class="fielddoc"><p>Division by 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga667011f4c74780559bac6963d2774553a0844ca44399d2f87922ecbc89152e38e"></a>XMC_HRPWM_CSG_PRESCALER_DIVISION_BY_4&#160;</td><td class="fielddoc"><p>Division by 4 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga667011f4c74780559bac6963d2774553aacf011ff10ddced9855054162d2485f0"></a>XMC_HRPWM_CSG_PRESCALER_DIVISION_BY_8&#160;</td><td class="fielddoc"><p>Division by 8 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga627a4aaf52c1bda8cf8ce7039763af93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga627a4aaf52c1bda8cf8ce7039763af93">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_PRESCALER_EXT_START_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga627a4aaf52c1bda8cf8ce7039763af93">XMC_HRPWM_CSG_PRESCALER_EXT_START_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CSG - Prescaler external start configuration </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga627a4aaf52c1bda8cf8ce7039763af93a3a5127fca3261ce02b4a3e510af6aaba"></a>XMC_HRPWM_CSG_PRESCALER_EXT_START_IGNORE&#160;</td><td class="fielddoc"><p>Prescaler operation on external start trigger is: Ignore </p>
</td></tr>
<tr><td class="fieldname"><a id="gga627a4aaf52c1bda8cf8ce7039763af93a1cff5ee8b817cadc0d89e62ca4296205"></a>XMC_HRPWM_CSG_PRESCALER_EXT_START_STRT&#160;</td><td class="fielddoc"><p>Prescaler operation on external start trigger is: Start prescaler </p>
</td></tr>
<tr><td class="fieldname"><a id="gga627a4aaf52c1bda8cf8ce7039763af93a17113b43b52d31ab1b4e432f98087bc9"></a>XMC_HRPWM_CSG_PRESCALER_EXT_START_CLR&#160;</td><td class="fielddoc"><p>Prescaler operation on external start trigger is: Clear prescaler </p>
</td></tr>
<tr><td class="fieldname"><a id="gga627a4aaf52c1bda8cf8ce7039763af93ac8519e497671019b691d984ad6033aaa"></a>XMC_HRPWM_CSG_PRESCALER_EXT_START_CLR_N_STRT&#160;</td><td class="fielddoc"><p>Prescaler operation on external start trigger is: Clear &amp; Start prescaler </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9dfa4483749fda4b6e87ec6f1ac44a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dfa4483749fda4b6e87ec6f1ac44a54">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_PRESCALER_EXT_STOP_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga9dfa4483749fda4b6e87ec6f1ac44a54">XMC_HRPWM_CSG_PRESCALER_EXT_STOP_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CSG - Prescaler external stop configuration </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9dfa4483749fda4b6e87ec6f1ac44a54a185becd0d61c4aa1da2f6877fb1f13cc"></a>XMC_HRPWM_CSG_PRESCALER_EXT_STOP_IGNORE&#160;</td><td class="fielddoc"><p>Prescaler operation on external stop trigger is: Ignore </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9dfa4483749fda4b6e87ec6f1ac44a54a86f20b536025b5f5112064c23889e184"></a>XMC_HRPWM_CSG_PRESCALER_EXT_STOP_STP&#160;</td><td class="fielddoc"><p>Prescaler operation on external stop trigger is: Stop prescaler </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9dfa4483749fda4b6e87ec6f1ac44a54a0d166c4f7dbb6f3d7769947308a910d6"></a>XMC_HRPWM_CSG_PRESCALER_EXT_STOP_CLR&#160;</td><td class="fielddoc"><p>Prescaler operation on external stop trigger is: Clear prescaler </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9dfa4483749fda4b6e87ec6f1ac44a54a0ff8e403add0872af4fe17915c0aa1a2"></a>XMC_HRPWM_CSG_PRESCALER_EXT_STOP_CLR_N_STOP&#160;</td><td class="fielddoc"><p>Prescaler operation on external stop trigger is: Clear &amp; Stop prescaler </p>
</td></tr>
</table>

</div>
</div>
<a id="gac2afbc1fbd9f9004061420fea8603b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2afbc1fbd9f9004061420fea8603b67">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_PRESCALER_START_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gac2afbc1fbd9f9004061420fea8603b67">XMC_HRPWM_CSG_PRESCALER_START_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prescaler start in CSG </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac2afbc1fbd9f9004061420fea8603b67a9b580d5de7307c3a1e8dd30bc4fe15c7"></a>XMC_HRPWM_CSG_PRESCALER_START_CSG0&#160;</td><td class="fielddoc"><p>Start prescaler of CSG0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac2afbc1fbd9f9004061420fea8603b67a8e9c35a3489ad350a3ee5a14b312d9d7"></a>XMC_HRPWM_CSG_PRESCALER_START_CSG1&#160;</td><td class="fielddoc"><p>Start prescaler of CSG1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac2afbc1fbd9f9004061420fea8603b67a7af95a19825ad17171a1992c30b8cea1"></a>XMC_HRPWM_CSG_PRESCALER_START_CSG2&#160;</td><td class="fielddoc"><p>Start prescaler of CSG2 </p>
</td></tr>
</table>

</div>
</div>
<a id="gacb53cbfc6388b50d5708abf4652823e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb53cbfc6388b50d5708abf4652823e5">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_PRESCALER_STATUS_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gacb53cbfc6388b50d5708abf4652823e5">XMC_HRPWM_CSG_PRESCALER_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CSG prescaler status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacb53cbfc6388b50d5708abf4652823e5a15aa0b0e34c68a9eece834e09f09ba99"></a>XMC_HRPWM_CSG_PRESCALER_STATUS_CSG0&#160;</td><td class="fielddoc"><p>Prescaler status in CSG0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacb53cbfc6388b50d5708abf4652823e5a4c18d1f09d251e1b1e44954d1c03eafe"></a>XMC_HRPWM_CSG_PRESCALER_STATUS_CSG1&#160;</td><td class="fielddoc"><p>Prescaler status in CSG1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacb53cbfc6388b50d5708abf4652823e5a977bd612dbcae8cb2da5d076c417e26e"></a>XMC_HRPWM_CSG_PRESCALER_STATUS_CSG2&#160;</td><td class="fielddoc"><p>Prescaler status in CSG2 </p>
</td></tr>
</table>

</div>
</div>
<a id="gacd216b6c73d586c8c407965d3a5288ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd216b6c73d586c8c407965d3a5288ca">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_PRESCALER_STOP_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gacd216b6c73d586c8c407965d3a5288ca">XMC_HRPWM_CSG_PRESCALER_STOP_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prescaler stop in CSG </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacd216b6c73d586c8c407965d3a5288caa6d63c09bee819ce6a6bb47913b34dbc2"></a>XMC_HRPWM_CSG_PRESCALER_STOP_CSG0&#160;</td><td class="fielddoc"><p>Stop prescaler of CSG0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd216b6c73d586c8c407965d3a5288caaf45be23cd6af0045fce0c68838f6fa8e"></a>XMC_HRPWM_CSG_PRESCALER_STOP_CSG1&#160;</td><td class="fielddoc"><p>Stop prescaler of CSG1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd216b6c73d586c8c407965d3a5288caacc20736ae78829b1c0113365de98249a"></a>XMC_HRPWM_CSG_PRESCALER_STOP_CSG2&#160;</td><td class="fielddoc"><p>Stop prescaler of CSG2 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8f5cb84356dd14d33e4172435a921082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f5cb84356dd14d33e4172435a921082">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_RUN_BIT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga8f5cb84356dd14d33e4172435a921082">XMC_HRPWM_CSG_RUN_BIT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DAC, Comparator start controls &amp; Comparator clamped state control The enum is used to access the bitfields of registers CSGSETG, CSGCLRG, CSGSTATG </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8f5cb84356dd14d33e4172435a921082ad7f6f0cbd5b228f9f0b2ca97fbdaddb7"></a>XMC_HRPWM_CSG_RUN_BIT_DAC0&#160;</td><td class="fielddoc"><p>Start DAC0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8f5cb84356dd14d33e4172435a921082a3d377ba20577661dfe5a8e12e4c265cc"></a>XMC_HRPWM_CSG_RUN_BIT_CMP0&#160;</td><td class="fielddoc"><p>Start comparator 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8f5cb84356dd14d33e4172435a921082ad09de0621aea8303fb6c73bb622454c9"></a>XMC_HRPWM_CSG_RUN_BIT_CMP0_PSL&#160;</td><td class="fielddoc"><p>Set comparator 0 output to clamped state </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8f5cb84356dd14d33e4172435a921082ac83c9648885d15a414eb0510e59b3caf"></a>XMC_HRPWM_CSG_RUN_BIT_DAC1&#160;</td><td class="fielddoc"><p>Start DAC1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8f5cb84356dd14d33e4172435a921082a852a50fbafef93f54b7b0c249228365c"></a>XMC_HRPWM_CSG_RUN_BIT_CMP1&#160;</td><td class="fielddoc"><p>Start comparator 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8f5cb84356dd14d33e4172435a921082a82c471f00baffac950bfd56346e47b16"></a>XMC_HRPWM_CSG_RUN_BIT_CMP1_PSL&#160;</td><td class="fielddoc"><p>Set comparator 1 output to clamped state </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8f5cb84356dd14d33e4172435a921082a77d56c88f193b0e61f942ca89da49586"></a>XMC_HRPWM_CSG_RUN_BIT_DAC2&#160;</td><td class="fielddoc"><p>Start DAC2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8f5cb84356dd14d33e4172435a921082ab552e347637c2418dcf13de5a8abd3a4"></a>XMC_HRPWM_CSG_RUN_BIT_CMP2&#160;</td><td class="fielddoc"><p>Start comparator2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8f5cb84356dd14d33e4172435a921082ae8b88291d912f7f27a728a8f56e4c450"></a>XMC_HRPWM_CSG_RUN_BIT_CMP2_PSL&#160;</td><td class="fielddoc"><p>Set comparator 2 output to clamped state </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4f816529f1530081745540ca81fa808b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f816529f1530081745540ca81fa808b">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_SLICE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga4f816529f1530081745540ca81fa808b">XMC_HRPWM_CSG_SLICE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CSG - Slice numbers </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4f816529f1530081745540ca81fa808ba92eb89d7239a41f891695640a11b5514"></a>XMC_HRPWM_CSG_SLICE_0&#160;</td><td class="fielddoc"><p>CSG slice number is 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f816529f1530081745540ca81fa808ba1b2ea691f646e8ac8455ccb548a753aa"></a>XMC_HRPWM_CSG_SLICE_1&#160;</td><td class="fielddoc"><p>CSG slice number is 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f816529f1530081745540ca81fa808ba07214c4016df9ac55c781544d23ef45a"></a>XMC_HRPWM_CSG_SLICE_2&#160;</td><td class="fielddoc"><p>CSG slice number is 2 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2155fcd8e21549783e868c3962d63965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2155fcd8e21549783e868c3962d63965">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_SLOPE_CTRL_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga2155fcd8e21549783e868c3962d63965">XMC_HRPWM_CSG_SLOPE_CTRL_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CSG - Slope Generation control mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2155fcd8e21549783e868c3962d63965a3b6b95d3649344afd7eac84b137a53c7"></a>XMC_HRPWM_CSG_SLOPE_CTRL_MODE_STATIC&#160;</td><td class="fielddoc"><p>Slope generation mode - Static mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2155fcd8e21549783e868c3962d63965a656f1340029a53bd56bca573e9f64039"></a>XMC_HRPWM_CSG_SLOPE_CTRL_MODE_DEC_GEN&#160;</td><td class="fielddoc"><p>Slope generation mode - Decrementing slope generation </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2155fcd8e21549783e868c3962d63965a31b01aa849bdf09cb6c315fc7956333e"></a>XMC_HRPWM_CSG_SLOPE_CTRL_MODE_INC_GEN&#160;</td><td class="fielddoc"><p>Slope generation mode - Incrementing slope generation </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2155fcd8e21549783e868c3962d63965a6e5fa61db78bc4fc10959a05b8bce271"></a>XMC_HRPWM_CSG_SLOPE_CTRL_MODE_TRIANGULAR&#160;</td><td class="fielddoc"><p>Slope generation mode - Triangular slope generation </p>
</td></tr>
</table>

</div>
</div>
<a id="ga60e2831acbfa421bc6ee4d92305afa7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60e2831acbfa421bc6ee4d92305afa7d">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_SLOPE_EXT_START_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga60e2831acbfa421bc6ee4d92305afa7d">XMC_HRPWM_CSG_SLOPE_EXT_START_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CSG - Slope Generation external start configuration </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga60e2831acbfa421bc6ee4d92305afa7da84aac3b4d271d8437515a127aa92154e"></a>XMC_HRPWM_CSG_SLOPE_EXT_START_IGNORE&#160;</td><td class="fielddoc"><p>Slope generation on external start trigger is: Ignore </p>
</td></tr>
<tr><td class="fieldname"><a id="gga60e2831acbfa421bc6ee4d92305afa7da28533040e25fc36f81b028752651e83c"></a>XMC_HRPWM_CSG_SLOPE_EXT_START_STRT&#160;</td><td class="fielddoc"><p>Slope generation on external start trigger is: Start/restart slope generation </p>
</td></tr>
<tr><td class="fieldname"><a id="gga60e2831acbfa421bc6ee4d92305afa7da00f4631e89bcf14f067637b274ab304d"></a>XMC_HRPWM_CSG_SLOPE_EXT_START_RESUME&#160;</td><td class="fielddoc"><p>Slope generation on external start trigger is: Resumes slope generation </p>
</td></tr>
</table>

</div>
</div>
<a id="gab1d906442d8114ef2b5019f3933694dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1d906442d8114ef2b5019f3933694dd">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_SLOPE_EXT_STOP_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gab1d906442d8114ef2b5019f3933694dd">XMC_HRPWM_CSG_SLOPE_EXT_STOP_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CGS - Slope Generation external stop configuration </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab1d906442d8114ef2b5019f3933694ddaa52047a2dfa4df54d189b75e23d2332c"></a>XMC_HRPWM_CSG_SLOPE_EXT_STOP_IGNORE&#160;</td><td class="fielddoc"><p>Slope generation on external stop trigger is: Ignore </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab1d906442d8114ef2b5019f3933694ddac65a8777eaa39e18cb13224c27a3d1be"></a>XMC_HRPWM_CSG_SLOPE_EXT_STOP_STP&#160;</td><td class="fielddoc"><p>Slope generation on external stop trigger is: Stops/Halts the slope generation </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab1d906442d8114ef2b5019f3933694ddac25b55e9ff26870f5ef84d0b67cf18f2"></a>XMC_HRPWM_CSG_SLOPE_EXT_STOP_FREEZE&#160;</td><td class="fielddoc"><p>Slope generation on external stop trigger is: Freezes slope generation &amp; feeds constantly the value programmed in CSGyDSV2 to the DAC </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1291723b296aeacb9832915604baebaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1291723b296aeacb9832915604baebaa">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_SLOPE_START_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga1291723b296aeacb9832915604baebaa">XMC_HRPWM_CSG_SLOPE_START_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Slope start for DAC units </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1291723b296aeacb9832915604baebaaab261e43b5b24d1d41557670872b8c3db"></a>XMC_HRPWM_CSG_SLOPE_START_DAC0&#160;</td><td class="fielddoc"><p>Start slope generation for DAC0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1291723b296aeacb9832915604baebaaa364eab2b3031e9e8e668064f273a162c"></a>XMC_HRPWM_CSG_SLOPE_START_DAC1&#160;</td><td class="fielddoc"><p>Start slope generation for DAC1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1291723b296aeacb9832915604baebaaa38474d314b91c5a23ea8ff1d98afc405"></a>XMC_HRPWM_CSG_SLOPE_START_DAC2&#160;</td><td class="fielddoc"><p>Start slope generation for DAC2 </p>
</td></tr>
</table>

</div>
</div>
<a id="gafbfe1cccf9f90e5f91d492c67907ba3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbfe1cccf9f90e5f91d492c67907ba3a">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_SLOPE_STEP_GAIN_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gafbfe1cccf9f90e5f91d492c67907ba3a">XMC_HRPWM_CSG_SLOPE_STEP_GAIN_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CSG - Slope step gain </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafbfe1cccf9f90e5f91d492c67907ba3aac48d9967c650caad4e66123dd8f1d83b"></a>XMC_HRPWM_CSG_SLOPE_STEP_GAIN_INC_DEC_BY_1&#160;</td><td class="fielddoc"><p>slope step has an increment/decrement of 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafbfe1cccf9f90e5f91d492c67907ba3aa195a01c602e2d5d3271ab5f08dcb6ab8"></a>XMC_HRPWM_CSG_SLOPE_STEP_GAIN_INC_DEC_BY_2&#160;</td><td class="fielddoc"><p>slope step has an increment/decrement of 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafbfe1cccf9f90e5f91d492c67907ba3aa960722f003293366578a59297e56fa28"></a>XMC_HRPWM_CSG_SLOPE_STEP_GAIN_INC_DEC_BY_4&#160;</td><td class="fielddoc"><p>slope step has an increment/decrement of 4 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafbfe1cccf9f90e5f91d492c67907ba3aa1d9098e35672bff5eaf61836ca0710d2"></a>XMC_HRPWM_CSG_SLOPE_STEP_GAIN_INC_DEC_BY_8&#160;</td><td class="fielddoc"><p>slope step has an increment/decrement of 8 </p>
</td></tr>
</table>

</div>
</div>
<a id="gab291d73c3f778be105bdd3f582e2756e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab291d73c3f778be105bdd3f582e2756e">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_SLOPE_STOP_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gab291d73c3f778be105bdd3f582e2756e">XMC_HRPWM_CSG_SLOPE_STOP_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Slope stop for DAC units </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab291d73c3f778be105bdd3f582e2756ea16564c85414717fe31f656662d45fe97"></a>XMC_HRPWM_CSG_SLOPE_STOP_DAC0&#160;</td><td class="fielddoc"><p>Stop slope generation for DAC0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab291d73c3f778be105bdd3f582e2756ea400eb82873c0f4a606a5f4d70f0617be"></a>XMC_HRPWM_CSG_SLOPE_STOP_DAC1&#160;</td><td class="fielddoc"><p>Stop slope generation for DAC1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab291d73c3f778be105bdd3f582e2756eaaefe6bc7487141f4bc9df0fae98d41ce"></a>XMC_HRPWM_CSG_SLOPE_STOP_DAC2&#160;</td><td class="fielddoc"><p>Stop slope generation for DAC2 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga551133de6601253b0f9bf43fc9772f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga551133de6601253b0f9bf43fc9772f15">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_SWITCH_CMP_INPUT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga551133de6601253b0f9bf43fc9772f15">XMC_HRPWM_CSG_SWITCH_CMP_INPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CSG comparator input switch request </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga551133de6601253b0f9bf43fc9772f15a2ab17e410048194a53c27631805225c1"></a>XMC_HRPWM_CSG_SWITCH_CMP_INPUT_CMP0&#160;</td><td class="fielddoc"><p>Request to switch the analog input connected to the comparator 0 between CINA and CINB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga551133de6601253b0f9bf43fc9772f15a85c4914a706fa182fbefcf66ccb542c4"></a>XMC_HRPWM_CSG_SWITCH_CMP_INPUT_CMP1&#160;</td><td class="fielddoc"><p>Request to switch the analog input connected to the comparator 1 between CINA and CINB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga551133de6601253b0f9bf43fc9772f15a4275570e2c689e90c9eeff6d77ec2b29"></a>XMC_HRPWM_CSG_SWITCH_CMP_INPUT_CMP2&#160;</td><td class="fielddoc"><p>Request to switch the analog input connected to the comparator 2 between CINA and CINB </p>
</td></tr>
</table>

</div>
</div>
<a id="gadfaa9ad3d5d14d786ac920e411b1a4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfaa9ad3d5d14d786ac920e411b1a4ce">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_SWSM_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gadfaa9ad3d5d14d786ac920e411b1a4ce">XMC_HRPWM_CSG_SWSM_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CSG - Initial DAC start mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadfaa9ad3d5d14d786ac920e411b1a4ceac376ee6cab4cee7d955b546b7c2d5a42"></a>XMC_HRPWM_CSG_SWSM_DSV2_W_TRIGGER&#160;</td><td class="fielddoc"><p>DSV2 is used as initial DAC value &amp; conversion trigger is generated </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadfaa9ad3d5d14d786ac920e411b1a4cea0079b7b28d79c71e6a10f9994abbcd68"></a>XMC_HRPWM_CSG_SWSM_DSV1_W_TRIGGER&#160;</td><td class="fielddoc"><p>DSV1 is used as initial DAC value &amp; conversion trigger is generated </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadfaa9ad3d5d14d786ac920e411b1a4cea13833815422a403579064732e26f9d41"></a>XMC_HRPWM_CSG_SWSM_DSV2_NO_TRIGGER&#160;</td><td class="fielddoc"><p>DSV2 is used as initial DAC value &amp; no conversion trigger generated </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadfaa9ad3d5d14d786ac920e411b1a4cea0c606a7c660d681deae1115003b55704"></a>XMC_HRPWM_CSG_SWSM_DSV1_NO_TRIGGER&#160;</td><td class="fielddoc"><p>DSV1 is used as initial DAC value &amp; no conversion trigger generated </p>
</td></tr>
</table>

</div>
</div>
<a id="gacab1ecd6e6319fac1fd6b005d9ee79bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacab1ecd6e6319fac1fd6b005d9ee79bd">&#9670;&nbsp;</a></span>XMC_HRPWM_DAC_SLOPE_GEN_STATUS_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gacab1ecd6e6319fac1fd6b005d9ee79bd">XMC_HRPWM_DAC_SLOPE_GEN_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DAC slope generation status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacab1ecd6e6319fac1fd6b005d9ee79bda050cdd15580b5e9f4791576028c82e4c"></a>XMC_HRPWM_DAC_SLOPE_GEN_STATUS_DAC0&#160;</td><td class="fielddoc"><p>Slope generation status mask for DAC0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacab1ecd6e6319fac1fd6b005d9ee79bda03ce61083ba8d3a8998968990d2d194e"></a>XMC_HRPWM_DAC_SLOPE_GEN_STATUS_DAC1&#160;</td><td class="fielddoc"><p>Slope generation status mask for DAC1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacab1ecd6e6319fac1fd6b005d9ee79bda12fd44409d9952627473663439ea42bb"></a>XMC_HRPWM_DAC_SLOPE_GEN_STATUS_DAC2&#160;</td><td class="fielddoc"><p>Slope generation status mask for DAC2 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga92348e75fa87c899d8e1e42b17ade149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92348e75fa87c899d8e1e42b17ade149">&#9670;&nbsp;</a></span>XMC_HRPWM_FUNC_STATUS_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga92348e75fa87c899d8e1e42b17ade149">XMC_HRPWM_FUNC_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM function Enable / Disable status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga92348e75fa87c899d8e1e42b17ade149ab31f03c65aef9e49b739d6c86feb00e3"></a>XMC_HRPWM_FUNC_STATUS_DISABLE&#160;</td><td class="fielddoc"><p>Function is disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga92348e75fa87c899d8e1e42b17ade149a9571af846803ca7a14645570e9ee2b53"></a>XMC_HRPWM_FUNC_STATUS_ENABLE&#160;</td><td class="fielddoc"><p>Function is enabled </p>
</td></tr>
</table>

</div>
</div>
<a id="gadfc15f0691fb89b0cfecc46a8422a39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfc15f0691fb89b0cfecc46a8422a39c">&#9670;&nbsp;</a></span>XMC_HRPWM_HR_LOGIC_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gadfc15f0691fb89b0cfecc46a8422a39c">XMC_HRPWM_HR_LOGIC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM high resolution module status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadfc15f0691fb89b0cfecc46a8422a39ca4477b73581be94c82737ec39baf54710"></a>XMC_HRPWM_HR_LOGIC_NOT_WORKING&#160;</td><td class="fielddoc"><p>High resolution signal path is switched off for all HRC channels </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadfc15f0691fb89b0cfecc46a8422a39ca67dd0ee226e9b0fdcb14a30429c7b5df"></a>XMC_HRPWM_HR_LOGIC_WORKING&#160;</td><td class="fielddoc"><p>High resolution signal path is switched on for all HRC channels </p>
</td></tr>
</table>

</div>
</div>
<a id="gacc779de5e6350ba1fffe4a4de2e5bfba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc779de5e6350ba1fffe4a4de2e5bfba">&#9670;&nbsp;</a></span>XMC_HRPWM_HR_PATH_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gacc779de5e6350ba1fffe4a4de2e5bfba">XMC_HRPWM_HR_PATH_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>High resolution paths for HRC channels </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacc779de5e6350ba1fffe4a4de2e5bfbaa4d298b1ce0fd6b7d85d75ef7b57f6262"></a>XMC_HRPWM_HR_PATH_HRC0&#160;</td><td class="fielddoc"><p>HRC0 path selected for High resolution </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacc779de5e6350ba1fffe4a4de2e5bfbaa6dabe10729a54b8d31b55fb5b189955a"></a>XMC_HRPWM_HR_PATH_HRC1&#160;</td><td class="fielddoc"><p>HRC1 path selected for High resolution </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacc779de5e6350ba1fffe4a4de2e5bfbaa71862a28aa914c1bf37a81dd15963e87"></a>XMC_HRPWM_HR_PATH_HRC2&#160;</td><td class="fielddoc"><p>HRC2 path selected for High resolution </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacc779de5e6350ba1fffe4a4de2e5bfbaa2f2deb15f8bebfe2a4b1a762eb0443ed"></a>XMC_HRPWM_HR_PATH_HRC3&#160;</td><td class="fielddoc"><p>HRC3 path selected for High resolution </p>
</td></tr>
</table>

</div>
</div>
<a id="gac26495c9b452d11e893e55a996d1cdd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac26495c9b452d11e893e55a996d1cdd2">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_CMP_SEL_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gac26495c9b452d11e893e55a996d1cdd2">XMC_HRPWM_HRC_CMP_SEL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM HRC source selector - connection of source selector to which CSG unit </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac26495c9b452d11e893e55a996d1cdd2a18a76a8a907ee1de11113d0afe76dcf0"></a>XMC_HRPWM_HRC_CMP_SEL_CSG0&#160;</td><td class="fielddoc"><p>Comparator output of CSG0 selected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac26495c9b452d11e893e55a996d1cdd2a8fbb55579d809bb272b8c821494d9757"></a>XMC_HRPWM_HRC_CMP_SEL_CSG1&#160;</td><td class="fielddoc"><p>Comparator output of CSG1 selected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac26495c9b452d11e893e55a996d1cdd2ab4407dbb078a545c7897b65e900a876d"></a>XMC_HRPWM_HRC_CMP_SEL_CSG2&#160;</td><td class="fielddoc"><p>Comparator output of CSG2 selected </p>
</td></tr>
</table>

</div>
</div>
<a id="ga184f2491fe7a58b2e674dbda3d73117a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga184f2491fe7a58b2e674dbda3d73117a">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_DT_TR_SEL_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga184f2491fe7a58b2e674dbda3d73117a">XMC_HRPWM_HRC_DT_TR_SEL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRC dead time shadow transfer trigger selection </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga184f2491fe7a58b2e674dbda3d73117aa276d12f130be8e58db9f375ba958fbfb"></a>XMC_HRPWM_HRC_DT_TR_SEL_TIMER&#160;</td><td class="fielddoc"><p>Source for shadow transfer trigger is CCU8 timer. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga184f2491fe7a58b2e674dbda3d73117aaa1fa6324cf9cd399b274f9bb6b59b31a"></a>XMC_HRPWM_HRC_DT_TR_SEL_OVERFLOW&#160;</td><td class="fielddoc"><p>Source for shadow transfer trigger is dead time timer overflow. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga16f08ec4aff668ebdebfd70a349cbd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16f08ec4aff668ebdebfd70a349cbd1f">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_HR_EDGE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga16f08ec4aff668ebdebfd70a349cbd1f">XMC_HRPWM_HRC_HR_EDGE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM HRC High Resolution mode configuration </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga16f08ec4aff668ebdebfd70a349cbd1fa56d0180694583b094e88db77b62c1814"></a>XMC_HRPWM_HRC_HR_EDGE_SEL_RISING&#160;</td><td class="fielddoc"><p>Rising edge high resolution signal positioning enabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga16f08ec4aff668ebdebfd70a349cbd1fafe9671b81928027a60ead898c3507189"></a>XMC_HRPWM_HRC_HR_EDGE_SEL_FALLING&#160;</td><td class="fielddoc"><p>Falling edge high resolution signal positioning enabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga16f08ec4aff668ebdebfd70a349cbd1fa5681e0efecb186e78b1c4d6ed3913696"></a>XMC_HRPWM_HRC_HR_EDGE_SEL_BOTH&#160;</td><td class="fielddoc"><p>Both edges high resolution signal positioning enabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga16f08ec4aff668ebdebfd70a349cbd1fa092af1c8745545f06de70458537b55e4"></a>XMC_HRPWM_HRC_HR_EDGE_SEL_NONE&#160;</td><td class="fielddoc"><p>No high resolution signal positioning </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6eb1fabdd95cf5e09fcb2d5eb8d52b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eb1fabdd95cf5e09fcb2d5eb8d52b9a">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_OUT_PASSIVE_LVL_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga6eb1fabdd95cf5e09fcb2d5eb8d52b9a">XMC_HRPWM_HRC_OUT_PASSIVE_LVL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM HRC output - Passive level </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6eb1fabdd95cf5e09fcb2d5eb8d52b9aa308afa35abd98e7402e0f01e33b7476b"></a>XMC_HRPWM_HRC_OUT_PASSIVE_LVL_LOW&#160;</td><td class="fielddoc"><p>Passive low output </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6eb1fabdd95cf5e09fcb2d5eb8d52b9aae96e41a521efcef92ef5e663eace6bc2"></a>XMC_HRPWM_HRC_OUT_PASSIVE_LVL_HIGH&#160;</td><td class="fielddoc"><p>Passive high output </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1430f4a0749968e47a744fc40009384b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1430f4a0749968e47a744fc40009384b">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_SHADOW_TX_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga1430f4a0749968e47a744fc40009384b">XMC_HRPWM_HRC_SHADOW_TX_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shadow transfer for HRC values The enum is used to access the bitfields of registers HRCSTRG, HRCCTRG, HRCSTSG </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1430f4a0749968e47a744fc40009384ba67b4e893c468ebf59cc14bd5e1f41e3f"></a>XMC_HRPWM_HRC_SHADOW_TX_HRC0_VALUE&#160;</td><td class="fielddoc"><p>HRC0 shadow transfer mask for CR1 &amp; CR2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1430f4a0749968e47a744fc40009384ba2f0a7f12a2014a563f428fcde7c989a3"></a>XMC_HRPWM_HRC_SHADOW_TX_HRC0_DT_VALUE&#160;</td><td class="fielddoc"><p>HRC0 shadow transfer mask for DCR &amp; DCRF </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1430f4a0749968e47a744fc40009384bad575224637f8b87089224c6d30b74274"></a>XMC_HRPWM_HRC_SHADOW_TX_HRC1_VALUE&#160;</td><td class="fielddoc"><p>HRC1 shadow transfer mask for CR1 &amp; CR2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1430f4a0749968e47a744fc40009384ba4bd5ff0af30e3fcb1075abe5b0d5c0df"></a>XMC_HRPWM_HRC_SHADOW_TX_HRC1_DT_VALUE&#160;</td><td class="fielddoc"><p>HRC1 shadow transfer mask for DCR &amp; DCRF </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1430f4a0749968e47a744fc40009384ba6cd7ddb733e1cd4c6ba45ca0de6131c5"></a>XMC_HRPWM_HRC_SHADOW_TX_HRC2_VALUE&#160;</td><td class="fielddoc"><p>HRC2 shadow transfer mask for CR1 &amp; CR2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1430f4a0749968e47a744fc40009384ba9ddf09e633e672f4ff05e2b70c87a631"></a>XMC_HRPWM_HRC_SHADOW_TX_HRC2_DT_VALUE&#160;</td><td class="fielddoc"><p>HRC2 shadow transfer mask for DCR &amp; DCRF </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1430f4a0749968e47a744fc40009384ba26d0c9fc52f4da230b0f271ef3cb1e0f"></a>XMC_HRPWM_HRC_SHADOW_TX_HRC3_VALUE&#160;</td><td class="fielddoc"><p>HRC3 shadow transfer mask for CR1 &amp; CR2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1430f4a0749968e47a744fc40009384ba415782d9160fedb66856bad233005d8a"></a>XMC_HRPWM_HRC_SHADOW_TX_HRC3_DT_VALUE&#160;</td><td class="fielddoc"><p>HRC3 shadow transfer mask for DCR &amp; DCRF </p>
</td></tr>
</table>

</div>
</div>
<a id="ga723536b1c6bed71c7369defade462741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga723536b1c6bed71c7369defade462741">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_SOURCE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga723536b1c6bed71c7369defade462741">XMC_HRPWM_HRC_SOURCE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HR source selector </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga723536b1c6bed71c7369defade462741a24d0393de4728f78fe0426c764e7f700"></a>XMC_HRPWM_HRC_SOURCE_0&#160;</td><td class="fielddoc"><p>High resolution source 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga723536b1c6bed71c7369defade462741a5088fd11251f4ce5b7eaca6ad4ef0b70"></a>XMC_HRPWM_HRC_SOURCE_1&#160;</td><td class="fielddoc"><p>High resolution source 1 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga898488583126f170c29de20ad78e7f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga898488583126f170c29de20ad78e7f96">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_SRC_EDGE_SEL_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga898488583126f170c29de20ad78e7f96">XMC_HRPWM_HRC_SRC_EDGE_SEL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HR source selector edge configuration (GSEL) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga898488583126f170c29de20ad78e7f96aea7755cb2aeb42a190ce56ddf25c2dea"></a>XMC_HRPWM_HRC_SRC_EDGE_SEL_DISABLED&#160;</td><td class="fielddoc"><p>source signal generation disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga898488583126f170c29de20ad78e7f96ab8de8ddf4006bcd6c0793d45b31973f5"></a>XMC_HRPWM_HRC_SRC_EDGE_SEL_RISING&#160;</td><td class="fielddoc"><p>source signal generation on rising edge </p>
</td></tr>
<tr><td class="fieldname"><a id="gga898488583126f170c29de20ad78e7f96acc3e3e9be9cd4c7d21f216fcd24897d2"></a>XMC_HRPWM_HRC_SRC_EDGE_SEL_FALLING&#160;</td><td class="fielddoc"><p>source signal generation on falling edge </p>
</td></tr>
<tr><td class="fieldname"><a id="gga898488583126f170c29de20ad78e7f96a6b95390c45734a5de70086de8f08b2bb"></a>XMC_HRPWM_HRC_SRC_EDGE_SEL_BOTH&#160;</td><td class="fielddoc"><p>source signal generation on both edges </p>
</td></tr>
</table>

</div>
</div>
<a id="gaab18b9caec75ff8940a250d265706f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab18b9caec75ff8940a250d265706f3c">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_SRC_INPUT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gaab18b9caec75ff8940a250d265706f3c">XMC_HRPWM_HRC_SRC_INPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM HRC source selector input </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaab18b9caec75ff8940a250d265706f3ca81042ecdb9df44aa4bb7f5a65ed7e7ce"></a>XMC_HRPWM_HRC_SRC_INPUT_CCU&#160;</td><td class="fielddoc"><p>Source selector is controlled via CCU timer signal </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaab18b9caec75ff8940a250d265706f3cacc2541215cb7918fbd98ef21aee679ee"></a>XMC_HRPWM_HRC_SRC_INPUT_CSG&#160;</td><td class="fielddoc"><p>Source selector is controlled via CSG output signal </p>
</td></tr>
</table>

</div>
</div>
<a id="gae0bbc6eaf0460ede1b5331a0ddb8d23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0bbc6eaf0460ede1b5331a0ddb8d23b">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_TIMER_SEL_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gae0bbc6eaf0460ede1b5331a0ddb8d23b">XMC_HRPWM_HRC_TIMER_SEL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM HRC source selector - connection of source selector to which CCU timer </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae0bbc6eaf0460ede1b5331a0ddb8d23bad9581792eb463154788807b4e77c3454"></a>XMC_HRPWM_HRC_TIMER_SEL_CCU_CC0&#160;</td><td class="fielddoc"><p>CCU timer 0 selected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae0bbc6eaf0460ede1b5331a0ddb8d23ba343602ab6ae844d4739313343760fb8a"></a>XMC_HRPWM_HRC_TIMER_SEL_CCU_CC1&#160;</td><td class="fielddoc"><p>CCU timer 1 selected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae0bbc6eaf0460ede1b5331a0ddb8d23baf9ec325058fb8bc2e7ea31cd9559f38c"></a>XMC_HRPWM_HRC_TIMER_SEL_CCU_CC2&#160;</td><td class="fielddoc"><p>CCU timer 2 selected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae0bbc6eaf0460ede1b5331a0ddb8d23ba3372387d31d07efb301d300f94f92845"></a>XMC_HRPWM_HRC_TIMER_SEL_CCU_CC3&#160;</td><td class="fielddoc"><p>CCU timer 3 selected </p>
</td></tr>
</table>

</div>
</div>
<a id="ga79a24ebb2df99867180c7e676dc4815e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79a24ebb2df99867180c7e676dc4815e">&#9670;&nbsp;</a></span>XMC_HRPWM_LR_PATH_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga79a24ebb2df99867180c7e676dc4815e">XMC_HRPWM_LR_PATH_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low resolution paths for HRC channels. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga79a24ebb2df99867180c7e676dc4815eacc8dd46b6369d282a8a06024419c1406"></a>XMC_HRPWM_LR_PATH_HRC0&#160;</td><td class="fielddoc"><p>LRC0 path selected for Low resolution </p>
</td></tr>
<tr><td class="fieldname"><a id="gga79a24ebb2df99867180c7e676dc4815eae96a7ea05fbf2c6fb19c092000f16761"></a>XMC_HRPWM_LR_PATH_HRC1&#160;</td><td class="fielddoc"><p>LRC0 path selected for Low resolution </p>
</td></tr>
<tr><td class="fieldname"><a id="gga79a24ebb2df99867180c7e676dc4815ea08ded09de47f2f2ec3ec02e2a726a21d"></a>XMC_HRPWM_LR_PATH_HRC2&#160;</td><td class="fielddoc"><p>LRC0 path selected for Low resolution </p>
</td></tr>
<tr><td class="fieldname"><a id="gga79a24ebb2df99867180c7e676dc4815ea81834fd31dfd486149e4f9bc15230f2f"></a>XMC_HRPWM_LR_PATH_HRC3&#160;</td><td class="fielddoc"><p>LRC0 path selected for Low resolution </p>
</td></tr>
</table>

</div>
</div>
<a id="ga672aedcae59032f2f63c9096b6bb4c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga672aedcae59032f2f63c9096b6bb4c46">&#9670;&nbsp;</a></span>XMC_HRPWM_SHADOW_TX_DAC_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#ga672aedcae59032f2f63c9096b6bb4c46">XMC_HRPWM_SHADOW_TX_DAC_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HRPWM CSG - DAC shadow transfer values </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga672aedcae59032f2f63c9096b6bb4c46a3bfd92c775f4eec23cf071f4f1767450"></a>XMC_HRPWM_SHADOW_TX_DAC0&#160;</td><td class="fielddoc"><p>Shadow transfer mask for DAC0 - reference value 1 &amp; Pulse swallow value </p>
</td></tr>
<tr><td class="fieldname"><a id="gga672aedcae59032f2f63c9096b6bb4c46a6aa8f303a42ef581734e40d8dbf770a8"></a>XMC_HRPWM_SHADOW_TX_DAC1&#160;</td><td class="fielddoc"><p>Shadow transfer mask for DAC1 - reference value 1 &amp; Pulse swallow value </p>
</td></tr>
<tr><td class="fieldname"><a id="gga672aedcae59032f2f63c9096b6bb4c46ac8fad7336886382c89a56e314e0bfb76"></a>XMC_HRPWM_SHADOW_TX_DAC2&#160;</td><td class="fielddoc"><p>Shadow transfer mask for DAC2 - reference value 1 &amp; Pulse swallow value </p>
</td></tr>
</table>

</div>
</div>
<a id="gaebcd5453412b9ad26fd5ead0b712a377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebcd5453412b9ad26fd5ead0b712a377">&#9670;&nbsp;</a></span>XMC_HRPWM_STATUS_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___h_r_p_w_m.html#gaebcd5453412b9ad26fd5ead0b712a377">XMC_HRPWM_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return HRPWM driver status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaebcd5453412b9ad26fd5ead0b712a377abb8dccf4de33c444e3380cb78bd54972"></a>XMC_HRPWM_STATUS_OK&#160;</td><td class="fielddoc"><p>Driver successfully completed the request </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaebcd5453412b9ad26fd5ead0b712a377ad168a33043ec0611e536d415a7d66f83"></a>XMC_HRPWM_STATUS_BUSY&#160;</td><td class="fielddoc"><p>Driver busy, cannot handle request </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaebcd5453412b9ad26fd5ead0b712a377a2a367595a93dab01aec3ae44d6e7b685"></a>XMC_HRPWM_STATUS_ERROR&#160;</td><td class="fielddoc"><p>Driver cannot fulfill request, error occurred </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf3a5ac7570e49d783ed75a12cdf88f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3a5ac7570e49d783ed75a12cdf88f78">&#9670;&nbsp;</a></span>XMC_HRPWM_ClampComparatorOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_ClampComparatorOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga8f5cb84356dd14d33e4172435a921082">XMC_HRPWM_CSG_RUN_BIT_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Set the comparator output to clamp state<br />
 <br />
 Sets the comparator to clamped state via software by setting CSGSETG.SC0P bit. The output of comparator is now not dependent on its inputs pins. The clamped state is defined by comparator output passive level value. Output passive level can be set to high or low.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga29de546fde9846b8f575687d58003c19">XMC_HRPWM_UnClampComparatorOutput()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gaa2e042c070a7387a6a751f5cb58d05a8">XMC_HRPWM_IsComparatorClamped()</a><br />
 </dd></dl>

</div>
</div>
<a id="gaf357ce24027e53b8b4193ee77ca59455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf357ce24027e53b8b4193ee77ca59455">&#9670;&nbsp;</a></span>XMC_HRPWM_ClearPreScaler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_ClearPreScaler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#gacb53cbfc6388b50d5708abf4652823e5">XMC_HRPWM_CSG_PRESCALER_STATUS_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Clears the prescaler registers of DACs selected by mask<br />
<br />
 Clears the prescaler registers of DACs selected by mask, by setting CSGFCG.PS0CLR bit.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga9eef87ede9768c817a6db40515146c6c">XMC_HRPWM_IsPrescalerRunning()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga40d3c775623a29d040dedd36396f0d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40d3c775623a29d040dedd36396f0d93">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_ClrEventSW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_ClrEventSW </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga436f2a6ad7ee2320f30163997c9d8cd4">XMC_HRPWM_CSG_IRQ_ID_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">event</td><td>Event selected for software trigger. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Cancel software request for selected event<br />
<br />
 Cancel the Event trigger request performed via software.<br />
</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga9f88106af0b4f60104671a8b83fa9a22">XMC_HRPWM_CSG_EnableEvent()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga60db4fb03cc3b1e408176c256b76a054">XMC_HRPWM_CSG_GetEventStatus()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga8521d4a0084ae0f6b40c123766001508">XMC_HRPWM_CSG_SetSRNode()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga394b6ac2f679d704cedad3c2c101825b">XMC_HRPWM_CSG_SetEventSW()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga273e4eb2aa12fbcc959aa6ab5e69ea2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga273e4eb2aa12fbcc959aa6ab5e69ea2a">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_DACRefValSwitchingConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_DACRefValSwitchingConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___i_n_p_u_t___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_INPUT_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to configuration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Configure input selection for switching DAC value between DSV1 and DSV2.<br />
<br />
 Configure the signal used to switch DAC value between DSV1 and DSV2.<br />
 It configures the signal source, required edge or level. </dd></dl>

</div>
</div>
<a id="ga0c677e919aaf2c8fb77665abc0151eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c677e919aaf2c8fb77665abc0151eb8">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_DisableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_DisableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga436f2a6ad7ee2320f30163997c9d8cd4">XMC_HRPWM_CSG_IRQ_ID_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">event</td><td>Event selected for interrupt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Disables the interrupt<br />
<br />
 Disables the selected interrupt request which may be forwarded to service node.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga9f88106af0b4f60104671a8b83fa9a22">XMC_HRPWM_CSG_EnableEvent()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga60db4fb03cc3b1e408176c256b76a054">XMC_HRPWM_CSG_GetEventStatus()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga8521d4a0084ae0f6b40c123766001508">XMC_HRPWM_CSG_SetSRNode()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga9f88106af0b4f60104671a8b83fa9a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f88106af0b4f60104671a8b83fa9a22">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_EnableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_EnableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga436f2a6ad7ee2320f30163997c9d8cd4">XMC_HRPWM_CSG_IRQ_ID_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">event</td><td>Event selected for interrupt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Enables the interrupt<br />
<br />
 Enables the selected interrupt request which may be forwarded to service node. The enabled event may be connected to any of the four service nodes.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga0c677e919aaf2c8fb77665abc0151eb8">XMC_HRPWM_CSG_DisableEvent()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga60db4fb03cc3b1e408176c256b76a054">XMC_HRPWM_CSG_GetEventStatus()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga8521d4a0084ae0f6b40c123766001508">XMC_HRPWM_CSG_SetSRNode()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga60db4fb03cc3b1e408176c256b76a054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60db4fb03cc3b1e408176c256b76a054">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_GetEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_HRPWM_CSG_GetEventStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga436f2a6ad7ee2320f30163997c9d8cd4">XMC_HRPWM_CSG_IRQ_ID_t</a> to generate the input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Returns the bit encoded status of selected events<br />
<br />
 Checks the status of selected events. The return value is non-zero is the status is set.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga9f88106af0b4f60104671a8b83fa9a22">XMC_HRPWM_CSG_EnableEvent()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga8521d4a0084ae0f6b40c123766001508">XMC_HRPWM_CSG_SetSRNode()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga83cd1efa3726db819166c61f6604fbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83cd1efa3726db819166c61f6604fbf0">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to configuration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Initializes the CSG channel.<br />
<br />
 This function is used to initialize the CSG channel.<br />
<br />
These include:<br />
 1) Comparator setup.<br />
 2) DAC Configuration.<br />
 3) Slope generation configuration.<br />
 </dd></dl>

</div>
</div>
<a id="ga78f6e3566f854fe75f9fb50e39b37a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78f6e3566f854fe75f9fb50e39b37a43">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_SelBlankingInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_SelBlankingInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___i_n_p_u_t___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_INPUT_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to configuration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Configures the input signal to blank the comparator output<br />
<br />
 Configures the input signal that is used as trigger signal to blank the comparator output.<br />
 It configures the signal source, required edge or level. The comparator output is blanked and set to passive level. </dd></dl>

</div>
</div>
<a id="ga03b62754415e1b809501ebac0c3a7fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03b62754415e1b809501ebac0c3a7fa1">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_SelClampingInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_SelClampingInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___i_n_p_u_t___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_INPUT_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to configuration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Configures the input signal to clamp the comparator output<br />
<br />
 Configures the input signal that is used as level signal to clamp the comparator output.<br />
 It configures the signal source and required level. </dd></dl>

</div>
</div>
<a id="ga6158089646f9e247a10868f690da809c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6158089646f9e247a10868f690da809c">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_SelSlopeGenClkInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_SelSlopeGenClkInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___h_r_p_w_m.html#gaa330fc9a084b311a86fc3dd42e0eccce">XMC_HRPWM_CSG_CLK_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input_clk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">input_clk</td><td>Clock selection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Select the clock for slope generation<br />
<br />
 Selects the clock source used for slope generation.<br />
 These are : <br />
 module clock <br />
 external clock A <br />
 external clock B <br />
 external clock C <br />
 </dd></dl>

</div>
</div>
<a id="ga805831cc2749a83373f6d0b0006bac38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga805831cc2749a83373f6d0b0006bac38">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_SetCMPInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_SetCMPInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___h_r_p_w_m.html#ga5da5acbc4ffb20968d49a8b9c3a0f3c5">XMC_HRPWM_CSG_CMP_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">input</td><td>Input to comparator. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga5da5acbc4ffb20968d49a8b9c3a0f3c5">XMC_HRPWM_CSG_CMP_INPUT_t</a> to generate the input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Configures the input connection to inverting pin of comparator<br />
<br />
 Selects the HW pin that gets connected to inverting pin of comparator.<br />
 Either CINA or CINB can be set. The non-inverting pin is connected to DAC output.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#gad197514e3c3e7f409ea3b98422085be5">XMC_HRPWM_GetCMPInput()</a> </dd></dl>

</div>
</div>
<a id="ga394b6ac2f679d704cedad3c2c101825b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga394b6ac2f679d704cedad3c2c101825b">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_SetEventSW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_SetEventSW </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga436f2a6ad7ee2320f30163997c9d8cd4">XMC_HRPWM_CSG_IRQ_ID_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">event</td><td>Event selected for software trigger. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Software request for selected event<br />
<br />
 Perform a software request for selected event.This overrides any hardware trigger.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga9f88106af0b4f60104671a8b83fa9a22">XMC_HRPWM_CSG_EnableEvent()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga60db4fb03cc3b1e408176c256b76a054">XMC_HRPWM_CSG_GetEventStatus()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga8521d4a0084ae0f6b40c123766001508">XMC_HRPWM_CSG_SetSRNode()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga40d3c775623a29d040dedd36396f0d93">XMC_HRPWM_CSG_ClrEventSW()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga8521d4a0084ae0f6b40c123766001508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8521d4a0084ae0f6b40c123766001508">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_SetSRNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_SetSRNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___h_r_p_w_m.html#ga436f2a6ad7ee2320f30163997c9d8cd4">XMC_HRPWM_CSG_IRQ_ID_t</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___h_r_p_w_m.html#ga74fab5ae35406664bf3be96687597b13">XMC_HRPWM_CSG_IRQ_SR_LINE_t</a>&#160;</td>
          <td class="paramname"><em>sr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">event</td><td>Event selected for interrupt. </td></tr>
    <tr><td class="paramname">sr</td><td>Service request node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Connects the interrupt request to serve node<br />
<br />
 Enables the connection between interrupt request and serve node.<br />
 Each event may be connected to any of four service node available. Each event/interrupt needs to be enabled individually.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga9f88106af0b4f60104671a8b83fa9a22">XMC_HRPWM_CSG_EnableEvent()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga60db4fb03cc3b1e408176c256b76a054">XMC_HRPWM_CSG_GetEventStatus()</a><br />
 </dd></dl>

</div>
</div>
<a id="gadb0c65380f210e989267c42099b28b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb0c65380f210e989267c42099b28b56">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_StartSlopeGenConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_StartSlopeGenConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___i_n_p_u_t___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_INPUT_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to configuration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Configures the input signal to start the DAC slope generation<br />
<br />
 Configures the input signal that is used as trigger signal to start the slope generation.<br />
 It configures the signal source, required edge or level.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#gaa7da6d834d100038306930f455459d17">XMC_HRPWM_CSG_StopSlopeGenConfig()</a><br />
 </dd></dl>

</div>
</div>
<a id="gaa7da6d834d100038306930f455459d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7da6d834d100038306930f455459d17">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_StopSlopeGenConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_StopSlopeGenConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___i_n_p_u_t___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_INPUT_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to configuration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Configures the input signal to stop the DAC slope generation<br />
<br />
 Configures the input that is used as trigger signal to stop the slope generation.<br />
 It configures the signal source, required edge or level.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#gadb0c65380f210e989267c42099b28b56">XMC_HRPWM_CSG_StartSlopeGenConfig()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga4cf121ecbb1cd7332e49b82ffe2f972b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cf121ecbb1cd7332e49b82ffe2f972b">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_TriggerDACConvConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_TriggerDACConvConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___i_n_p_u_t___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_INPUT_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to configuration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Configures the input signal to trigger the DAC conversion<br />
<br />
 Configures the input signal that is used as trigger signal to perform the DAC conversion.<br />
 It configures the signal source, required edge or level.<br />
 This is used when DAC is configured in <b>static mode</b>. </dd></dl>

</div>
</div>
<a id="gaad6ba2cd0b1ce2b037b1d54435ea214c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad6ba2cd0b1ce2b037b1d54435ea214c">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_TriggerShadowXferConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_TriggerShadowXferConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___h_r_p_w_m___c_s_g___i_n_p_u_t___c_o_n_f_i_g__t.html">XMC_HRPWM_CSG_INPUT_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to configuration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Configure input selection for triggering shadow transfer<br />
<br />
 Configure the signal used to triggering shadow transfer.<br />
 It configures the signal source, required edge or level. </dd></dl>

</div>
</div>
<a id="ga9bb9d294b29b27fcf713f23da951c116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bb9d294b29b27fcf713f23da951c116">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_UpdateBlankingValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_UpdateBlankingValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">value</td><td>Value to be written to blanking register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Updates the BLV register<br />
<br />
 Updates the blanking register.<br />
 Note BLV register does not have shadow register. </dd></dl>

</div>
</div>
<a id="ga9667846d88cec6c51618bf2d239f5a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9667846d88cec6c51618bf2d239f5a8c">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_UpdateDACPrescaler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_UpdateDACPrescaler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga667011f4c74780559bac6963d2774553">XMC_HRPWM_CSG_PRESCALER_DIVISION_t</a>&#160;</td>
          <td class="paramname"><em>div_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">div_value</td><td>Prescaler value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Updates the prescaler value of slope generation<br />
<br />
 Updates the prescaler value of slope generation by setting SC.PSV The rate of DAC value update is determined by prescaler.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga33d76f330edc72e2604b3d92c1e67628">XMC_HRPWM_CSG_UpdateDACStepGain()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga08079e3c838977218a439da7476c16d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08079e3c838977218a439da7476c16d8">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_UpdateDACRefDSV1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_UpdateDACRefDSV1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">value</td><td>Value to be written to DSV1 shadow register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Updates the DSV1 shadow register<br />
<br />
 Update the DSV1 shadow register.<br />
 Call the shadow transfer update API. A shadow transfer request in corresponding CCU8 slice may also be required.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga445cb2483edf80fa5b1a8c6fd74948e0">XMC_HRPWM_EnableHighResolutionShadowTransfer()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga0c3541e919f14b6a7c58d22c39bbbcd6">XMC_HRPWM_CSG_UpdateDACRefDSV2()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga0c3541e919f14b6a7c58d22c39bbbcd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c3541e919f14b6a7c58d22c39bbbcd6">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_UpdateDACRefDSV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_UpdateDACRefDSV2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">value</td><td>Value to be written to DSV2 register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Updates the DSV2 register<br />
<br />
 Updates the DSV2 register.<br />
 Note DSV2 register does not have shadow register.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga08079e3c838977218a439da7476c16d8">XMC_HRPWM_CSG_UpdateDACRefDSV1()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga33d76f330edc72e2604b3d92c1e67628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33d76f330edc72e2604b3d92c1e67628">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_UpdateDACStepGain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_UpdateDACStepGain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#gafbfe1cccf9f90e5f91d492c67907ba3a">XMC_HRPWM_CSG_SLOPE_STEP_GAIN_t</a>&#160;</td>
          <td class="paramname"><em>gain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">gain</td><td>Gain value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Updates the gain value of slope generation<br />
<br />
 Updates the gain value of slope generation by setting SC.GCFG bits. The value by which DAC increments/decrements is determined by the step gain.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga9667846d88cec6c51618bf2d239f5a8c">XMC_HRPWM_CSG_UpdateDACPrescaler()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga9841d1826a3ee415c1feee990c341f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9841d1826a3ee415c1feee990c341f65">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_UpdateFilterWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_UpdateFilterWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga7bd4884f6c1a92640cfc91ea62556f47">XMC_HRPWM_CSG_CMP_FILTER_WINDOW_t</a>&#160;</td>
          <td class="paramname"><em>window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">window</td><td>Size of filter window. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Updates the filter window size<br />
<br />
 Updates the filter window size used for pulse swallowing, in slope generation.<br />
 This value is used in slope generation when filter window is enabled. A certain no of clock pulses in the filter window are swallowed and applied to slope generation. The pulse swallowed are determined by "Pulse swallow value"</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga464b5b593e11eaa98fb82827ee014a46">XMC_HRPWM_CSG_UpdatePulseClk()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga464b5b593e11eaa98fb82827ee014a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga464b5b593e11eaa98fb82827ee014a46">&#9670;&nbsp;</a></span>XMC_HRPWM_CSG_UpdatePulseClk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_CSG_UpdatePulseClk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga3acaa9244c28bd19d7c2bff6764edfec">XMC_HRPWM_CSG_t</a> *const&#160;</td>
          <td class="paramname"><em>csg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csg</td><td>Constant pointer to XMC_HRPWM_CSG_t, pointing to the CSG channel base address </td></tr>
    <tr><td class="paramname">value</td><td>No of clock pulses to be swallowed in the filter window. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Updates the no of clock pulses to be swallowed in the filter window<br />
<br />
 Update the pulse swallow value.<br />
 This value is used in slope generation when filter window is enabled for slope generation. No of clock pulse swallow is determined by this value.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga9841d1826a3ee415c1feee990c341f65">XMC_HRPWM_CSG_UpdateFilterWindow()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga3a85578ea5b24d2d2c697d17f182bf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a85578ea5b24d2d2c697d17f182bf91">&#9670;&nbsp;</a></span>XMC_HRPWM_DisableBias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_DisableBias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Disables the bias generation<br />
<br />
 Disables the bias generation of high resolution generation by clearing HRBSC.HRBE bit.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#gad10658881a91d3000301eff5df84ac17">XMC_HRPWM_EnableBias()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga3d9504e5573ab6ed0e2f1b07f67831d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d9504e5573ab6ed0e2f1b07f67831d6">&#9670;&nbsp;</a></span>XMC_HRPWM_DisableComparatorShadowTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_DisableComparatorShadowTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga672aedcae59032f2f63c9096b6bb4c46">XMC_HRPWM_SHADOW_TX_DAC_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Cancels the shadow transfer of DSV1 and pulse swallow registers<br />
<br />
 Cancels the shadow transfer of DSV1 and pulse swallow registers by setting CSGTRC.D0SEC bit. The transfer request is canceled. Needs to be called before the next shadow transfer trigger.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#gad476f8353f1345158a0f55b3ccb4da98">XMC_HRPWM_EnableComparatorShadowTransfer()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gac9d54d78a8f4e342eafed7040e2f9d43">XMC_HRPWM_GetComparatorShadowTransferStatus()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga54a7856ac4e8d8a68fb91a850cb727b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54a7856ac4e8d8a68fb91a850cb727b2">&#9670;&nbsp;</a></span>XMC_HRPWM_DisableCsgClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_DisableCsgClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#gaf65bccdc3328dbd26b681fb5d0304c4d">XMC_HRPWM_CSG_CLK_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Disables the clock of selected CSG subunits<br />
<br />
 Disables the clock of selected CSG subunits by setting the CSGCFG.C0CD bit.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd></dd></dl>

</div>
</div>
<a id="ga65994066d50af817523e4bd23284073c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65994066d50af817523e4bd23284073c">&#9670;&nbsp;</a></span>XMC_HRPWM_DisableGlobalHR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_DisableGlobalHR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Disable global high resolution generation<br />
<br />
 Disables global high resolution generation by clearing GLBANA.GHREN bit.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga061facdca6896f543e7a10ecc1eed696">XMC_HRPWM_EnableGlobalHR()</a><br />
 </dd></dl>

</div>
</div>
<a id="gad5b7cea1c88b33f35c15e928fc88d8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b7cea1c88b33f35c15e928fc88d8d5">&#9670;&nbsp;</a></span>XMC_HRPWM_DisableHighResolutionPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_DisableHighResolutionPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected HRC modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#gacc779de5e6350ba1fffe4a4de2e5bfba">XMC_HRPWM_HR_PATH_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Disables the high resolution path<br />
<br />
 Disables the high resolution path determined by passed mask value, by clearing HRCCFG.HRC0E bit.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga6b02902e05248a345d3a75226ab2eb76">XMC_HRPWM_EnableHighResolutionPath()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gaf027dc9fd7d9c64c7316e2bc2874ebf2">XMC_HRPWM_EnableLowResolutionPath()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga7b43ac44b227a27a44628b87b0e46f11">XMC_HRPWM_DisableLowResolutionPath()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga5a4878a32203c629ac659aef582fc1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a4878a32203c629ac659aef582fc1a1">&#9670;&nbsp;</a></span>XMC_HRPWM_DisableHighResolutionShadowTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_DisableHighResolutionShadowTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected HRC modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga1430f4a0749968e47a744fc40009384b">XMC_HRPWM_HRC_SHADOW_TX_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Disables the high resolution shadow transfer<br />
<br />
 Disables the high resolution shadow transfer determined by passed mask value, by setting HRCCTRG.H0EC, HRCCTRG.H0DEC bits. It cancels shadow transfer request by <a class="el" href="group___h_r_p_w_m.html#ga445cb2483edf80fa5b1a8c6fd74948e0">XMC_HRPWM_EnableHighResolutionShadowTransfer()</a>, provided the shadow transfer has not occurred.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga445cb2483edf80fa5b1a8c6fd74948e0">XMC_HRPWM_EnableHighResolutionShadowTransfer()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga06c6e822633e604ddab01f871bf25574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06c6e822633e604ddab01f871bf25574">&#9670;&nbsp;</a></span>XMC_HRPWM_DisableHRPowerMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_DisableHRPowerMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Turns OFF the power to all HR and LR path<br />
<br />
 Turns OFF the power to all HR and LR path by clearing HRCCFG.HRCPM bit. This disables all HR and LR paths.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#gaabcf1cff107c2ae113407befb7b0412a">XMC_HRPWM_EnableHRPowerMode()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga7b43ac44b227a27a44628b87b0e46f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b43ac44b227a27a44628b87b0e46f11">&#9670;&nbsp;</a></span>XMC_HRPWM_DisableLowResolutionPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_DisableLowResolutionPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected HRC modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga79a24ebb2df99867180c7e676dc4815e">XMC_HRPWM_LR_PATH_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Disables the low resolution path<br />
<br />
 Disables the low resolution path determined by passed mask value, by clearing HRCCFG.LRC0E bit.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga6b02902e05248a345d3a75226ab2eb76">XMC_HRPWM_EnableHighResolutionPath()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gad5b7cea1c88b33f35c15e928fc88d8d5">XMC_HRPWM_DisableHighResolutionPath()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gaf027dc9fd7d9c64c7316e2bc2874ebf2">XMC_HRPWM_EnableLowResolutionPath()</a><br />
 </dd></dl>

</div>
</div>
<a id="gad10658881a91d3000301eff5df84ac17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad10658881a91d3000301eff5df84ac17">&#9670;&nbsp;</a></span>XMC_HRPWM_EnableBias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_EnableBias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Enables the bias generation<br />
<br />
 Enables the bias generation of high resolution generation by setting HRBSC.HRBE bit.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga3a85578ea5b24d2d2c697d17f182bf91">XMC_HRPWM_DisableBias()</a><br />
 </dd></dl>

</div>
</div>
<a id="gad476f8353f1345158a0f55b3ccb4da98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad476f8353f1345158a0f55b3ccb4da98">&#9670;&nbsp;</a></span>XMC_HRPWM_EnableComparatorShadowTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_EnableComparatorShadowTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected HRC modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga672aedcae59032f2f63c9096b6bb4c46">XMC_HRPWM_SHADOW_TX_DAC_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Enables the shadow transfer of DSV1 and pulse swallow registers of DACs selected by mask<br />
<br />
 Enables the shadow transfer of DSV1 and pulse swallow registers of DACs selected by mask by setting CSGTRG.D0SES bit. The transfer is done at the next shadow transfer trigger.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga3d9504e5573ab6ed0e2f1b07f67831d6">XMC_HRPWM_DisableComparatorShadowTransfer()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gac9d54d78a8f4e342eafed7040e2f9d43">XMC_HRPWM_GetComparatorShadowTransferStatus()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga061facdca6896f543e7a10ecc1eed696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga061facdca6896f543e7a10ecc1eed696">&#9670;&nbsp;</a></span>XMC_HRPWM_EnableGlobalHR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_EnableGlobalHR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Enable global high resolution generation<br />
<br />
 Enables global high resolution generation by setting GLBANA.GHREN bit.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga65994066d50af817523e4bd23284073c">XMC_HRPWM_DisableGlobalHR()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga6b02902e05248a345d3a75226ab2eb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b02902e05248a345d3a75226ab2eb76">&#9670;&nbsp;</a></span>XMC_HRPWM_EnableHighResolutionPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_EnableHighResolutionPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected HRC modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#gacc779de5e6350ba1fffe4a4de2e5bfba">XMC_HRPWM_HR_PATH_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd><br />
Enables the high resolution path.<br />
<br />
 Enables the high resolution path determined by passed mask value, by setting HRCCFG.HRC0E bit. By default signals from source selector 0 are linked to HR path and signals from source selector 1 are linked to LR path. This connections can be reversed at runtime, if bit HRCySC.ST is set to 1.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga662c21ff0c66afdb96e049f45d6a67ea">XMC_HRPWM_HRC_Set_HR_Source()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gad5b7cea1c88b33f35c15e928fc88d8d5">XMC_HRPWM_DisableHighResolutionPath()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gaf027dc9fd7d9c64c7316e2bc2874ebf2">XMC_HRPWM_EnableLowResolutionPath()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga7b43ac44b227a27a44628b87b0e46f11">XMC_HRPWM_DisableLowResolutionPath()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gaabcf1cff107c2ae113407befb7b0412a">XMC_HRPWM_EnableHRPowerMode()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga445cb2483edf80fa5b1a8c6fd74948e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga445cb2483edf80fa5b1a8c6fd74948e0">&#9670;&nbsp;</a></span>XMC_HRPWM_EnableHighResolutionShadowTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_EnableHighResolutionShadowTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected HRC modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga1430f4a0749968e47a744fc40009384b">XMC_HRPWM_HRC_SHADOW_TX_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Enables the high resolution shadow transfer<br />
 <br />
 Enables the high resolution shadow transfer determined by passed mask value, by setting HRCSTRG.H0ES, HRCSTRG.H0DES bits. The input for trigger for shadow transfer needs to be configured correctly.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga5a4878a32203c629ac659aef582fc1a1">XMC_HRPWM_DisableHighResolutionShadowTransfer()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga80c1e83e5135d8548b33f4fba38d626b">XMC_HRPWM_GetHighResolutionShadowTransferStatus()</a><br />
 </dd></dl>

</div>
</div>
<a id="gaabcf1cff107c2ae113407befb7b0412a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabcf1cff107c2ae113407befb7b0412a">&#9670;&nbsp;</a></span>XMC_HRPWM_EnableHRPowerMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_EnableHRPowerMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Turns ON the power to all HR and LR path<br />
<br />
 Turns ON the power to all HR and LR path by setting HRCCFG.HRCPM bit. Enable the HR and LR paths as per requirement by calling following API <a class="el" href="group___h_r_p_w_m.html#ga6b02902e05248a345d3a75226ab2eb76">XMC_HRPWM_EnableHighResolutionPath()</a> and <a class="el" href="group___h_r_p_w_m.html#gaf027dc9fd7d9c64c7316e2bc2874ebf2">XMC_HRPWM_EnableLowResolutionPath()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga6b02902e05248a345d3a75226ab2eb76">XMC_HRPWM_EnableHighResolutionPath()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gaf027dc9fd7d9c64c7316e2bc2874ebf2">XMC_HRPWM_EnableLowResolutionPath()</a><br />
 </dd></dl>

</div>
</div>
<a id="gaf027dc9fd7d9c64c7316e2bc2874ebf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf027dc9fd7d9c64c7316e2bc2874ebf2">&#9670;&nbsp;</a></span>XMC_HRPWM_EnableLowResolutionPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_EnableLowResolutionPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected HRC modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga79a24ebb2df99867180c7e676dc4815e">XMC_HRPWM_LR_PATH_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Enables the low resolution path<br />
<br />
 Enables the low resolution path determined by passed mask value, by setting HRCCFG.LRC0E bit. By default signals from source selector 0 are linked to HR path and signals from source selector 1 are linked to LR path. This connections can be reversed at runtime, if bit HRCySC.ST is set to 1.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga662c21ff0c66afdb96e049f45d6a67ea">XMC_HRPWM_HRC_Set_HR_Source()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga6b02902e05248a345d3a75226ab2eb76">XMC_HRPWM_EnableHighResolutionPath()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gad5b7cea1c88b33f35c15e928fc88d8d5">XMC_HRPWM_DisableHighResolutionPath()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga7b43ac44b227a27a44628b87b0e46f11">XMC_HRPWM_DisableLowResolutionPath()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gaabcf1cff107c2ae113407befb7b0412a">XMC_HRPWM_EnableHRPowerMode()</a><br />
 </dd></dl>

</div>
</div>
<a id="gad197514e3c3e7f409ea3b98422085be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad197514e3c3e7f409ea3b98422085be5">&#9670;&nbsp;</a></span>XMC_HRPWM_GetCMPInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_HRPWM_GetCMPInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga551133de6601253b0f9bf43fc9772f15">XMC_HRPWM_CSG_SWITCH_CMP_INPUT_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Returns the bit encoded status of HW pin connected to comparator inverting pin<br />
<br />
 Returns the bit encoded status of HW pin connected to comparator inverting pin by checking CSGTRSG.SW0ST bit. The bit position is set to 1 if CINB is connected, else its CINA.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga805831cc2749a83373f6d0b0006bac38">XMC_HRPWM_CSG_SetCMPInput()</a><br />
 </dd></dl>

</div>
</div>
<a id="gac9d54d78a8f4e342eafed7040e2f9d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9d54d78a8f4e342eafed7040e2f9d43">&#9670;&nbsp;</a></span>XMC_HRPWM_GetComparatorShadowTransferStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_HRPWM_GetComparatorShadowTransferStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Gets the shadow transfer status of DSV1 and pulse swallow registers of all the DACs<br />
<br />
 Gets the shadow transfer status of DSV1 and pulse swallow registers of all the DACs by checking the register CSGTRSG The return value is not zero if shadow transfer has been requested, but is still pending completion.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#gad476f8353f1345158a0f55b3ccb4da98">XMC_HRPWM_EnableComparatorShadowTransfer()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga3d9504e5573ab6ed0e2f1b07f67831d6">XMC_HRPWM_DisableComparatorShadowTransfer()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga80c1e83e5135d8548b33f4fba38d626b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80c1e83e5135d8548b33f4fba38d626b">&#9670;&nbsp;</a></span>XMC_HRPWM_GetHighResolutionShadowTransferStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_HRPWM_GetHighResolutionShadowTransferStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected HRC modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga1430f4a0749968e47a744fc40009384b">XMC_HRPWM_HRC_SHADOW_TX_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Returns the shadow transfer request status<br />
<br />
 Returns the shadow transfer request status, by checking HRCSTSG.H0STE, HRCSTSG.H0DSTE bits. Returns a non zero value if corresponding shadow transfer request has been performed.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga445cb2483edf80fa5b1a8c6fd74948e0">XMC_HRPWM_EnableHighResolutionShadowTransfer()</a><br />
 </dd></dl>

</div>
</div>
<a id="gab6a93e24f3e2668cb2a4e38e44f8f96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6a93e24f3e2668cb2a4e38e44f8f96e">&#9670;&nbsp;</a></span>XMC_HRPWM_GetHRGenReadyStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_r_p_w_m.html#gadfc15f0691fb89b0cfecc46a8422a39c">XMC_HRPWM_HR_LOGIC_t</a> XMC_HRPWM_GetHRGenReadyStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_HRPWM_HR_LOGIC_t</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Returns the status of the high resolution logic.<br />
<br />
 Returns status of the high resolution logic by checking HRGHRS.HRGR bit. The return value should be <a class="el" href="group___h_r_p_w_m.html#ggadfc15f0691fb89b0cfecc46a8422a39ca67dd0ee226e9b0fdcb14a30429c7b5df">XMC_HRPWM_HR_LOGIC_WORKING</a> for proper generation of high resolution signal positioning. </dd></dl>

</div>
</div>
<a id="gaa297fb77b955ee067b7665c6540876e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa297fb77b955ee067b7665c6540876e2">&#9670;&nbsp;</a></span>XMC_HRPWM_GetRunBitStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_HRPWM_GetRunBitStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga8f5cb84356dd14d33e4172435a921082">XMC_HRPWM_CSG_RUN_BIT_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Returns bit encoded status of multiple DACs and Comparators, defined by the mask.<br />
<br />
 Returns bit encoded status of multiple DACs and Comparators from register CSGSTATG, defined by the mask. The mask is generated by bitwise ORing multiple Enums.<br />
 mask = (uint32_t) (XMC_HRPWM_CSG_RUN_BIT_CMP0 | XMC_HRPWM_CSG_RUN_BIT_DAC0 | XMC_HRPWM_CSG_RUN_BIT_CMP0_PSL);</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#gab56e64bc4f4e7af2ae753c045c0a9f62">XMC_HRPWM_IsDacRunning()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gaa2e042c070a7387a6a751f5cb58d05a8">XMC_HRPWM_IsComparatorClamped()</a><br />
 </dd></dl>

</div>
</div>
<a id="gae373f3148dcac7511e56b5cc6dd98a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae373f3148dcac7511e56b5cc6dd98a09">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_ConfigSourceSelect0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_HRC_ConfigSourceSelect0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a> *const&#160;</td>
          <td class="paramname"><em>hrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___h_r_p_w_m___h_r_c___s_r_c___c_o_n_f_i_g__t.html">XMC_HRPWM_HRC_SRC_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrc</td><td>Constant pointer to XMC_HRPWM_HRC_t, pointing to the HRC channel base address </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to configuration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Initializes the source 0 of HRC channel.<br />
<br />
 Initialize the source 0 functionality of HRC channel.<br />
 This include:<br />
 1) general configuration for source 0 HRC channel.<br />
 2) Configuration of which inputs are being used to generate the set and clear for the latch and therefore controlling the generation of the output PWM signal.<br />
 3) Configuration for which timer from the Capture/Compare Unit is used for the Source Selector 0 and Source Selector 1.<br />
</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga2fd6d77ee95cee8a52216e17c86d6af4">XMC_HRPWM_HRC_ConfigSourceSelect1()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga2fd6d77ee95cee8a52216e17c86d6af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fd6d77ee95cee8a52216e17c86d6af4">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_ConfigSourceSelect1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_HRC_ConfigSourceSelect1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a> *const&#160;</td>
          <td class="paramname"><em>hrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___h_r_p_w_m___h_r_c___s_r_c___c_o_n_f_i_g__t.html">XMC_HRPWM_HRC_SRC_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrc</td><td>Constant pointer to XMC_HRPWM_HRC_t, pointing to the HRC channel base address </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to configuration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Initializes the source 1 of HRC channel.<br />
<br />
 Initialize the source 1 functionality of HRC channel.<br />
<br />
This include:<br />
 1) general configuration for source 1 HRC channel.<br />
 2) Configuration of which inputs are being used to generate the set and clear for the latch and therefore controlling the generation of the output PWM signal.<br />
 3) Configuration for which timer from the Capture/Compare Unit is used for the Source Selector 0 and Source Selector 1.<br />
</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#gae373f3148dcac7511e56b5cc6dd98a09">XMC_HRPWM_HRC_ConfigSourceSelect0()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga55a09b6807a5fd6f321eed7a8a970446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55a09b6807a5fd6f321eed7a8a970446">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_HRC_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a> *const&#160;</td>
          <td class="paramname"><em>hrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___h_r_p_w_m___h_r_c___c_o_n_f_i_g__t.html">XMC_HRPWM_HRC_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrc</td><td>Constant pointer to XMC_HRPWM_HRC_t, pointing to the HRC channel base address </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to configuration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Initializes the HRC channel.<br />
<br />
 Initializes the HRC channel functionality.<br />
 These include:<br />
 1) Dead time configuration.<br />
 3) Trap Configuration.<br />
 4) Shadow transfer configuration.<br />
 5) Output inversion configuration.<br />
 6) Passive levels of HRC outputs.<br />
 </dd></dl>

</div>
</div>
<a id="ga662c21ff0c66afdb96e049f45d6a67ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga662c21ff0c66afdb96e049f45d6a67ea">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_Set_HR_Source()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_HRC_Set_HR_Source </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a> *const&#160;</td>
          <td class="paramname"><em>hrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga723536b1c6bed71c7369defade462741">XMC_HRPWM_HRC_SOURCE_t</a>&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrc</td><td>Constant pointer to XMC_HRPWM_HRC_t, pointing to the HRC channel base address </td></tr>
    <tr><td class="paramname">source</td><td>Source connected to high resolution channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Sets the source to high resolution channel<br />
<br />
 Sets the shadow transfer register deciding the source connected to high resolution channel. This also affects the CCU8 timer used for linking shadow transfer trigger. Call the shadow transfer update API. A shadow transfer request in corresponding CCU8 slice may also be required.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga445cb2483edf80fa5b1a8c6fd74948e0">XMC_HRPWM_EnableHighResolutionShadowTransfer()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga35eaab412824cc2cc2a8521196e56d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35eaab412824cc2cc2a8521196e56d5c">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_SetCompare1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_HRC_SetCompare1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a> *const&#160;</td>
          <td class="paramname"><em>hrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>cr1_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrc</td><td>Constant pointer to XMC_HRPWM_HRC_t, pointing to the HRC channel base address </td></tr>
    <tr><td class="paramname">cr1_value</td><td>high resolution positioning value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Sets the shadow transfer register of high resolution positioning for rising edge<br />
<br />
 Call the shadow transfer update API for transfer to CR1 register. A shadow transfer request in corresponding CCU8 slice may also be required.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga445cb2483edf80fa5b1a8c6fd74948e0">XMC_HRPWM_EnableHighResolutionShadowTransfer()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga9a520049dd9aa004faaf0427435a75a3">XMC_HRPWM_HRC_SetCompare2()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga9a520049dd9aa004faaf0427435a75a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a520049dd9aa004faaf0427435a75a3">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_SetCompare2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_HRC_SetCompare2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a> *const&#160;</td>
          <td class="paramname"><em>hrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>cr2_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrc</td><td>Constant pointer to XMC_HRPWM_HRC_t, pointing to the HRC channel base address </td></tr>
    <tr><td class="paramname">cr2_value</td><td>high resolution positioning value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Sets the shadow transfer register of high resolution positioning for falling edge<br />
<br />
 Call the shadow transfer update API for transfer to CR2 register. A shadow transfer request in corresponding CCU8 slice may also be required.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga445cb2483edf80fa5b1a8c6fd74948e0">XMC_HRPWM_EnableHighResolutionShadowTransfer()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga35eaab412824cc2cc2a8521196e56d5c">XMC_HRPWM_HRC_SetCompare1()</a><br />
 </dd></dl>

</div>
</div>
<a id="gafdfed01719f6ee374bb928e39d7b60c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdfed01719f6ee374bb928e39d7b60c3">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_SetDeadTimeFalling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_HRC_SetDeadTimeFalling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a> *const&#160;</td>
          <td class="paramname"><em>hrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dcf_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrc</td><td>Constant pointer to XMC_HRPWM_HRC_t, pointing to the HRC channel base address </td></tr>
    <tr><td class="paramname">dcf_value</td><td>Falling edge dead time value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Sets the shadow transfer register of falling edge dead time.<br />
<br />
 Call the shadow transfer update API for transfer to DCR register. A shadow transfer request in corresponding CCU8 slice may also be required.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga445cb2483edf80fa5b1a8c6fd74948e0">XMC_HRPWM_EnableHighResolutionShadowTransfer()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga0d1ae69aff7172b27d30f03aaba531c1">XMC_HRPWM_HRC_SetDeadTimeRising()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga0d1ae69aff7172b27d30f03aaba531c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d1ae69aff7172b27d30f03aaba531c1">&#9670;&nbsp;</a></span>XMC_HRPWM_HRC_SetDeadTimeRising()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_HRC_SetDeadTimeRising </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga1a5ed62e672427731f694ea08a9e32b4">XMC_HRPWM_HRC_t</a> *const&#160;</td>
          <td class="paramname"><em>hrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dcr_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrc</td><td>Constant pointer to XMC_HRPWM_HRC_t, pointing to the HRC channel base address </td></tr>
    <tr><td class="paramname">dcr_value</td><td>Rising edge dead time value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Sets the shadow transfer register of rising edge dead time.<br />
<br />
 Call the shadow transfer update API for transfer to DCR register. A shadow transfer request in corresponding CCU8 slice may also be required.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga445cb2483edf80fa5b1a8c6fd74948e0">XMC_HRPWM_EnableHighResolutionShadowTransfer()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gafdfed01719f6ee374bb928e39d7b60c3">XMC_HRPWM_HRC_SetDeadTimeFalling()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga87dbc2328d96a26fa55d35d9bfe853a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87dbc2328d96a26fa55d35d9bfe853a8">&#9670;&nbsp;</a></span>XMC_HRPWM_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___h_r_p_w_m.html#gaebcd5453412b9ad26fd5ead0b712a377">XMC_HRPWM_STATUS_t</a> XMC_HRPWM_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_HRPWM_STATUS_t</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
HRPWM Init <br />
<br />
 This function initializes the HRPWM global registers. It configures the CSG trimming data. This is the first function that needs to be called in initializing HRC or CSG modules.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___s_d_m_m_c.html#ga8e8348ee9e807c66799bffe6a6092aba">XMC_SDMMC_TriggerEvent()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gaa2e042c070a7387a6a751f5cb58d05a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2e042c070a7387a6a751f5cb58d05a8">&#9670;&nbsp;</a></span>XMC_HRPWM_IsComparatorClamped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_HRPWM_IsComparatorClamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga8f5cb84356dd14d33e4172435a921082">XMC_HRPWM_CSG_RUN_BIT_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Checks if comparator is in clamped state <br />
<br />
 Checks if comparator is in clamped state by checking CSGSTATG.PSLS0 bit. Returns bit encoded status if comparator is set to clamped state via software.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#gaf3a5ac7570e49d783ed75a12cdf88f78">XMC_HRPWM_ClampComparatorOutput()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga29de546fde9846b8f575687d58003c19">XMC_HRPWM_UnClampComparatorOutput()</a><br />
 </dd></dl>

</div>
</div>
<a id="gaf3b0bc4b90b8091d58d356cf21c091bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3b0bc4b90b8091d58d356cf21c091bf">&#9670;&nbsp;</a></span>XMC_HRPWM_IsComparatorRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_HRPWM_IsComparatorRunning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga8f5cb84356dd14d33e4172435a921082">XMC_HRPWM_CSG_RUN_BIT_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Checks if comparator is enabled<br />
<br />
 Checks if comparator is enabled by checking CSGSTATG.C0RB bit. Returns true if comparator run bit is set, else returns false.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga04e267b78b1687f5718629b0677feb6f">XMC_HRPWM_StartComparator()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga61e02555559df57238c3c95f78805723">XMC_HRPWM_StopComparator()</a><br />
 </dd></dl>

</div>
</div>
<a id="gab56e64bc4f4e7af2ae753c045c0a9f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab56e64bc4f4e7af2ae753c045c0a9f62">&#9670;&nbsp;</a></span>XMC_HRPWM_IsDacRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_HRPWM_IsDacRunning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga8f5cb84356dd14d33e4172435a921082">XMC_HRPWM_CSG_RUN_BIT_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Checks if CSG DAC is operational<br />
<br />
 Checks if CSG DAC is operational by checking CSGSTATG.D0RB bit.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#gadbebb06d6614c718f7c79537910719aa">XMC_HRPWM_StartDac()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gaf85b9ae687f8831159c11b8480fc986e">XMC_HRPWM_StopDac()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga9eef87ede9768c817a6db40515146c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eef87ede9768c817a6db40515146c6c">&#9670;&nbsp;</a></span>XMC_HRPWM_IsPrescalerRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_HRPWM_IsPrescalerRunning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#gacb53cbfc6388b50d5708abf4652823e5">XMC_HRPWM_CSG_PRESCALER_STATUS_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Checks the prescaler status of DACs selected by mask<br />
<br />
 Checks the prescaler status of DACs selected by mask, by checking CSGFCG.P0RB bit. Returns the bit encoded status information of prescaler.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#gaf357ce24027e53b8b4193ee77ca59455">XMC_HRPWM_ClearPreScaler()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga5c36905fafe437df01d4b049d4989962">XMC_HRPWM_StartSlopeGeneration()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga6c9948d05a763e18e8467ddc8363c051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c9948d05a763e18e8467ddc8363c051">&#9670;&nbsp;</a></span>XMC_HRPWM_IsSlopeGenerationRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_HRPWM_IsSlopeGenerationRunning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga8f5cb84356dd14d33e4172435a921082">XMC_HRPWM_CSG_RUN_BIT_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Checks if Prescaler &amp; slope generation is running<br />
<br />
 Checks if Prescaler &amp; slope generation is running by checking CSGFSG.S0RB CSGFSG.P0RB bits. The mask is generated by bitwise ORing multiple Enums.<br />
 mask = (uint32_t) (XMC_HRPWM_CSG_SLOPE_START_DAC0 | XMC_HRPWM_CSG_PRESCALER_START_CSG0);</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga5c36905fafe437df01d4b049d4989962">XMC_HRPWM_StartSlopeGeneration()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga9cba81f02e8db279bbf0fe4a42646ba6">XMC_HRPWM_StopSlopeGeneration()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga344cdb322dc26cea959f5d0129c0ece1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga344cdb322dc26cea959f5d0129c0ece1">&#9670;&nbsp;</a></span>XMC_HRPWM_ModuleClkFreq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_ModuleClkFreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___h_r_p_w_m.html#ga5cd683d357b3e616029c499dbde6ff5d">XMC_HRPWM_CLK_FREQ_t</a>&#160;</td>
          <td class="paramname"><em>clk_freq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">clk_freq</td><td>The operating clock frequency of HRPWM module. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga5cd683d357b3e616029c499dbde6ff5d">XMC_HRPWM_CLK_FREQ_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Configures the clock frequency of operation of HRPWM module<br />
<br />
 Configures the clock frequency of operation of HRPWM module by configuring HRCCFG.CLKC bits. The clock is generally selected based on the device type selected. </dd></dl>

</div>
</div>
<a id="gabfdb7f2f27dc19c46a80f4a14bf4a4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfdb7f2f27dc19c46a80f4a14bf4a4ca">&#9670;&nbsp;</a></span>XMC_HRPWM_SetCsgPowerMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_SetCsgPowerMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___h_r_p_w_m.html#ga4f816529f1530081745540ca81fa808b">XMC_HRPWM_CSG_SLICE_t</a>&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___h_r_p_w_m.html#gaa200a6a7a4cbfb74537076c89a7aa4be">XMC_HRPWM_CSG_POWER_MODE_t</a>&#160;</td>
          <td class="paramname"><em>power_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">slice</td><td>Slice NO. </td></tr>
    <tr><td class="paramname">power_mode</td><td>The mode to be put in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Sets the DAC in OFF, Low speed or High speed mode<br />
<br />
 Sets the DAC in OFF, Low speed or High speed mode, by setting CSGCFG.C0PM bits.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd></dd></dl>

</div>
</div>
<a id="ga04e267b78b1687f5718629b0677feb6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04e267b78b1687f5718629b0677feb6f">&#9670;&nbsp;</a></span>XMC_HRPWM_StartComparator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_StartComparator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga8f5cb84356dd14d33e4172435a921082">XMC_HRPWM_CSG_RUN_BIT_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Enables the operation of comparator <br />
<br />
 Enables the operation of comparator by setting CSGSETG.SC0R bit.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga61e02555559df57238c3c95f78805723">XMC_HRPWM_StopComparator()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gaf3b0bc4b90b8091d58d356cf21c091bf">XMC_HRPWM_IsComparatorRunning()</a><br />
 </dd></dl>

</div>
</div>
<a id="gadbebb06d6614c718f7c79537910719aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbebb06d6614c718f7c79537910719aa">&#9670;&nbsp;</a></span>XMC_HRPWM_StartDac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_StartDac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga8f5cb84356dd14d33e4172435a921082">XMC_HRPWM_CSG_RUN_BIT_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Enables the operation of CSG DAC<br />
<br />
 Enables the operation of CSG DAC by setting CSGSETG.SD0R bit. The DAC operation is enabled. Either the value in DSV1 or DSV2 is sent to DAC, based on configuration.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#gaf85b9ae687f8831159c11b8480fc986e">XMC_HRPWM_StopDac()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gab56e64bc4f4e7af2ae753c045c0a9f62">XMC_HRPWM_IsDacRunning()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga5c36905fafe437df01d4b049d4989962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c36905fafe437df01d4b049d4989962">&#9670;&nbsp;</a></span>XMC_HRPWM_StartSlopeGeneration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_StartSlopeGeneration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga8f5cb84356dd14d33e4172435a921082">XMC_HRPWM_CSG_RUN_BIT_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Start the prescaler &amp; slope generation of DAC<br />
<br />
 Start the prescaler &amp; slope generation of DAC by setting CSGFCG.S0STR and CSGFCG.PS0STR bits. The mask is generated by bitwise ORing multiple Enums.<br />
 mask = (uint32_t) (XMC_HRPWM_CSG_SLOPE_START_DAC0 | XMC_HRPWM_CSG_PRESCALER_START_CSG0);</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga9cba81f02e8db279bbf0fe4a42646ba6">XMC_HRPWM_StopSlopeGeneration()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga6c9948d05a763e18e8467ddc8363c051">XMC_HRPWM_IsSlopeGenerationRunning()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga61e02555559df57238c3c95f78805723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61e02555559df57238c3c95f78805723">&#9670;&nbsp;</a></span>XMC_HRPWM_StopComparator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_StopComparator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga8f5cb84356dd14d33e4172435a921082">XMC_HRPWM_CSG_RUN_BIT_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Disables the operation of comparator<br />
<br />
 Disables the operation of comparator by setting CSGCLRG.CC0R bit.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga04e267b78b1687f5718629b0677feb6f">XMC_HRPWM_StartComparator()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gaf3b0bc4b90b8091d58d356cf21c091bf">XMC_HRPWM_IsComparatorRunning()</a><br />
 </dd></dl>

</div>
</div>
<a id="gaf85b9ae687f8831159c11b8480fc986e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf85b9ae687f8831159c11b8480fc986e">&#9670;&nbsp;</a></span>XMC_HRPWM_StopDac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_StopDac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga8f5cb84356dd14d33e4172435a921082">XMC_HRPWM_CSG_RUN_BIT_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Disables the operation of CSG DAC<br />
<br />
 Disables the operation of CSG DAC by setting CSGCLRG.CD0R bit.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#gadbebb06d6614c718f7c79537910719aa">XMC_HRPWM_StartDac()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gab56e64bc4f4e7af2ae753c045c0a9f62">XMC_HRPWM_IsDacRunning()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga9cba81f02e8db279bbf0fe4a42646ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cba81f02e8db279bbf0fe4a42646ba6">&#9670;&nbsp;</a></span>XMC_HRPWM_StopSlopeGeneration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_StopSlopeGeneration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga8f5cb84356dd14d33e4172435a921082">XMC_HRPWM_CSG_RUN_BIT_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Stops the prescaler &amp; slope generation of DAC<br />
<br />
 Stops the prescaler &amp; slope generation of DAC by setting CSGFCG.S0STP and CSGFCG.PS0STP bits. The mask is generated by bitwise ORing multiple Enums.<br />
 mask = (uint32_t) (XMC_HRPWM_CSG_SLOPE_START_DAC0 | XMC_HRPWM_CSG_PRESCALER_START_CSG0);</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#ga5c36905fafe437df01d4b049d4989962">XMC_HRPWM_StartSlopeGeneration()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#ga6c9948d05a763e18e8467ddc8363c051">XMC_HRPWM_IsSlopeGenerationRunning()</a><br />
 </dd></dl>

</div>
</div>
<a id="ga29de546fde9846b8f575687d58003c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29de546fde9846b8f575687d58003c19">&#9670;&nbsp;</a></span>XMC_HRPWM_UnClampComparatorOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_HRPWM_UnClampComparatorOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_r_p_w_m.html#ga45de914982446332346b0ed2e298a464">XMC_HRPWM_t</a> *const&#160;</td>
          <td class="paramname"><em>hrpwm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hrpwm</td><td>Constant pointer to XMC_HRPWM_t, pointing to the HRPWM module base address </td></tr>
    <tr><td class="paramname">mask</td><td>masked values of selected CSG modules. Use the enum type <a class="el" href="group___h_r_p_w_m.html#ga8f5cb84356dd14d33e4172435a921082">XMC_HRPWM_CSG_RUN_BIT_t</a> to generate the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description </dt><dd><br />
Clear the comparator output from clamp state<br />
<br />
 Un-clamps the output of comparator from clamped state set via software by setting CSGCLRG.CC0P bit. The output of comparator is now dependent on the inputs of comparator.</dd></dl>
<dl class="section user"><dt>Related APIs: </dt><dd><a class="el" href="group___h_r_p_w_m.html#gaf3a5ac7570e49d783ed75a12cdf88f78">XMC_HRPWM_ClampComparatorOutput()</a><br />
 <a class="el" href="group___h_r_p_w_m.html#gaa2e042c070a7387a6a751f5cb58d05a8">XMC_HRPWM_IsComparatorClamped()</a><br />
 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>XMC Peripheral Library for XMC4000 Family</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
