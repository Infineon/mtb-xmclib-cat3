<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XMC Peripheral Library for XMC4000 Family: Inter Integrated Circuit(IIC)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC4000 Family</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___i2_c.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Inter Integrated Circuit(IIC)</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___i2_c___c_h___c_o_n_f_i_g__t.html">XMC_I2C_CH_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga71176768512ab2836eb4dc41973c1339"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga71176768512ab2836eb4dc41973c1339">XMC_I2C0_CH0</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a></td></tr>
<tr class="separator:ga71176768512ab2836eb4dc41973c1339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbbadccd3da1cbecf1aac59dd54035dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gafbbadccd3da1cbecf1aac59dd54035dd">XMC_I2C0_CH1</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a></td></tr>
<tr class="separator:gafbbadccd3da1cbecf1aac59dd54035dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ffc942d7d7d6a1a2653c4406f265a16"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9ffc942d7d7d6a1a2653c4406f265a16">XMC_I2C1_CH0</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab3012ea0f6b1dddc5b1c05425e15c4a1">XMC_USIC1_CH0</a></td></tr>
<tr class="separator:ga9ffc942d7d7d6a1a2653c4406f265a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b7a66d60a6dc718f09b5245187b9fec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8b7a66d60a6dc718f09b5245187b9fec">XMC_I2C1_CH1</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga8892cec48c6246ff3e470178e4273f99">XMC_USIC1_CH1</a></td></tr>
<tr class="separator:ga8b7a66d60a6dc718f09b5245187b9fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd192d1e612ccd4143ec299966a11f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gadbd192d1e612ccd4143ec299966a11f0">XMC_I2C2_CH0</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab79d676f4efb3235bd3d8c977b83b1cf">XMC_USIC2_CH0</a></td></tr>
<tr class="separator:gadbd192d1e612ccd4143ec299966a11f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d470379c765ee393530da6b97372122"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga7d470379c765ee393530da6b97372122">XMC_I2C2_CH1</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a></td></tr>
<tr class="separator:ga7d470379c765ee393530da6b97372122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156f3aa37787f3b6b73c58a742e64302"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga156f3aa37787f3b6b73c58a742e64302">XMC_I2C_10BIT_ADDR_GROUP</a>&#160;&#160;&#160;(0x7800U)</td></tr>
<tr class="separator:ga156f3aa37787f3b6b73c58a742e64302"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga797641917b01a783e6e7aac5d25a298f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga797641917b01a783e6e7aac5d25a298f">XMC_I2C_CH_INTERRUPT_NODE_POINTER_t</a> </td></tr>
<tr class="separator:ga797641917b01a783e6e7aac5d25a298f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab922e97164d14898b92df3d30c10fe83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gab922e97164d14898b92df3d30c10fe83">XMC_I2C_CH_ClearStatusFlag</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, uint32_t flag)</td></tr>
<tr class="separator:gab922e97164d14898b92df3d30c10fe83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63149dd65f853cc69ed57add87f34627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga63149dd65f853cc69ed57add87f34627">XMC_I2C_CH_ConfigExternalInputSignalToBRG</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t pdiv, const uint32_t oversampling, const <a class="el" href="group___u_s_i_c.html#ga4c50ae5a7f12a5496d82d2bc665e1db2">XMC_USIC_CH_INPUT_COMBINATION_MODE_t</a> combination_mode)</td></tr>
<tr class="separator:ga63149dd65f853cc69ed57add87f34627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d7a2f143c3f07c35b39174d6e802be6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4d7a2f143c3f07c35b39174d6e802be6">XMC_I2C_CH_DisableAcknowledgeAddress0</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga4d7a2f143c3f07c35b39174d6e802be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c7d23e924935f15cbebc5808e901fb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga2c7d23e924935f15cbebc5808e901fb8">XMC_I2C_CH_DisableDataTransmission</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga2c7d23e924935f15cbebc5808e901fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d0b7e575a13d2fdd2ead33d96d9e15b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga7d0b7e575a13d2fdd2ead33d96d9e15b">XMC_I2C_CH_DisableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, uint32_t event)</td></tr>
<tr class="separator:ga7d0b7e575a13d2fdd2ead33d96d9e15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dd4cbd57cae2b9d61d1b930ad516d8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4dd4cbd57cae2b9d61d1b930ad516d8e">XMC_I2C_CH_DisableMasterClock</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga4dd4cbd57cae2b9d61d1b930ad516d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae49923f2679d64f4980518491d844bec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gae49923f2679d64f4980518491d844bec">XMC_I2C_CH_EnableAcknowledgeAddress0</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gae49923f2679d64f4980518491d844bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2bdd26fa6dce7331c7ba723c2536070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad2bdd26fa6dce7331c7ba723c2536070">XMC_I2C_CH_EnableDataTransmission</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gad2bdd26fa6dce7331c7ba723c2536070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga868f80d9e08a0518c38100dda3f77882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga868f80d9e08a0518c38100dda3f77882">XMC_I2C_CH_EnableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, uint32_t event)</td></tr>
<tr class="separator:ga868f80d9e08a0518c38100dda3f77882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac55a7d058c2ccdb357a1b43a4f3d6de7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gac55a7d058c2ccdb357a1b43a4f3d6de7">XMC_I2C_CH_EnableMasterClock</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gac55a7d058c2ccdb357a1b43a4f3d6de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50f0983dca84031814fcbcb52991ee63"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga50f0983dca84031814fcbcb52991ee63">XMC_I2C_CH_GetReceivedData</a> (const <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga50f0983dca84031814fcbcb52991ee63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1168655888146acb741b9e6aac04c4e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad1168655888146acb741b9e6aac04c4e">XMC_I2C_CH_GetReceiverStatusFlag</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gad1168655888146acb741b9e6aac04c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9131749645c421ff4b8bc80d0c93b691"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9131749645c421ff4b8bc80d0c93b691">XMC_I2C_CH_GetSlaveAddress</a> (const <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga9131749645c421ff4b8bc80d0c93b691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddc87a65cf16a2bf717f650a29506cef"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaddc87a65cf16a2bf717f650a29506cef">XMC_I2C_CH_GetStatusFlag</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gaddc87a65cf16a2bf717f650a29506cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbab6cabacc65e03592b1c5d6cece11d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gafbab6cabacc65e03592b1c5d6cece11d">XMC_I2C_CH_Init</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="struct_x_m_c___i2_c___c_h___c_o_n_f_i_g__t.html">XMC_I2C_CH_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:gafbab6cabacc65e03592b1c5d6cece11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4863d117a62932fe1f784e45797c62e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf4863d117a62932fe1f784e45797c62e">XMC_I2C_CH_InitEx</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="struct_x_m_c___i2_c___c_h___c_o_n_f_i_g__t.html">XMC_I2C_CH_CONFIG_t</a> *const config, bool init_brg)</td></tr>
<tr class="separator:gaf4863d117a62932fe1f784e45797c62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5e1a8e56b356c2fc246c8b3b95bfb74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad5e1a8e56b356c2fc246c8b3b95bfb74">XMC_I2C_CH_MasterReceiveAck</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gad5e1a8e56b356c2fc246c8b3b95bfb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5960060afec908c91cd8e4a78e5eae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gae5960060afec908c91cd8e4a78e5eae9">XMC_I2C_CH_MasterReceiveNack</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gae5960060afec908c91cd8e4a78e5eae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770a5f71ceb3b447f21a8b129df6486e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga770a5f71ceb3b447f21a8b129df6486e">XMC_I2C_CH_MasterRepeatedStart</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t addr, const <a class="el" href="group___i2_c.html#gaf81b9bb81ece318669b08149f1fd7f4b">XMC_I2C_CH_CMD_t</a> command)</td></tr>
<tr class="separator:ga770a5f71ceb3b447f21a8b129df6486e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd425a409b805d4571e75f793317070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaebd425a409b805d4571e75f793317070">XMC_I2C_CH_MasterStart</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t addr, const <a class="el" href="group___i2_c.html#gaf81b9bb81ece318669b08149f1fd7f4b">XMC_I2C_CH_CMD_t</a> command)</td></tr>
<tr class="separator:gaebd425a409b805d4571e75f793317070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a48dbbe2be7fce74bd328bae5db5141"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6a48dbbe2be7fce74bd328bae5db5141">XMC_I2C_CH_MasterStop</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga6a48dbbe2be7fce74bd328bae5db5141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga701835880c9d134de09af56c12ee3383"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t data)</td></tr>
<tr class="separator:ga701835880c9d134de09af56c12ee3383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0caf9dbe9035171cc4826ad279a857a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga0caf9dbe9035171cc4826ad279a857a3">XMC_I2C_CH_SelectInterruptNodePointer</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_c.html#ga797641917b01a783e6e7aac5d25a298f">XMC_I2C_CH_INTERRUPT_NODE_POINTER_t</a> interrupt_node, const uint32_t service_request)</td></tr>
<tr class="separator:ga0caf9dbe9035171cc4826ad279a857a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0da1b672c78d08d3ffdb83316d1443cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c.html#gacba9683fdb659e012642e66bc96a406d">XMC_I2C_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga0da1b672c78d08d3ffdb83316d1443cb">XMC_I2C_CH_SetBaudrate</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t rate)</td></tr>
<tr class="separator:ga0da1b672c78d08d3ffdb83316d1443cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d2b199b5c216800a315baca1f5b7bcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c.html#gacba9683fdb659e012642e66bc96a406d">XMC_I2C_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6d2b199b5c216800a315baca1f5b7bcb">XMC_I2C_CH_SetBaudrateEx</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, uint32_t rate, bool normal_divider_mode)</td></tr>
<tr class="separator:ga6d2b199b5c216800a315baca1f5b7bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga206a30449f5196a40611f3bbe5bf39ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga206a30449f5196a40611f3bbe5bf39ba">XMC_I2C_CH_SetHoldDelay</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, uint32_t hdel)</td></tr>
<tr class="separator:ga206a30449f5196a40611f3bbe5bf39ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga358214504f42dac696c4519efa19307b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga358214504f42dac696c4519efa19307b">XMC_I2C_CH_SetInputSource</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___i2_c.html#ga76b49d68cc6d179beaf1dfe2998230bd">XMC_I2C_CH_INPUT_t</a> input, const uint8_t source)</td></tr>
<tr class="separator:ga358214504f42dac696c4519efa19307b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada2c698290a70ed692f067756ececd4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gada2c698290a70ed692f067756ececd4d">XMC_I2C_CH_SetInterruptNodePointer</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t service_request)</td></tr>
<tr class="separator:gada2c698290a70ed692f067756ececd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec9df234c44378c3fc10f0423d71aec9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaec9df234c44378c3fc10f0423d71aec9">XMC_I2C_CH_SetSlaveAddress</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t address)</td></tr>
<tr class="separator:gaec9df234c44378c3fc10f0423d71aec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd7192c5a6b3fa481f293fb0a574665"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gafdd7192c5a6b3fa481f293fb0a574665">XMC_I2C_CH_SlaveTransmit</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t data)</td></tr>
<tr class="separator:gafdd7192c5a6b3fa481f293fb0a574665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3de1b923c1a3c0a2b1ea9a8d9ff1d91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad3de1b923c1a3c0a2b1ea9a8d9ff1d91">XMC_I2C_CH_Start</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gad3de1b923c1a3c0a2b1ea9a8d9ff1d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eeda18d28c90e527c309726ff5d3cb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c.html#gacba9683fdb659e012642e66bc96a406d">XMC_I2C_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4eeda18d28c90e527c309726ff5d3cb9">XMC_I2C_CH_Stop</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga4eeda18d28c90e527c309726ff5d3cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d5d08ec30a105175f9a789ab38c1c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga72d5d08ec30a105175f9a789ab38c1c7">XMC_I2C_CH_TriggerServiceRequest</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t service_request_line)</td></tr>
<tr class="separator:ga72d5d08ec30a105175f9a789ab38c1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>USIC IIC Features: <br />
</p><ul>
<li>Two-wire interface, with one line for shift clock transfer and synchronization (shift clock SCL), the other one for the data transfer (shift data SDA) <br />
</li>
<li>Communication in standard mode (100 kBit/s) or in fast mode (up to 400 kBit/s) <br />
</li>
<li>Support of 7-bit addressing, as well as 10-bit addressing <br />
</li>
<li>Master mode operation, where the IIC controls the bus transactions and provides the clock signal. <br />
</li>
<li>Slave mode operation, where an external master controls the bus transactions and provides the clock signal.<br />
</li>
<li>Multi-master mode operation, where several masters can be connected to the bus and bus arbitration can take place, i.e. the IIC module can be master or slave. <br />
 The master/slave operation of an IIC bus participant can change from frame to frame. <br />
</li>
<li>Efficient frame handling (low software effort), also allowing DMA transfers <br />
</li>
<li>Powerful interrupt handling due to multitude of indication flags <br />
 </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga71176768512ab2836eb4dc41973c1339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71176768512ab2836eb4dc41973c1339">&#9670;&nbsp;</a></span>XMC_I2C0_CH0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2C0_CH0&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC0 channel 0 base address </p>

</div>
</div>
<a id="gafbbadccd3da1cbecf1aac59dd54035dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbbadccd3da1cbecf1aac59dd54035dd">&#9670;&nbsp;</a></span>XMC_I2C0_CH1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2C0_CH1&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC0 channel 1 base address </p>

</div>
</div>
<a id="ga9ffc942d7d7d6a1a2653c4406f265a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ffc942d7d7d6a1a2653c4406f265a16">&#9670;&nbsp;</a></span>XMC_I2C1_CH0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2C1_CH0&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab3012ea0f6b1dddc5b1c05425e15c4a1">XMC_USIC1_CH0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC1 channel 0 base address </p>

</div>
</div>
<a id="ga8b7a66d60a6dc718f09b5245187b9fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b7a66d60a6dc718f09b5245187b9fec">&#9670;&nbsp;</a></span>XMC_I2C1_CH1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2C1_CH1&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga8892cec48c6246ff3e470178e4273f99">XMC_USIC1_CH1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC1 channel 1 base address </p>

</div>
</div>
<a id="gadbd192d1e612ccd4143ec299966a11f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbd192d1e612ccd4143ec299966a11f0">&#9670;&nbsp;</a></span>XMC_I2C2_CH0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2C2_CH0&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab79d676f4efb3235bd3d8c977b83b1cf">XMC_USIC2_CH0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC2 channel 0 base address </p>

</div>
</div>
<a id="ga7d470379c765ee393530da6b97372122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d470379c765ee393530da6b97372122">&#9670;&nbsp;</a></span>XMC_I2C2_CH1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2C2_CH1&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC2 channel 1 base address </p>

</div>
</div>
<a id="ga156f3aa37787f3b6b73c58a742e64302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga156f3aa37787f3b6b73c58a742e64302">&#9670;&nbsp;</a></span>XMC_I2C_10BIT_ADDR_GROUP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_I2C_10BIT_ADDR_GROUP&#160;&#160;&#160;(0x7800U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Value to verify the address is 10-bit or not </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaf81b9bb81ece318669b08149f1fd7f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf81b9bb81ece318669b08149f1fd7f4b">&#9670;&nbsp;</a></span>XMC_I2C_CH_CMD_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gaf81b9bb81ece318669b08149f1fd7f4b">XMC_I2C_CH_CMD_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C commands. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf81b9bb81ece318669b08149f1fd7f4baf3c121d840b85087f675d717adf27dc5"></a>XMC_I2C_CH_CMD_WRITE&#160;</td><td class="fielddoc"><p>I2C Command Write </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf81b9bb81ece318669b08149f1fd7f4ba31d1b9749ef1daa181a908bbf2f28087"></a>XMC_I2C_CH_CMD_READ&#160;</td><td class="fielddoc"><p>I2C Command Read </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4142054abf4133012810875bc5ac4f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4142054abf4133012810875bc5ac4f48">&#9670;&nbsp;</a></span>XMC_I2C_CH_EVENT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga4142054abf4133012810875bc5ac4f48">XMC_I2C_CH_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C events. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4142054abf4133012810875bc5ac4f48a07ea52a7379c4bf4825453b3d210b0be"></a>XMC_I2C_CH_EVENT_RECEIVE_START&#160;</td><td class="fielddoc"><p>Receive start event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4142054abf4133012810875bc5ac4f48a3f9ea9390840a184c4b611aa5fe1ce6d"></a>XMC_I2C_CH_EVENT_DATA_LOST&#160;</td><td class="fielddoc"><p>Data lost event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4142054abf4133012810875bc5ac4f48afd7666e256e93f0e533f879a83284f54"></a>XMC_I2C_CH_EVENT_TRANSMIT_SHIFT&#160;</td><td class="fielddoc"><p>Transmit shift event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4142054abf4133012810875bc5ac4f48a5e8ecaf6874fb8996dc7a527e183c8d8"></a>XMC_I2C_CH_EVENT_TRANSMIT_BUFFER&#160;</td><td class="fielddoc"><p>Transmit buffer event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4142054abf4133012810875bc5ac4f48aa3535a887f7de062e4e3d0eaa95e421c"></a>XMC_I2C_CH_EVENT_STANDARD_RECEIVE&#160;</td><td class="fielddoc"><p>Receive event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4142054abf4133012810875bc5ac4f48a2d0b99a3d3e49439e6a6d58776b028d1"></a>XMC_I2C_CH_EVENT_ALTERNATIVE_RECEIVE&#160;</td><td class="fielddoc"><p>Alternate receive event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4142054abf4133012810875bc5ac4f48ab99891a610ff5ad0a7fdfb8037981da8"></a>XMC_I2C_CH_EVENT_BAUD_RATE_GENERATOR&#160;</td><td class="fielddoc"><p>Baudrate generator event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4142054abf4133012810875bc5ac4f48ad4539a3f5b3d43af665dcb2a5816ed82"></a>XMC_I2C_CH_EVENT_START_CONDITION_RECEIVED&#160;</td><td class="fielddoc"><p>Start condition received event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4142054abf4133012810875bc5ac4f48acf9e7500f6357d8821e4ef18c935e751"></a>XMC_I2C_CH_EVENT_REPEATED_START_CONDITION_RECEIVED&#160;</td><td class="fielddoc"><p>Repeated start condition received event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4142054abf4133012810875bc5ac4f48a8b8ef502b35abb43ea12a87e497a28d3"></a>XMC_I2C_CH_EVENT_STOP_CONDITION_RECEIVED&#160;</td><td class="fielddoc"><p>Stop condition received event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4142054abf4133012810875bc5ac4f48a8cffe5232278c8f126ebfbc8487a1c26"></a>XMC_I2C_CH_EVENT_NACK&#160;</td><td class="fielddoc"><p>NACK received event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4142054abf4133012810875bc5ac4f48a0ef9afd8b09cb8e99bcc7d342c0a38ee"></a>XMC_I2C_CH_EVENT_ARBITRATION_LOST&#160;</td><td class="fielddoc"><p>Arbitration lost event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4142054abf4133012810875bc5ac4f48a5b951bd38436773cb0e772c1db7dc997"></a>XMC_I2C_CH_EVENT_SLAVE_READ_REQUEST&#160;</td><td class="fielddoc"><p>Slave read request event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4142054abf4133012810875bc5ac4f48a43faef54c5b0282fd188a4d374a18bdc"></a>XMC_I2C_CH_EVENT_ERROR&#160;</td><td class="fielddoc"><p>Error condition event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4142054abf4133012810875bc5ac4f48abcff76a9225d94f13a62d8fd613abe62"></a>XMC_I2C_CH_EVENT_ACK&#160;</td><td class="fielddoc"><p>ACK received event </p>
</td></tr>
</table>

</div>
</div>
<a id="ga76b49d68cc6d179beaf1dfe2998230bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76b49d68cc6d179beaf1dfe2998230bd">&#9670;&nbsp;</a></span>XMC_I2C_CH_INPUT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga76b49d68cc6d179beaf1dfe2998230bd">XMC_I2C_CH_INPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C input stage selection. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga76b49d68cc6d179beaf1dfe2998230bdaba2847f3ec9aeb06277abdea4a9a51bc"></a>XMC_I2C_CH_INPUT_SDA&#160;</td><td class="fielddoc"><p>selection of sda input stage </p>
</td></tr>
<tr><td class="fieldname"><a id="gga76b49d68cc6d179beaf1dfe2998230bdaabd01419bb4afb47c665b94b4441dca9"></a>XMC_I2C_CH_INPUT_SCL&#160;</td><td class="fielddoc"><p>selection of scl input stage </p>
</td></tr>
</table>

</div>
</div>
<a id="ga797641917b01a783e6e7aac5d25a298f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga797641917b01a783e6e7aac5d25a298f">&#9670;&nbsp;</a></span>XMC_I2C_CH_INTERRUPT_NODE_POINTER_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga797641917b01a783e6e7aac5d25a298f">XMC_I2C_CH_INTERRUPT_NODE_POINTER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C channel interrupt node pointers </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga797641917b01a783e6e7aac5d25a298fafd73773ef7c86cc9030d4766b6dad775"></a>XMC_I2C_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT&#160;</td><td class="fielddoc"><p>Node pointer for transmit shift interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="gga797641917b01a783e6e7aac5d25a298fa30e7d3a2e8ad4bb38a00f428454b517c"></a>XMC_I2C_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER&#160;</td><td class="fielddoc"><p>Node pointer for transmit buffer interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="gga797641917b01a783e6e7aac5d25a298fa7d9ed5feb1378602a157a765470f55bb"></a>XMC_I2C_CH_INTERRUPT_NODE_POINTER_RECEIVE&#160;</td><td class="fielddoc"><p>Node pointer for receive interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="gga797641917b01a783e6e7aac5d25a298fab01fc29cb67b7bf5c6cd96d4ab25aa61"></a>XMC_I2C_CH_INTERRUPT_NODE_POINTER_ALTERNATE_RECEIVE&#160;</td><td class="fielddoc"><p>Node pointer for alternate receive interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="gga797641917b01a783e6e7aac5d25a298fa21d86beba6a0b2719c4a280f6e0c483b"></a>XMC_I2C_CH_INTERRUPT_NODE_POINTER_PROTOCOL&#160;</td><td class="fielddoc"><p>Node pointer for protocol related interrupts </p>
</td></tr>
</table>

</div>
</div>
<a id="ga0f5cc56c100494c399620dc165e74ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f5cc56c100494c399620dc165e74ee9">&#9670;&nbsp;</a></span>XMC_I2C_CH_RECEIVER_STATUS_FLAG_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga0f5cc56c100494c399620dc165e74ee9">XMC_I2C_CH_RECEIVER_STATUS_FLAG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C receiver status. The received data byte is available at the bit positions RBUF[7:0], whereas the additional information is monitored at the bit positions RBUF[12:8]. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0f5cc56c100494c399620dc165e74ee9ae99b1cd7f47070702c4c8608eee3ea5b"></a>XMC_I2C_CH_RECEIVER_STATUS_FLAG_ACK&#160;</td><td class="fielddoc"><p>Bit 8: Value of Received Acknowledgement bit </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0f5cc56c100494c399620dc165e74ee9a94b6f93bb9548e17750f7ca5c1ead596"></a>XMC_I2C_CH_RECEIVER_STATUS_FLAG_FIN&#160;</td><td class="fielddoc"><p>Bit 9: A 1 at this bit position indicates that after a (repeated) start condition followed by the address reception the first data byte of a new frame has been received. A 0 at this bit position indicates further data bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0f5cc56c100494c399620dc165e74ee9a4f00ab2699087f6404bb326a8a40432f"></a>XMC_I2C_CH_RECEIVER_STATUS_FLAG_MODE&#160;</td><td class="fielddoc"><p>Bit 10: A 0 at this bit position indicates that the data byte has been received when the device has been in slave mode, whereas a 1 indicates a reception in master mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0f5cc56c100494c399620dc165e74ee9a1561cdb73356e1167878f2c171a59c03"></a>XMC_I2C_CH_RECEIVER_STATUS_FLAG_ERR&#160;</td><td class="fielddoc"><p>Bit 11: A 1 at this bit position indicates an incomplete/erroneous data byte in the receive buffer </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0f5cc56c100494c399620dc165e74ee9acdd6f7f3796679921b546e194b25329e"></a>XMC_I2C_CH_RECEIVER_STATUS_FLAG_ADR&#160;</td><td class="fielddoc"><p>Bit 12: A 0 at this bit position indicates that the programmed address has been received. A 1 indicates a general call address. </p>
</td></tr>
</table>

</div>
</div>
<a id="gae922e0696a07a1809a0d8e80248ce497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae922e0696a07a1809a0d8e80248ce497">&#9670;&nbsp;</a></span>XMC_I2C_CH_STATUS_FLAG_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gae922e0696a07a1809a0d8e80248ce497">XMC_I2C_CH_STATUS_FLAG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497a9064574003e7488ab0abb7ff5ab24afb"></a>XMC_I2C_CH_STATUS_FLAG_SLAVE_SELECT&#160;</td><td class="fielddoc"><p>Slave select status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497a755a5fd93caa9ce9256fb9b1af28f83b"></a>XMC_I2C_CH_STATUS_FLAG_WRONG_TDF_CODE_FOUND&#160;</td><td class="fielddoc"><p>Wrong TDF status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497a70622c04d56ea2eb020f6d284a6ab3cb"></a>XMC_I2C_CH_STATUS_FLAG_START_CONDITION_RECEIVED&#160;</td><td class="fielddoc"><p>Start condition received status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497a756fc8a9aeeb892d313cb974a3d0177b"></a>XMC_I2C_CH_STATUS_FLAG_REPEATED_START_CONDITION_RECEIVED&#160;</td><td class="fielddoc"><p>Repeated start condition received status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497a4664181ff09534b6db48dea42858e898"></a>XMC_I2C_CH_STATUS_FLAG_STOP_CONDITION_RECEIVED&#160;</td><td class="fielddoc"><p>Stop condition received status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497ab44e1045125702fdfd9dcf9285ef17cb"></a>XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED&#160;</td><td class="fielddoc"><p>NACK received status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497a9423024bda96a10cd3c46715cd9ca9df"></a>XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST&#160;</td><td class="fielddoc"><p>Arbitration lost status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497a7b0ee1867bcc1f8341b092ae4eb67511"></a>XMC_I2C_CH_STATUS_FLAG_SLAVE_READ_REQUESTED&#160;</td><td class="fielddoc"><p>Slave read requested status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497a2da70d78de866416d369528e6219429f"></a>XMC_I2C_CH_STATUS_FLAG_ERROR&#160;</td><td class="fielddoc"><p>Error status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497ab08a526647c7f9bd1bcad252e6a195c3"></a>XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED&#160;</td><td class="fielddoc"><p>ACK received status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497a942fb1f070d531f75611d7ea2780b895"></a>XMC_I2C_CH_STATUS_FLAG_RECEIVER_START_INDICATION&#160;</td><td class="fielddoc"><p>Receive start indication status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497ae799d0f1665c26de8a6e698c68e5b2cb"></a>XMC_I2C_CH_STATUS_FLAG_DATA_LOST_INDICATION&#160;</td><td class="fielddoc"><p>Data lost indication status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497a277ffd76549e58155dbe9bb950a2827c"></a>XMC_I2C_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION&#160;</td><td class="fielddoc"><p>Transmit shift indication status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497a852f66a227d76d83ce213ff503666566"></a>XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION&#160;</td><td class="fielddoc"><p>Transmit buffer indication status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497a66815c4a86a9c2db3486177c992a559d"></a>XMC_I2C_CH_STATUS_FLAG_RECEIVE_INDICATION&#160;</td><td class="fielddoc"><p>Receive indication status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497a47e992f985807bd7e44c6a1692221454"></a>XMC_I2C_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION&#160;</td><td class="fielddoc"><p>Alternate receive indication status </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae922e0696a07a1809a0d8e80248ce497a592e3d84375f9921674e4e5a46a2544d"></a>XMC_I2C_CH_STATUS_FLAG_BAUD_RATE_GENERATOR_INDICATION&#160;</td><td class="fielddoc"><p>Baud rate generator indication status </p>
</td></tr>
</table>

</div>
</div>
<a id="gacba9683fdb659e012642e66bc96a406d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacba9683fdb659e012642e66bc96a406d">&#9670;&nbsp;</a></span>XMC_I2C_CH_STATUS_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gacba9683fdb659e012642e66bc96a406d">XMC_I2C_CH_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C Status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacba9683fdb659e012642e66bc96a406dad4a9d28840691950dde4b05dad36f276"></a>XMC_I2C_CH_STATUS_OK&#160;</td><td class="fielddoc"><p>Status OK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacba9683fdb659e012642e66bc96a406da60c441b462f4212da785420bb921734d"></a>XMC_I2C_CH_STATUS_ERROR&#160;</td><td class="fielddoc"><p>Status ERROR </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacba9683fdb659e012642e66bc96a406da27fb280a26d46055901bc598c7e02f2f"></a>XMC_I2C_CH_STATUS_BUSY&#160;</td><td class="fielddoc"><p>Status BUSY </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab922e97164d14898b92df3d30c10fe83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab922e97164d14898b92df3d30c10fe83">&#9670;&nbsp;</a></span>XMC_I2C_CH_ClearStatusFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_ClearStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">flag</td><td>Status flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Clears the status flag of I2C <em>channel</em> by setting the input parameter <em>flag</em> in PSCR register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#gaddc87a65cf16a2bf717f650a29506cef">XMC_I2C_CH_GetStatusFlag()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="ga63149dd65f853cc69ed57add87f34627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63149dd65f853cc69ed57add87f34627">&#9670;&nbsp;</a></span>XMC_I2C_CH_ConfigExternalInputSignalToBRG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_ConfigExternalInputSignalToBRG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>pdiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>oversampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_s_i_c.html#ga4c50ae5a7f12a5496d82d2bc665e1db2">XMC_USIC_CH_INPUT_COMBINATION_MODE_t</a>&#160;</td>
          <td class="paramname"><em>combination_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_c.html#ga71176768512ab2836eb4dc41973c1339">XMC_I2C0_CH0</a>, <a class="el" href="group___i2_c.html#gafbbadccd3da1cbecf1aac59dd54035dd">XMC_I2C0_CH1</a>,<a class="el" href="group___i2_c.html#ga9ffc942d7d7d6a1a2653c4406f265a16">XMC_I2C1_CH0</a>,<a class="el" href="group___i2_c.html#ga8b7a66d60a6dc718f09b5245187b9fec">XMC_I2C1_CH1</a>,<a class="el" href="group___i2_c.html#gadbd192d1e612ccd4143ec299966a11f0">XMC_I2C2_CH0</a>,<a class="el" href="group___i2_c.html#ga7d470379c765ee393530da6b97372122">XMC_I2C2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of I2C1 and I2C2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdiv</td><td>Desired divider for the external frequency input. <b>Range:</b> minimum value = 1, maximum value = 1024 <br />
</td></tr>
    <tr><td class="paramname">oversampling</td><td>Required oversampling. The value indicates the number of time quanta for one symbol of data. <br />
 This can be related to the number of samples for each logic state of the data signal. <br />
 <b>Range:</b> 1 to 32. Value should be chosen based on the protocol used. </td></tr>
    <tr><td class="paramname">combination_mode</td><td>USIC channel input combination mode <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the external frequency input for the Baudrate Generator and configures the divider, oversampling and the combination mode of the USIC channel. <br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga2876a325930da4b77ef46ec4e0acda0d">XMC_USIC_CH_SetBRGInputClockSource()</a>, <a class="el" href="group___u_s_i_c.html#gaeef58e03c1253fce5b8a456f5d8c6da6">XMC_USIC_CH_SetInputTriggerCombinationMode()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga4d7a2f143c3f07c35b39174d6e802be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d7a2f143c3f07c35b39174d6e802be6">&#9670;&nbsp;</a></span>XMC_I2C_CH_DisableAcknowledgeAddress0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_DisableAcknowledgeAddress0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>This bit defines that slave device should not be sensitive to the slave address 00H.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#gae49923f2679d64f4980518491d844bec">XMC_I2C_CH_EnableAcknowledgeAddress0()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="ga2c7d23e924935f15cbebc5808e901fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c7d23e924935f15cbebc5808e901fb8">&#9670;&nbsp;</a></span>XMC_I2C_CH_DisableDataTransmission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_DisableDataTransmission </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_c.html#ga71176768512ab2836eb4dc41973c1339">XMC_I2C0_CH0</a>, <a class="el" href="group___i2_c.html#gafbbadccd3da1cbecf1aac59dd54035dd">XMC_I2C0_CH1</a>,<a class="el" href="group___i2_c.html#ga9ffc942d7d7d6a1a2653c4406f265a16">XMC_I2C1_CH0</a>,<a class="el" href="group___i2_c.html#ga8b7a66d60a6dc718f09b5245187b9fec">XMC_I2C1_CH1</a>,<a class="el" href="group___i2_c.html#gadbd192d1e612ccd4143ec299966a11f0">XMC_I2C2_CH0</a>,<a class="el" href="group___i2_c.html#ga7d470379c765ee393530da6b97372122">XMC_I2C2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of I2C1 and I2C2 depends on device selection </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disable data transmission.<br />
<br />
Use this function in combination with <a class="el" href="group___i2_c.html#gad2bdd26fa6dce7331c7ba723c2536070">XMC_I2C_CH_EnableDataTransmission()</a> to fill the FIFO and send the FIFO content without gaps in the transmission. FIFO is filled using <a class="el" href="group___u_s_i_c.html#gae96e9afeaefe2585b687e36f6227727f">XMC_USIC_CH_TXFIFO_PutData()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#gad2bdd26fa6dce7331c7ba723c2536070">XMC_I2C_CH_EnableDataTransmission()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga7d0b7e575a13d2fdd2ead33d96d9e15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d0b7e575a13d2fdd2ead33d96d9e15b">&#9670;&nbsp;</a></span>XMC_I2C_CH_DisableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_DisableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">event</td><td>ORed values of <a class="el" href="group___i2_c.html#ga4142054abf4133012810875bc5ac4f48">XMC_I2C_CH_EVENT_t</a> enum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the input parameter <a class="el" href="group___i2_c.html#ga4142054abf4133012810875bc5ac4f48">XMC_I2C_CH_EVENT_t</a> event using PCR_IICMode register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga868f80d9e08a0518c38100dda3f77882">XMC_I2C_CH_EnableEvent()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="ga4dd4cbd57cae2b9d61d1b930ad516d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dd4cbd57cae2b9d61d1b930ad516d8e">&#9670;&nbsp;</a></span>XMC_I2C_CH_DisableMasterClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_DisableMasterClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the generation of Master clock by clearing PCR.MCLK bit.<br />
<br />
This clock can be enabled by invoking <a class="el" href="group___i2_c.html#gac55a7d058c2ccdb357a1b43a4f3d6de7">XMC_I2C_CH_EnableMasterClock()</a> as needed in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#gac55a7d058c2ccdb357a1b43a4f3d6de7">XMC_I2C_CH_EnableMasterClock()</a> </dd></dl>

</div>
</div>
<a id="gae49923f2679d64f4980518491d844bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae49923f2679d64f4980518491d844bec">&#9670;&nbsp;</a></span>XMC_I2C_CH_EnableAcknowledgeAddress0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_EnableAcknowledgeAddress0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Retrieves the status byte of I2C <em>channel</em> using PSR_IICMode register.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga4d7a2f143c3f07c35b39174d6e802be6">XMC_I2C_CH_DisableAcknowledgeAddress0()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="gad2bdd26fa6dce7331c7ba723c2536070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2bdd26fa6dce7331c7ba723c2536070">&#9670;&nbsp;</a></span>XMC_I2C_CH_EnableDataTransmission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_EnableDataTransmission </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_c.html#ga71176768512ab2836eb4dc41973c1339">XMC_I2C0_CH0</a>, <a class="el" href="group___i2_c.html#gafbbadccd3da1cbecf1aac59dd54035dd">XMC_I2C0_CH1</a>,<a class="el" href="group___i2_c.html#ga9ffc942d7d7d6a1a2653c4406f265a16">XMC_I2C1_CH0</a>,<a class="el" href="group___i2_c.html#ga8b7a66d60a6dc718f09b5245187b9fec">XMC_I2C1_CH1</a>,<a class="el" href="group___i2_c.html#gadbd192d1e612ccd4143ec299966a11f0">XMC_I2C2_CH0</a>,<a class="el" href="group___i2_c.html#ga7d470379c765ee393530da6b97372122">XMC_I2C2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of I2C1 and I2C2 depends on device selection </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enable data transmission.<br />
<br />
Use this function in combination with <a class="el" href="group___i2_c.html#ga2c7d23e924935f15cbebc5808e901fb8">XMC_I2C_CH_DisableDataTransmission()</a> to fill the FIFO and send the FIFO content without gaps in the transmission. FIFO is filled using <a class="el" href="group___u_s_i_c.html#gae96e9afeaefe2585b687e36f6227727f">XMC_USIC_CH_TXFIFO_PutData()</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you need more control over the start of transmission use <a class="el" href="group___u_s_i_c.html#ga3b02352ba5e94e8f79751dea304084e0">XMC_USIC_CH_SetStartTransmisionMode()</a></dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga2c7d23e924935f15cbebc5808e901fb8">XMC_I2C_CH_DisableDataTransmission()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga868f80d9e08a0518c38100dda3f77882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga868f80d9e08a0518c38100dda3f77882">&#9670;&nbsp;</a></span>XMC_I2C_CH_EnableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_EnableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">event</td><td>ORed values of <a class="el" href="group___i2_c.html#ga4142054abf4133012810875bc5ac4f48">XMC_I2C_CH_EVENT_t</a> enum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the input parameter <a class="el" href="group___i2_c.html#ga4142054abf4133012810875bc5ac4f48">XMC_I2C_CH_EVENT_t</a> event using PCR_IICMode register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga7d0b7e575a13d2fdd2ead33d96d9e15b">XMC_I2C_CH_DisableEvent()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="gac55a7d058c2ccdb357a1b43a4f3d6de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac55a7d058c2ccdb357a1b43a4f3d6de7">&#9670;&nbsp;</a></span>XMC_I2C_CH_EnableMasterClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_EnableMasterClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the generation of Master clock by setting PCR.MCLK bit.<br />
<br />
This clock can be used as a clock reference for external devices. This is not enabled during initialization in <a class="el" href="group___i2_c.html#gafbab6cabacc65e03592b1c5d6cece11d">XMC_I2C_CH_Init()</a>. Invoke <a class="el" href="group___i2_c.html#gac55a7d058c2ccdb357a1b43a4f3d6de7">XMC_I2C_CH_EnableMasterClock()</a> to enable as needed in the program, or if it is disabled by <a class="el" href="group___i2_c.html#ga4dd4cbd57cae2b9d61d1b930ad516d8e">XMC_I2C_CH_DisableMasterClock()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga4dd4cbd57cae2b9d61d1b930ad516d8e">XMC_I2C_CH_DisableMasterClock()</a> </dd></dl>

</div>
</div>
<a id="ga50f0983dca84031814fcbcb52991ee63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50f0983dca84031814fcbcb52991ee63">&#9670;&nbsp;</a></span>XMC_I2C_CH_GetReceivedData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t XMC_I2C_CH_GetReceivedData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t OUTR/RBUF register data<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Reads the data from I2C <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Data is read by using OUTR/RBUF register based on FIFO/non-FIFO modes.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="gad1168655888146acb741b9e6aac04c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1168655888146acb741b9e6aac04c4e">&#9670;&nbsp;</a></span>XMC_I2C_CH_GetReceiverStatusFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t XMC_I2C_CH_GetReceiverStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t Receiver status flag<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Gets the receiver status of I2C <em>channel</em> using RBUF register of bits 8-12 which gives information about receiver status.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="ga9131749645c421ff4b8bc80d0c93b691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9131749645c421ff4b8bc80d0c93b691">&#9670;&nbsp;</a></span>XMC_I2C_CH_GetSlaveAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XMC_I2C_CH_GetSlaveAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t Slave address<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Gets the I2C <em>channel</em> slave address.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Returns the address using PCR_IICMode register by checking if it is in 10-bit address group or 7-bit address group.<br />
 (If first five bits of address are assigned with 0xF0, then address mode is considered as 10-bit mode otherwise it is 7-bit mode)<br />
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A 7-bit address will include an additional bit at the LSB. For example, address 0x05 will be returned as 0x0a. 10-bit address will not include the 10-bit address identifier 0b11110xx at the most signifcant bits.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#gaec9df234c44378c3fc10f0423d71aec9">XMC_I2C_CH_SetSlaveAddress()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="gaddc87a65cf16a2bf717f650a29506cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddc87a65cf16a2bf717f650a29506cef">&#9670;&nbsp;</a></span>XMC_I2C_CH_GetStatusFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_I2C_CH_GetStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t Status byte<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Retrieves the status byte of I2C <em>channel</em> using PSR_IICMode register.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#gab922e97164d14898b92df3d30c10fe83">XMC_I2C_CH_ClearStatusFlag()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="gafbab6cabacc65e03592b1c5d6cece11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbab6cabacc65e03592b1c5d6cece11d">&#9670;&nbsp;</a></span>XMC_I2C_CH_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___i2_c___c_h___c_o_n_f_i_g__t.html">XMC_I2C_CH_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">config</td><td>Constant pointer to I2C channel config structure of type <a class="el" href="struct_x_m_c___i2_c___c_h___c_o_n_f_i_g__t.html">XMC_I2C_CH_CONFIG_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initializes the I2C <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Configures the data format in SCTR register. Sets the slave address, baud rate. Enables transmit data valid, clears status flags and disables parity generation.<br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga0567321036170adb335fef9b36dc3b71">XMC_USIC_CH_Enable()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="gaf4863d117a62932fe1f784e45797c62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4863d117a62932fe1f784e45797c62e">&#9670;&nbsp;</a></span>XMC_I2C_CH_InitEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_InitEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___i2_c___c_h___c_o_n_f_i_g__t.html">XMC_I2C_CH_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init_brg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">config</td><td>Constant pointer to I2C channel config structure of type <a class="el" href="struct_x_m_c___i2_c___c_h___c_o_n_f_i_g__t.html">XMC_I2C_CH_CONFIG_t</a> </td></tr>
    <tr><td class="paramname">init_brg</td><td>Selects if the baudrate generator should be configured automatically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initializes the I2C <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Configures the data format in SCTR register. Sets the slave address, baud rate. Enables transmit data valid, clears status flags and disables parity generation.<br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga0567321036170adb335fef9b36dc3b71">XMC_USIC_CH_Enable()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="gad5e1a8e56b356c2fc246c8b3b95bfb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5e1a8e56b356c2fc246c8b3b95bfb74">&#9670;&nbsp;</a></span>XMC_I2C_CH_MasterReceiveAck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_MasterReceiveAck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sends the Ack request from I2C master <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Reads the transmit buffer status is busy or not and thereby updates IN/TBUF register based on FIFO/non-FIFO modes using Master Receive Ack command.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="gae5960060afec908c91cd8e4a78e5eae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5960060afec908c91cd8e4a78e5eae9">&#9670;&nbsp;</a></span>XMC_I2C_CH_MasterReceiveNack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_MasterReceiveNack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sends the Nack request from I2C master <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Reads the transmit buffer status is busy or not and thereby updates IN/TBUF register based on FIFO/non-FIFO modes using Master Receive Nack command.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="ga770a5f71ceb3b447f21a8b129df6486e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga770a5f71ceb3b447f21a8b129df6486e">&#9670;&nbsp;</a></span>XMC_I2C_CH_MasterRepeatedStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_MasterRepeatedStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_c.html#gaf81b9bb81ece318669b08149f1fd7f4b">XMC_I2C_CH_CMD_t</a>&#160;</td>
          <td class="paramname"><em>command</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">addr</td><td>I2C master address </td></tr>
    <tr><td class="paramname">command</td><td>read/write command </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sends the repeated start condition from I2C master <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Sends the repeated start condition with read/write command by updating IN/TBUF register based on FIFO/non-FIFO modes.<br />
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Address(addr) should reserve an additional bit at the LSB for read/write indication. For example, address 0x05 should be provided as 0x0a. If the address is 10-bit, only most significant bits with the 10-bit identifier should be sent using this function. For example, if the 10-bit address is 0x305, the address should be provided as 0xf6(prepend with 0b11110, upper two bits of address 0b11, followed by 1-bit field for read/write).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit()</a>, <a class="el" href="group___u_s_i_c.html#ga091c9637a98727f1dce0d159764aea24">XMC_USIC_CH_GetTransmitBufferStatus()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="gaebd425a409b805d4571e75f793317070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebd425a409b805d4571e75f793317070">&#9670;&nbsp;</a></span>XMC_I2C_CH_MasterStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_MasterStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_c.html#gaf81b9bb81ece318669b08149f1fd7f4b">XMC_I2C_CH_CMD_t</a>&#160;</td>
          <td class="paramname"><em>command</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">addr</td><td>I2C master address </td></tr>
    <tr><td class="paramname">command</td><td>read/write command </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Starts the I2C master <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Sends the Start condition with read/write command by updating IN/TBUF register based on FIFO/non-FIFO modes.<br />
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Address(addr) should reserve an additional bit at the LSB for read/write indication. For example, address 0x05 should be provided as 0x0a. If the address is 10-bit, only most significant bits with the 10-bit identifier should be sent using this function. For example, if the 10-bit address is 0x305, the address should be provided as 0xf6(prepend with 0b11110, upper two bits of address 0b11, followed by 1-bit field for read/write).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit()</a>, <a class="el" href="group___u_s_i_c.html#ga091c9637a98727f1dce0d159764aea24">XMC_USIC_CH_GetTransmitBufferStatus()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="ga6a48dbbe2be7fce74bd328bae5db5141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a48dbbe2be7fce74bd328bae5db5141">&#9670;&nbsp;</a></span>XMC_I2C_CH_MasterStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_MasterStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Stops the I2C master <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Reads the transmit buffer status is busy or not and thereby updates IN/TBUF register based on FIFO/non-FIFO modes using Stop command.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga701835880c9d134de09af56c12ee3383">XMC_I2C_CH_MasterTransmit()</a>, <a class="el" href="group___u_s_i_c.html#ga091c9637a98727f1dce0d159764aea24">XMC_USIC_CH_GetTransmitBufferStatus()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="ga701835880c9d134de09af56c12ee3383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga701835880c9d134de09af56c12ee3383">&#9670;&nbsp;</a></span>XMC_I2C_CH_MasterTransmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_MasterTransmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">data</td><td>data to transmit from I2C <em>channel</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Transmit the data from the I2C master <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Reads the transmit buffer status is busy or not and thereby updates IN/TBUF register based on FIFO/non-FIFO modes using Master Send command.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga091c9637a98727f1dce0d159764aea24">XMC_USIC_CH_GetTransmitBufferStatus()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="ga0caf9dbe9035171cc4826ad279a857a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0caf9dbe9035171cc4826ad279a857a3">&#9670;&nbsp;</a></span>XMC_I2C_CH_SelectInterruptNodePointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_SelectInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_c.html#ga797641917b01a783e6e7aac5d25a298f">XMC_I2C_CH_INTERRUPT_NODE_POINTER_t</a>&#160;</td>
          <td class="paramname"><em>interrupt_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_c.html#ga71176768512ab2836eb4dc41973c1339">XMC_I2C0_CH0</a>, <a class="el" href="group___i2_c.html#gafbbadccd3da1cbecf1aac59dd54035dd">XMC_I2C0_CH1</a>,<a class="el" href="group___i2_c.html#ga9ffc942d7d7d6a1a2653c4406f265a16">XMC_I2C1_CH0</a>,<a class="el" href="group___i2_c.html#ga8b7a66d60a6dc718f09b5245187b9fec">XMC_I2C1_CH1</a>,<a class="el" href="group___i2_c.html#gadbd192d1e612ccd4143ec299966a11f0">XMC_I2C2_CH0</a>,<a class="el" href="group___i2_c.html#ga7d470379c765ee393530da6b97372122">XMC_I2C2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of I2C1 and I2C2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interrupt_node</td><td>Interrupt node pointer to be configured. <br />
 <b>Range:</b> <a class="el" href="group___i2_c.html#gga797641917b01a783e6e7aac5d25a298fafd73773ef7c86cc9030d4766b6dad775">XMC_I2C_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT</a>, <a class="el" href="group___i2_c.html#gga797641917b01a783e6e7aac5d25a298fa30e7d3a2e8ad4bb38a00f428454b517c">XMC_I2C_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER</a> etc. </td></tr>
    <tr><td class="paramname">service_request</td><td>Service request number.<br />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the interrupt node for USIC channel events. <br />
<br />
For an event to generate interrupt, node pointer should be configured with service request(SR0, SR1..SR5). The NVIC node gets linked to the interrupt event by doing so.<br />
 Note: NVIC node should be separately enabled to generate the interrupt.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga868f80d9e08a0518c38100dda3f77882">XMC_I2C_CH_EnableEvent()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga0da1b672c78d08d3ffdb83316d1443cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0da1b672c78d08d3ffdb83316d1443cb">&#9670;&nbsp;</a></span>XMC_I2C_CH_SetBaudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c.html#gacba9683fdb659e012642e66bc96a406d">XMC_I2C_CH_STATUS_t</a> XMC_I2C_CH_SetBaudrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">rate</td><td>baud rate of I2C channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the rate of I2C <em>channel</em>.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Standard over sampling is considered if rate &lt;= 100KHz and fast over sampling is considered if rate &gt; 100KHz.<br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gac9feec95c73b09889e494ec6d6898f4f">XMC_USIC_CH_SetBaudrate()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="ga6d2b199b5c216800a315baca1f5b7bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d2b199b5c216800a315baca1f5b7bcb">&#9670;&nbsp;</a></span>XMC_I2C_CH_SetBaudrateEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c.html#gacba9683fdb659e012642e66bc96a406d">XMC_I2C_CH_STATUS_t</a> XMC_I2C_CH_SetBaudrateEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normal_divider_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">rate</td><td>baud rate of I2C channel </td></tr>
    <tr><td class="paramname">normal_divider_mode</td><td>Selects normal divider mode for baudrate generator instead of default fractional divider decreasing jitter of signal at the cost of frequency selection</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the rate of I2C <em>channel</em>.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Standard over sampling is considered if rate &lt;= 100KHz and fast over sampling is considered if rate &gt; 100KHz.<br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gac9feec95c73b09889e494ec6d6898f4f">XMC_USIC_CH_SetBaudrate()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="ga206a30449f5196a40611f3bbe5bf39ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga206a30449f5196a40611f3bbe5bf39ba">&#9670;&nbsp;</a></span>XMC_I2C_CH_SetHoldDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_SetHoldDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hdel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A constant pointer to <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a>, pointing to the USIC channel base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>To respect the specified SDA hold time of 300 ns for standard mode and fast mode after a falling edge of signal SCL, a hold delay tHDEL has been introduced. It also prevents an erroneous detection of a start or a stop condition. The length of this delay can be programmed by bit field PCR.HDEL. Taking into account the input sampling and output update, bit field HDEL can be programmed according to:<ul>
<li>HDEL &gt;= 300ns x fPPP - (3 x fPPP/fPERIH) + 1 (with digital filter and HDELmin = 2)</li>
<li>HDEL &gt;= 300ns x fPPP - (3 x fPPP/fPERIH) + 2 (without digital filter and HDELmin = 1) If the digital input filter is used, HDEL compensates the filter delay of 2 filter periods (fPPP should be used) in case of a spike on the input signal. This ensures that a data bit on the SDA line changing just before the rising edge or behind the falling edge of SCL will not be treated as a start or stop condition. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga358214504f42dac696c4519efa19307b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga358214504f42dac696c4519efa19307b">&#9670;&nbsp;</a></span>XMC_I2C_CH_SetInputSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_SetInputSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___i2_c.html#ga76b49d68cc6d179beaf1dfe2998230bd">XMC_I2C_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">input</td><td>I2C channel input stage of type <a class="el" href="group___i2_c.html#ga76b49d68cc6d179beaf1dfe2998230bd">XMC_I2C_CH_INPUT_t</a> </td></tr>
    <tr><td class="paramname">source</td><td>Input source select for the input stage(0-&gt;DX0A, 1-&gt;DX1A, .. 7-&gt;DX7G) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the input source for I2C <em>channel</em>.<br />
 Defines the input stage for the corresponding input line.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After configuring the input source for corresponding channel, interrupt node pointer is set.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>XMC_USIC_CH_SetInptSource(), <a class="el" href="group___u_s_i_c.html#ga52f9fc18049dbc906b127e1f3662b4b3">XMC_USIC_CH_SetInterruptNodePointer()</a> </dd></dl>

</div>
</div>
<a id="gada2c698290a70ed692f067756ececd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada2c698290a70ed692f067756ececd4d">&#9670;&nbsp;</a></span>XMC_I2C_CH_SetInterruptNodePointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_SetInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">service_request</td><td>Service request number in the range of 0-5 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the interrupt node for protocol interrupt.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>To generate interrupt for an event, node pointer should be configured with service request number(SR0, SR1..SR5). The NVIC node gets linked to the interrupt event by doing so.<br />
</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>NVIC node should be separately enabled to generate the interrupt. After setting the node pointer, desired event must be enabled.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga868f80d9e08a0518c38100dda3f77882">XMC_I2C_CH_EnableEvent()</a>, NVIC_SetPriority(), NVIC_EnableIRQ(), <a class="el" href="group___i2_c.html#ga358214504f42dac696c4519efa19307b">XMC_I2C_CH_SetInputSource()</a><br />
 </dd></dl>

</div>
</div>
<a id="gaec9df234c44378c3fc10f0423d71aec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec9df234c44378c3fc10f0423d71aec9">&#9670;&nbsp;</a></span>XMC_I2C_CH_SetSlaveAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_SetSlaveAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">address</td><td>I2C slave address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the I2C <em>channel</em> slave address.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Address is set in PCR_IICMode register by checking if it is in 10-bit address group or 7-bit address group. (If first five bits of address are assigned with 0xF0, then address mode is 10-bit mode otherwise it is 7-bit mode)<br />
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A 7-bit address should include an additional bit at the LSB for read/write indication. For example, address 0x05 should be provided as 0x0a. A 10-bit address should be provided with the identifier 0b11110xx at the most significant bits. For example, address 0x305 should be provided as 0x7b05(bitwise OR with 0x7800).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga9131749645c421ff4b8bc80d0c93b691">XMC_I2C_CH_GetSlaveAddress()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="gafdd7192c5a6b3fa481f293fb0a574665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdd7192c5a6b3fa481f293fb0a574665">&#9670;&nbsp;</a></span>XMC_I2C_CH_SlaveTransmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_SlaveTransmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> </td></tr>
    <tr><td class="paramname">data</td><td>data to transmit from I2C <em>channel</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Transmit the data from the I2C slave <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Reads the transmit buffer status is busy or not and thereby updates IN/TBUF register based on FIFO/non-FIFO modes using Slave Send command.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga091c9637a98727f1dce0d159764aea24">XMC_USIC_CH_GetTransmitBufferStatus()</a>,<a class="el" href="group___i2_c.html#gab922e97164d14898b92df3d30c10fe83">XMC_I2C_CH_ClearStatusFlag()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="gad3de1b923c1a3c0a2b1ea9a8d9ff1d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3de1b923c1a3c0a2b1ea9a8d9ff1d91">&#9670;&nbsp;</a></span>XMC_I2C_CH_Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Starts the I2C <em>channel</em>.</dd></dl>
<dl class="section user"><dt></dt><dd>Sets the USIC input operation mode to I2C mode using CCR register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga8c04c213fd44c14b1bed871bb658683c">XMC_USIC_CH_SetMode()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="ga4eeda18d28c90e527c309726ff5d3cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4eeda18d28c90e527c309726ff5d3cb9">&#9670;&nbsp;</a></span>XMC_I2C_CH_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c.html#gacba9683fdb659e012642e66bc96a406d">XMC_I2C_CH_STATUS_t</a> XMC_I2C_CH_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel structure of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___i2_c.html#gacba9683fdb659e012642e66bc96a406d">XMC_I2C_CH_STATUS_t<br />
</a></dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Stops the I2C <em>channel</em>.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Sets the USIC input operation to IDLE mode using CCR register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#ga8c04c213fd44c14b1bed871bb658683c">XMC_USIC_CH_SetMode()</a><br />
<br />
</dd></dl>

</div>
</div>
<a id="ga72d5d08ec30a105175f9a789ab38c1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72d5d08ec30a105175f9a789ab38c1c7">&#9670;&nbsp;</a></span>XMC_I2C_CH_TriggerServiceRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_I2C_CH_TriggerServiceRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>service_request_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___i2_c.html#ga71176768512ab2836eb4dc41973c1339">XMC_I2C0_CH0</a>, <a class="el" href="group___i2_c.html#gafbbadccd3da1cbecf1aac59dd54035dd">XMC_I2C0_CH1</a>,<a class="el" href="group___i2_c.html#ga9ffc942d7d7d6a1a2653c4406f265a16">XMC_I2C1_CH0</a>,<a class="el" href="group___i2_c.html#ga8b7a66d60a6dc718f09b5245187b9fec">XMC_I2C1_CH1</a>,<a class="el" href="group___i2_c.html#gadbd192d1e612ccd4143ec299966a11f0">XMC_I2C2_CH0</a>,<a class="el" href="group___i2_c.html#ga7d470379c765ee393530da6b97372122">XMC_I2C2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of I2C1 and I2C2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_request_line</td><td>service request number of the event to be triggered. <br />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Trigger a I2C interrupt service request.<br />
<br />
When the I2C service request is triggered, the NVIC interrupt associated with it will be generated if enabled.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___i2_c.html#ga0caf9dbe9035171cc4826ad279a857a3">XMC_I2C_CH_SelectInterruptNodePointer()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>XMC Peripheral Library for XMC4000 Family</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
