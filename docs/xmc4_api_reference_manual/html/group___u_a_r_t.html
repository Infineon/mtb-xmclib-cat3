<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XMC Peripheral Library for XMC4000 Family: Universal Asynchronous Receiver/Transmitter (UART)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFX_LOGO_4C_medium.bmp"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC4000 Family</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___u_a_r_t.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Universal Asynchronous Receiver/Transmitter (UART)</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___u_a_r_t___c_h___c_o_n_f_i_g__t.html">XMC_UART_CH_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga3dc31990cf98c3e7cf5743793187bd01"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a></td></tr>
<tr class="separator:ga3dc31990cf98c3e7cf5743793187bd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa04c64ad7fa9ae5db3dd9b8b7999ef49"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a></td></tr>
<tr class="separator:gaa04c64ad7fa9ae5db3dd9b8b7999ef49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad784f4e853952a3d0be9f260a0f1c3c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab3012ea0f6b1dddc5b1c05425e15c4a1">XMC_USIC1_CH0</a></td></tr>
<tr class="separator:gad784f4e853952a3d0be9f260a0f1c3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a09c318f27492e33d0d3e341ae0703e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga8892cec48c6246ff3e470178e4273f99">XMC_USIC1_CH1</a></td></tr>
<tr class="separator:ga8a09c318f27492e33d0d3e341ae0703e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb94319572f1e75648bcf89a98da324a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab79d676f4efb3235bd3d8c977b83b1cf">XMC_USIC2_CH0</a></td></tr>
<tr class="separator:gaeb94319572f1e75648bcf89a98da324a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa231ac5218c378cfa8801ae63ca8ee79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a>&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a></td></tr>
<tr class="separator:gaa231ac5218c378cfa8801ae63ca8ee79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga122d0cf7042ea6cb81ccdb50df5f62b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga122d0cf7042ea6cb81ccdb50df5f62b6">XMC_UART_CH_EVENT_t</a> </td></tr>
<tr class="separator:ga122d0cf7042ea6cb81ccdb50df5f62b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2deb0d11792f241e1e5c02e6a4063998"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga2deb0d11792f241e1e5c02e6a4063998">XMC_UART_CH_INPUT_SAMPLING_FREQ_t</a> </td></tr>
<tr class="separator:ga2deb0d11792f241e1e5c02e6a4063998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7358da2d90633473ae9de4636ddb3a46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> </td></tr>
<tr class="separator:ga7358da2d90633473ae9de4636ddb3a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29676690a77272438ef1cfc21575ff6d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga29676690a77272438ef1cfc21575ff6d">XMC_UART_CH_INTERRUPT_NODE_POINTER_t</a> </td></tr>
<tr class="separator:ga29676690a77272438ef1cfc21575ff6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga802a057f335dc7bc1465ae11b19d09af"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga802a057f335dc7bc1465ae11b19d09af">XMC_UART_CH_STATUS_FLAG_t</a> </td></tr>
<tr class="separator:ga802a057f335dc7bc1465ae11b19d09af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd220ce3211af8111e0af876a0619788"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gadd220ce3211af8111e0af876a0619788">XMC_UART_CH_STATUS_t</a> </td></tr>
<tr class="separator:gadd220ce3211af8111e0af876a0619788"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6840ff2cfd59836fea619b9c1cfbbac5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga6840ff2cfd59836fea619b9c1cfbbac5">XMC_UART_CH_ClearStatusFlag</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t flag)</td></tr>
<tr class="separator:ga6840ff2cfd59836fea619b9c1cfbbac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935afb3b95df6c123883f44a1d63208f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga935afb3b95df6c123883f44a1d63208f">XMC_UART_CH_DisableDataTransmission</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga935afb3b95df6c123883f44a1d63208f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87743034df2fe747615ce39a6b870a0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga87743034df2fe747615ce39a6b870a0c">XMC_UART_CH_DisableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:ga87743034df2fe747615ce39a6b870a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef225ec3a0bc7db11ddf0b4f260a905c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaef225ec3a0bc7db11ddf0b4f260a905c">XMC_UART_CH_DisableInputDigitalFilter</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:gaef225ec3a0bc7db11ddf0b4f260a905c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd566960d84740ec0c0713197839b071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gafd566960d84740ec0c0713197839b071">XMC_UART_CH_DisableInputInversion</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:gafd566960d84740ec0c0713197839b071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga655549975b9c7dce3fb9f28c89b5685f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga655549975b9c7dce3fb9f28c89b5685f">XMC_UART_CH_DisableInputSync</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga655549975b9c7dce3fb9f28c89b5685f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34495c14c7650599ba2e2ab348333cf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga34495c14c7650599ba2e2ab348333cf9">XMC_UART_CH_DisableMasterClock</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga34495c14c7650599ba2e2ab348333cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac81a2e2617e9c6e9ddd314036185c08f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gac81a2e2617e9c6e9ddd314036185c08f">XMC_UART_CH_EnableDataTransmission</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:gac81a2e2617e9c6e9ddd314036185c08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf511dd60e7f23bc40bad0207ff9bd266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaf511dd60e7f23bc40bad0207ff9bd266">XMC_UART_CH_EnableEvent</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t event)</td></tr>
<tr class="separator:gaf511dd60e7f23bc40bad0207ff9bd266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeec73a4f59460bbe97aad10c1d925c73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaeec73a4f59460bbe97aad10c1d925c73">XMC_UART_CH_EnableInputDigitalFilter</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:gaeec73a4f59460bbe97aad10c1d925c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95acf430dde4497f55838626ec22b808"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga95acf430dde4497f55838626ec22b808">XMC_UART_CH_EnableInputInversion</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga95acf430dde4497f55838626ec22b808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52aa3807f291f58be66b4d946aec7d47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga52aa3807f291f58be66b4d946aec7d47">XMC_UART_CH_EnableInputSync</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> input)</td></tr>
<tr class="separator:ga52aa3807f291f58be66b4d946aec7d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60eafedc1effa37f174e772a313c94fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga60eafedc1effa37f174e772a313c94fa">XMC_UART_CH_EnableMasterClock</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga60eafedc1effa37f174e772a313c94fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga578c15fc0df2e8ea7a265c92c0a26536"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga578c15fc0df2e8ea7a265c92c0a26536">XMC_UART_CH_GetReceivedData</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga578c15fc0df2e8ea7a265c92c0a26536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5578bae41ea73c00dd704924c63f7370"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga5578bae41ea73c00dd704924c63f7370">XMC_UART_CH_GetStatusFlag</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga5578bae41ea73c00dd704924c63f7370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga719ad21f9ccaf9585dd0b473b4daef7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga719ad21f9ccaf9585dd0b473b4daef7e">XMC_UART_CH_Init</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="struct_x_m_c___u_a_r_t___c_h___c_o_n_f_i_g__t.html">XMC_UART_CH_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga719ad21f9ccaf9585dd0b473b4daef7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca0ca9010bb1284a819b265694b7a5f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaca0ca9010bb1284a819b265694b7a5f0">XMC_UART_CH_InitEx</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *channel, const <a class="el" href="struct_x_m_c___u_a_r_t___c_h___c_o_n_f_i_g__t.html">XMC_UART_CH_CONFIG_t</a> *const config, bool init_brg)</td></tr>
<tr class="separator:gaca0ca9010bb1284a819b265694b7a5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd72632ef25d7f44d8518141fde99a2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gadd72632ef25d7f44d8518141fde99a2c">XMC_UART_CH_SelectInterruptNodePointer</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga29676690a77272438ef1cfc21575ff6d">XMC_UART_CH_INTERRUPT_NODE_POINTER_t</a> interrupt_node, const uint32_t service_request)</td></tr>
<tr class="separator:gadd72632ef25d7f44d8518141fde99a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f757d62a86fc8944cf7188137490b62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t.html#gadd220ce3211af8111e0af876a0619788">XMC_UART_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga0f757d62a86fc8944cf7188137490b62">XMC_UART_CH_SetBaudrate</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, uint32_t rate, uint32_t oversampling)</td></tr>
<tr class="separator:ga0f757d62a86fc8944cf7188137490b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga516877b6a939a19eb1c7ec772b6535f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t.html#gadd220ce3211af8111e0af876a0619788">XMC_UART_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga516877b6a939a19eb1c7ec772b6535f1">XMC_UART_CH_SetBaudrateEx</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, uint32_t rate, uint32_t oversampling, bool normal_divider_mode)</td></tr>
<tr class="separator:ga516877b6a939a19eb1c7ec772b6535f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f6eb4a3265729b4b7cf7e3d198130d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga9f6eb4a3265729b4b7cf7e3d198130d6">XMC_UART_CH_SetFrameLength</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t frame_length)</td></tr>
<tr class="separator:ga9f6eb4a3265729b4b7cf7e3d198130d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c3cf150769886938ceb811557db243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gad6c3cf150769886938ceb811557db243">XMC_UART_CH_SetInputSamplingFreq</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> input, const <a class="el" href="group___u_a_r_t.html#ga2deb0d11792f241e1e5c02e6a4063998">XMC_UART_CH_INPUT_SAMPLING_FREQ_t</a> sampling_freq)</td></tr>
<tr class="separator:gad6c3cf150769886938ceb811557db243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f6aded563def78ca10e8638889bd898"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga1f6aded563def78ca10e8638889bd898">XMC_UART_CH_SetInputSource</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a> input, const uint8_t source)</td></tr>
<tr class="separator:ga1f6aded563def78ca10e8638889bd898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa013e09337b1c9c05b41eac29b2518ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gaa013e09337b1c9c05b41eac29b2518ea">XMC_UART_CH_SetInterruptNodePointer</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t service_request)</td></tr>
<tr class="separator:gaa013e09337b1c9c05b41eac29b2518ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12f39dca3684261d4e35aeb7af9c82a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga12f39dca3684261d4e35aeb7af9c82a9">XMC_UART_CH_SetPulseLength</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t pulse_length)</td></tr>
<tr class="separator:ga12f39dca3684261d4e35aeb7af9c82a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacabdceef217f1be937dc494ce9140765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#gacabdceef217f1be937dc494ce9140765">XMC_UART_CH_SetSamplePoint</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t sample_point)</td></tr>
<tr class="separator:gacabdceef217f1be937dc494ce9140765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b12b3bdebda3d3a6c28d5c79a12735b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga6b12b3bdebda3d3a6c28d5c79a12735b">XMC_UART_CH_SetWordLength</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint8_t word_length)</td></tr>
<tr class="separator:ga6b12b3bdebda3d3a6c28d5c79a12735b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga786385b5527c6c6405d7e9e3626e0587"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga786385b5527c6c6405d7e9e3626e0587">XMC_UART_CH_Start</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga786385b5527c6c6405d7e9e3626e0587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga083e4d7b2be613994d61ebc9841f7ebd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t.html#gadd220ce3211af8111e0af876a0619788">XMC_UART_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga083e4d7b2be613994d61ebc9841f7ebd">XMC_UART_CH_Stop</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel)</td></tr>
<tr class="separator:ga083e4d7b2be613994d61ebc9841f7ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a9b41f5d74a0dde43d9b19166ffa7c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga3a9b41f5d74a0dde43d9b19166ffa7c6">XMC_UART_CH_Transmit</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint16_t data)</td></tr>
<tr class="separator:ga3a9b41f5d74a0dde43d9b19166ffa7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a3d22e4821ed95b364793b3a7e711c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t.html#ga3a3d22e4821ed95b364793b3a7e711c0">XMC_UART_CH_TriggerServiceRequest</a> (<a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const channel, const uint32_t service_request_line)</td></tr>
<tr class="separator:ga3a3d22e4821ed95b364793b3a7e711c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The UART driver uses Universal Serial Interface Channel(USIC) module to implement UART protocol. It provides APIs to configure USIC channel for UART communication. The driver enables the user in getting the status of UART protocol events, configuring interrupt service requests, protocol related parameter configuration etc.</p>
<p>UART driver features:</p><ol type="1">
<li>Configuration structure <a class="el" href="struct_x_m_c___u_a_r_t___c_h___c_o_n_f_i_g__t.html">XMC_UART_CH_CONFIG_t</a> and initialization function <a class="el" href="group___u_a_r_t.html#ga719ad21f9ccaf9585dd0b473b4daef7e">XMC_UART_CH_Init()</a></li>
<li>Enumeration of events with their bit masks <a class="el" href="group___u_a_r_t.html#ga122d0cf7042ea6cb81ccdb50df5f62b6">XMC_UART_CH_EVENT_t</a>, <a class="el" href="group___u_a_r_t.html#ga802a057f335dc7bc1465ae11b19d09af">XMC_UART_CH_STATUS_FLAG_t</a></li>
<li>Allows the selection of input source for the DX0 input stage using the API <a class="el" href="group___u_a_r_t.html#ga1f6aded563def78ca10e8638889bd898">XMC_UART_CH_SetInputSource()</a></li>
<li>Allows configuration of baudrate using <a class="el" href="group___u_a_r_t.html#ga0f757d62a86fc8944cf7188137490b62">XMC_UART_CH_SetBaudrate()</a> and configuration of data length using <a class="el" href="group___u_a_r_t.html#ga6b12b3bdebda3d3a6c28d5c79a12735b">XMC_UART_CH_SetWordLength()</a> and <a class="el" href="group___u_a_r_t.html#ga9f6eb4a3265729b4b7cf7e3d198130d6">XMC_UART_CH_SetFrameLength()</a></li>
<li>Provides the status of UART protocol events, <a class="el" href="group___u_a_r_t.html#ga5578bae41ea73c00dd704924c63f7370">XMC_UART_CH_GetStatusFlag()</a></li>
<li>Allows transmission of data using <a class="el" href="group___u_a_r_t.html#ga3a9b41f5d74a0dde43d9b19166ffa7c6">XMC_UART_CH_Transmit()</a> and gets received data using <a class="el" href="group___u_a_r_t.html#ga578c15fc0df2e8ea7a265c92c0a26536">XMC_UART_CH_GetReceivedData()</a> </li>
</ol>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga3dc31990cf98c3e7cf5743793187bd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dc31990cf98c3e7cf5743793187bd01">&#9670;&nbsp;</a></span>XMC_UART0_CH0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_UART0_CH0&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga28dd6da4b742e7336b12ae6fa8de5e9f">XMC_USIC0_CH0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC0 channel 0 base address </p>

</div>
</div>
<a id="gaa04c64ad7fa9ae5db3dd9b8b7999ef49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">&#9670;&nbsp;</a></span>XMC_UART0_CH1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_UART0_CH1&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab7c9a3765e7d637114fc67951cf20c5b">XMC_USIC0_CH1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC0 channel 1 base address </p>

</div>
</div>
<a id="gad784f4e853952a3d0be9f260a0f1c3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad784f4e853952a3d0be9f260a0f1c3c6">&#9670;&nbsp;</a></span>XMC_UART1_CH0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_UART1_CH0&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab3012ea0f6b1dddc5b1c05425e15c4a1">XMC_USIC1_CH0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC1 channel 0 base address </p>

</div>
</div>
<a id="ga8a09c318f27492e33d0d3e341ae0703e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a09c318f27492e33d0d3e341ae0703e">&#9670;&nbsp;</a></span>XMC_UART1_CH1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_UART1_CH1&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga8892cec48c6246ff3e470178e4273f99">XMC_USIC1_CH1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC1 channel 1 base address </p>

</div>
</div>
<a id="gaeb94319572f1e75648bcf89a98da324a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb94319572f1e75648bcf89a98da324a">&#9670;&nbsp;</a></span>XMC_UART2_CH0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_UART2_CH0&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#gab79d676f4efb3235bd3d8c977b83b1cf">XMC_USIC2_CH0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC2 channel 0 base address </p>

</div>
</div>
<a id="gaa231ac5218c378cfa8801ae63ca8ee79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa231ac5218c378cfa8801ae63ca8ee79">&#9670;&nbsp;</a></span>XMC_UART2_CH1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_UART2_CH1&#160;&#160;&#160;<a class="el" href="group___u_s_i_c.html#ga6f71692f25917f0dcd77bb77e5518313">XMC_USIC2_CH1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USIC2 channel 1 base address </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga122d0cf7042ea6cb81ccdb50df5f62b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga122d0cf7042ea6cb81ccdb50df5f62b6">&#9670;&nbsp;</a></span>XMC_UART_CH_EVENT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga122d0cf7042ea6cb81ccdb50df5f62b6">XMC_UART_CH_EVENT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART configuration events. The enums can be used for configuring events using the CCR register. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga122d0cf7042ea6cb81ccdb50df5f62b6addd2af8f6f565002a1b4ea856b7bbcee"></a>XMC_UART_CH_EVENT_RECEIVE_START&#160;</td><td class="fielddoc"><p>Receive start event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga122d0cf7042ea6cb81ccdb50df5f62b6a6e76badf4b36a6fa694cd7c4c0d873b9"></a>XMC_UART_CH_EVENT_DATA_LOST&#160;</td><td class="fielddoc"><p>Data lost event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga122d0cf7042ea6cb81ccdb50df5f62b6af28054e5044087c68da450015df6771f"></a>XMC_UART_CH_EVENT_TRANSMIT_SHIFT&#160;</td><td class="fielddoc"><p>Transmit shift event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga122d0cf7042ea6cb81ccdb50df5f62b6a26b35a7f887b79474fa97856749f182b"></a>XMC_UART_CH_EVENT_TRANSMIT_BUFFER&#160;</td><td class="fielddoc"><p>Transmit buffer event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga122d0cf7042ea6cb81ccdb50df5f62b6a3fec2fc1685b8db717c095a21053240a"></a>XMC_UART_CH_EVENT_STANDARD_RECEIVE&#160;</td><td class="fielddoc"><p>Receive event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga122d0cf7042ea6cb81ccdb50df5f62b6ad640d6bca0daeeb45ac4023b1e4db5b4"></a>XMC_UART_CH_EVENT_ALTERNATIVE_RECEIVE&#160;</td><td class="fielddoc"><p>Alternate receive event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga122d0cf7042ea6cb81ccdb50df5f62b6ac9364f8566efee358ffc0491940122e2"></a>XMC_UART_CH_EVENT_BAUD_RATE_GENERATOR&#160;</td><td class="fielddoc"><p>Baudrate generator event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga122d0cf7042ea6cb81ccdb50df5f62b6a266352a130a03ea0a41565bc695ef146"></a>XMC_UART_CH_EVENT_SYNCHRONIZATION_BREAK&#160;</td><td class="fielddoc"><p>Event synchronization break </p>
</td></tr>
<tr><td class="fieldname"><a id="gga122d0cf7042ea6cb81ccdb50df5f62b6acf263e5b91743a7e5d424d551a9f177b"></a>XMC_UART_CH_EVENT_COLLISION&#160;</td><td class="fielddoc"><p>Event collision </p>
</td></tr>
<tr><td class="fieldname"><a id="gga122d0cf7042ea6cb81ccdb50df5f62b6a9045609949ae1b88827a4ec8fd005b93"></a>XMC_UART_CH_EVENT_RECEIVER_NOISE&#160;</td><td class="fielddoc"><p>Event receiver noise </p>
</td></tr>
<tr><td class="fieldname"><a id="gga122d0cf7042ea6cb81ccdb50df5f62b6aef5d7acb2f77f77405a56b2c04fbaba5"></a>XMC_UART_CH_EVENT_FORMAT_ERROR&#160;</td><td class="fielddoc"><p>Event format error </p>
</td></tr>
<tr><td class="fieldname"><a id="gga122d0cf7042ea6cb81ccdb50df5f62b6a2ea7a5f9780633b9cb5702c1fc7296d2"></a>XMC_UART_CH_EVENT_FRAME_FINISHED&#160;</td><td class="fielddoc"><p>Event frame finished </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2deb0d11792f241e1e5c02e6a4063998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2deb0d11792f241e1e5c02e6a4063998">&#9670;&nbsp;</a></span>XMC_UART_CH_INPUT_SAMPLING_FREQ_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga2deb0d11792f241e1e5c02e6a4063998">XMC_UART_CH_INPUT_SAMPLING_FREQ_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART Input sampling frequency options </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2deb0d11792f241e1e5c02e6a4063998a916e6151ac686996fbef2b0c059d0527"></a>XMC_UART_CH_INPUT_SAMPLING_FREQ_FPERIPH&#160;</td><td class="fielddoc"><p>Sampling frequency input fperiph </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2deb0d11792f241e1e5c02e6a4063998ac1ae8f6ca1096c61ca0619dae0a18b92"></a>XMC_UART_CH_INPUT_SAMPLING_FREQ_FRACTIONAL_DIVIDER&#160;</td><td class="fielddoc"><p>Sampling frequency input fractional divider </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7358da2d90633473ae9de4636ddb3a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7358da2d90633473ae9de4636ddb3a46">&#9670;&nbsp;</a></span>XMC_UART_CH_INPUT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART input stages </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d"></a>XMC_UART_CH_INPUT_RXD&#160;</td><td class="fielddoc"><p>UART input stage DX0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7358da2d90633473ae9de4636ddb3a46a66212b93204c18de9680a5b45d41e327"></a>XMC_UART_CH_INPUT_RXD1&#160;</td><td class="fielddoc"><p>UART input stage DX3 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7358da2d90633473ae9de4636ddb3a46a1dbf3656536ec612da6a63ecd25e67d4"></a>XMC_UART_CH_INPUT_RXD2&#160;</td><td class="fielddoc"><p>UART input stage DX5 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga29676690a77272438ef1cfc21575ff6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29676690a77272438ef1cfc21575ff6d">&#9670;&nbsp;</a></span>XMC_UART_CH_INTERRUPT_NODE_POINTER_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga29676690a77272438ef1cfc21575ff6d">XMC_UART_CH_INTERRUPT_NODE_POINTER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART channel interrupt node pointers </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga29676690a77272438ef1cfc21575ff6da0069cc6489d3bf33490bf4cc95e998d4"></a>XMC_UART_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT&#160;</td><td class="fielddoc"><p>Node pointer for transmit shift interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29676690a77272438ef1cfc21575ff6da59a31b003753d05ac1b5d5067751121e"></a>XMC_UART_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER&#160;</td><td class="fielddoc"><p>Node pointer for transmit buffer interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29676690a77272438ef1cfc21575ff6da668bf0b677803516a7815b85cc98880d"></a>XMC_UART_CH_INTERRUPT_NODE_POINTER_RECEIVE&#160;</td><td class="fielddoc"><p>Node pointer for receive interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29676690a77272438ef1cfc21575ff6daa2617445b7d8d4c1b05dda8e02c1e431"></a>XMC_UART_CH_INTERRUPT_NODE_POINTER_ALTERNATE_RECEIVE&#160;</td><td class="fielddoc"><p>Node pointer for alternate receive interrupt </p>
</td></tr>
<tr><td class="fieldname"><a id="gga29676690a77272438ef1cfc21575ff6dad86f5c91df1f3e5713ed174d1371a3f5"></a>XMC_UART_CH_INTERRUPT_NODE_POINTER_PROTOCOL&#160;</td><td class="fielddoc"><p>Node pointer for protocol related interrupts </p>
</td></tr>
</table>

</div>
</div>
<a id="ga802a057f335dc7bc1465ae11b19d09af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga802a057f335dc7bc1465ae11b19d09af">&#9670;&nbsp;</a></span>XMC_UART_CH_STATUS_FLAG_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#ga802a057f335dc7bc1465ae11b19d09af">XMC_UART_CH_STATUS_FLAG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART portocol status. The enum values can be used for getting the status of UART channel. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afa8838558f1c949dfdfa117908e21d7058"></a>XMC_UART_CH_STATUS_FLAG_TRANSMISSION_IDLE&#160;</td><td class="fielddoc"><p>UART Protocol Status transmit IDLE </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afa02d60fc761d9eee4c4d1c525f2429a5c"></a>XMC_UART_CH_STATUS_FLAG_RECEPTION_IDLE&#160;</td><td class="fielddoc"><p>UART Protocol Status receive IDLE </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afaeaf9ee65696e36e06e012e0e3e5b5855"></a>XMC_UART_CH_STATUS_FLAG_SYNCHRONIZATION_BREAK_DETECTED&#160;</td><td class="fielddoc"><p>UART Protocol Status synchronization break detected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afa1127a4bc2e8bca81c351cdc344245fd0"></a>XMC_UART_CH_STATUS_FLAG_COLLISION_DETECTED&#160;</td><td class="fielddoc"><p>UART Protocol Status collision detected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afa147a2ad3b6ab6a1aacb07fa971eb1275"></a>XMC_UART_CH_STATUS_FLAG_RECEIVER_NOISE_DETECTED&#160;</td><td class="fielddoc"><p>UART Protocol Status receiver noise detected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afaf6d928be53c8c901a05872e3ef950bc7"></a>XMC_UART_CH_STATUS_FLAG_FORMAT_ERROR_IN_STOP_BIT_0&#160;</td><td class="fielddoc"><p>UART Protocol Status format error in stop bit 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afa5733cca57c6cff9c79da3c824e644a72"></a>XMC_UART_CH_STATUS_FLAG_FORMAT_ERROR_IN_STOP_BIT_1&#160;</td><td class="fielddoc"><p>UART Protocol Status format error in stop bit 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afa5abbfe2717ee3117550e329d90769863"></a>XMC_UART_CH_STATUS_FLAG_RECEIVE_FRAME_FINISHED&#160;</td><td class="fielddoc"><p>UART Protocol Status receive frame finished </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afae8fe75675b2f99f20032577dd0ca4f7c"></a>XMC_UART_CH_STATUS_FLAG_TRANSMITTER_FRAME_FINISHED&#160;</td><td class="fielddoc"><p>UART Protocol Status transmit frame finished </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afa68079f24c35e5259c9984e39c602db45"></a>XMC_UART_CH_STATUS_FLAG_TRANSFER_STATUS_BUSY&#160;</td><td class="fielddoc"><p>UART Protocol Status transfer status busy </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afa81b11006a6b243c9f04f4a8a9f5c5735"></a>XMC_UART_CH_STATUS_FLAG_RECEIVER_START_INDICATION&#160;</td><td class="fielddoc"><p>UART Protocol Status receive start indication flag </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afadcd6021f9d2ab0764ae114b544a1244a"></a>XMC_UART_CH_STATUS_FLAG_DATA_LOST_INDICATION&#160;</td><td class="fielddoc"><p>UART Protocol Status data lost indication flag </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afa4b78514f4ad98fead964ecf359c673ae"></a>XMC_UART_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION&#160;</td><td class="fielddoc"><p>UART Protocol Status transmit shift indication flag </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afaa8188ae95171fc9461c3c4905e41739b"></a>XMC_UART_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION&#160;</td><td class="fielddoc"><p>UART Protocol Status transmit buffer indication flag </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afa47f5b38bcab2bc0e1b009cffcca18855"></a>XMC_UART_CH_STATUS_FLAG_RECEIVE_INDICATION&#160;</td><td class="fielddoc"><p>UART Protocol Status receive indication flag </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afaaac652362ebf22f1b23c1e2e4dd52cfa"></a>XMC_UART_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION&#160;</td><td class="fielddoc"><p>UART Protocol Status alternative receive indication flag </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802a057f335dc7bc1465ae11b19d09afa5e66e98130f3a6f072c57295a1a779f7"></a>XMC_UART_CH_STATUS_FLAG_BAUD_RATE_GENERATOR_INDICATION&#160;</td><td class="fielddoc"><p>UART Protocol Status baudrate generator indication flag </p>
</td></tr>
</table>

</div>
</div>
<a id="gadd220ce3211af8111e0af876a0619788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd220ce3211af8111e0af876a0619788">&#9670;&nbsp;</a></span>XMC_UART_CH_STATUS_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t.html#gadd220ce3211af8111e0af876a0619788">XMC_UART_CH_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART driver status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadd220ce3211af8111e0af876a0619788a1d4d4ea36dc6c0ceb6599efed42f0559"></a>XMC_UART_CH_STATUS_OK&#160;</td><td class="fielddoc"><p>UART driver status : OK </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd220ce3211af8111e0af876a0619788a146ec14a2e6f316f449c332a863289b0"></a>XMC_UART_CH_STATUS_ERROR&#160;</td><td class="fielddoc"><p>UART driver status : ERROR </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd220ce3211af8111e0af876a0619788a410817c31e098fd03c04f4d5ecb76ef1"></a>XMC_UART_CH_STATUS_BUSY&#160;</td><td class="fielddoc"><p>UART driver status : BUSY </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6840ff2cfd59836fea619b9c1cfbbac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6840ff2cfd59836fea619b9c1cfbbac5">&#9670;&nbsp;</a></span>XMC_UART_CH_ClearStatusFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_ClearStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>UART events to be cleared. <br />
 <b>Range:</b> Use <a class="el" href="group___u_a_r_t.html#ga802a057f335dc7bc1465ae11b19d09af">XMC_UART_CH_STATUS_FLAG_t</a> enumerations for event bitmasks. <a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa8838558f1c949dfdfa117908e21d7058">XMC_UART_CH_STATUS_FLAG_TRANSMISSION_IDLE</a>, <a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa02d60fc761d9eee4c4d1c525f2429a5c">XMC_UART_CH_STATUS_FLAG_RECEPTION_IDLE</a>, <a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afaeaf9ee65696e36e06e012e0e3e5b5855">XMC_UART_CH_STATUS_FLAG_SYNCHRONIZATION_BREAK_DETECTED</a> etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the status of UART channel events.<br />
<br />
Multiple events can be combined using the bitwise OR operation and configured in one function call. XMC_UART_CH_STATUS_FLAG_t enumerates multiple event bitmasks. These enumerations can be used as input to the API. Events are cleared by setting the bitmask to the PSCR register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga87743034df2fe747615ce39a6b870a0c">XMC_UART_CH_DisableEvent()</a>, <a class="el" href="group___u_a_r_t.html#ga5578bae41ea73c00dd704924c63f7370">XMC_UART_CH_GetStatusFlag()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga935afb3b95df6c123883f44a1d63208f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga935afb3b95df6c123883f44a1d63208f">&#9670;&nbsp;</a></span>XMC_UART_CH_DisableDataTransmission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_DisableDataTransmission </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disable data transmission.<br />
<br />
Use this function in combination with <a class="el" href="group___u_a_r_t.html#gac81a2e2617e9c6e9ddd314036185c08f">XMC_UART_CH_EnableDataTransmission()</a> to fill the FIFO and send the FIFO content without gaps in the transmission. FIFO is filled using <a class="el" href="group___u_s_i_c.html#gae96e9afeaefe2585b687e36f6227727f">XMC_USIC_CH_TXFIFO_PutData()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gac81a2e2617e9c6e9ddd314036185c08f">XMC_UART_CH_EnableDataTransmission()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga87743034df2fe747615ce39a6b870a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87743034df2fe747615ce39a6b870a0c">&#9670;&nbsp;</a></span>XMC_UART_CH_DisableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_DisableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bitmask of events to disable. Use the type <a class="el" href="group___u_a_r_t.html#ga122d0cf7042ea6cb81ccdb50df5f62b6">XMC_UART_CH_EVENT_t</a> for naming events.<br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6addd2af8f6f565002a1b4ea856b7bbcee">XMC_UART_CH_EVENT_RECEIVE_START</a>, <a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6a6e76badf4b36a6fa694cd7c4c0d873b9">XMC_UART_CH_EVENT_DATA_LOST</a>, <a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6af28054e5044087c68da450015df6771f">XMC_UART_CH_EVENT_TRANSMIT_SHIFT</a>, <a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6a26b35a7f887b79474fa97856749f182b">XMC_UART_CH_EVENT_TRANSMIT_BUFFER</a>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the interrupt events by clearing the bits in CCR register.<br />
<br />
Multiple events can be combined using the bitwise OR operation and configured in one function call. XMC_UART_CH_EVENT_FLAG_t enumerates multiple event bitmasks. These enumerations can be used as input to the API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga6840ff2cfd59836fea619b9c1cfbbac5">XMC_UART_CH_ClearStatusFlag()</a>, <a class="el" href="group___u_a_r_t.html#gaf511dd60e7f23bc40bad0207ff9bd266">XMC_UART_CH_EnableEvent()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gaef225ec3a0bc7db11ddf0b4f260a905c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef225ec3a0bc7db11ddf0b4f260a905c">&#9670;&nbsp;</a></span>XMC_UART_CH_DisableInputDigitalFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_DisableInputDigitalFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46a66212b93204c18de9680a5b45d41e327">XMC_UART_CH_INPUT_RXD1</a> (for DX3), <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46a1dbf3656536ec612da6a63ecd25e67d4">XMC_UART_CH_INPUT_RXD2</a> (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the digital filter for UART input stage.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gaeec73a4f59460bbe97aad10c1d925c73">XMC_UART_CH_EnableInputDigitalFilter()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gafd566960d84740ec0c0713197839b071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd566960d84740ec0c0713197839b071">&#9670;&nbsp;</a></span>XMC_UART_CH_DisableInputInversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_DisableInputInversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46a66212b93204c18de9680a5b45d41e327">XMC_UART_CH_INPUT_RXD1</a> (for DX3), <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46a1dbf3656536ec612da6a63ecd25e67d4">XMC_UART_CH_INPUT_RXD2</a> (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables input inversion for UART input data signal.<br />
<br />
Resets the input data polarity for the UART input data signal. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga95acf430dde4497f55838626ec22b808">XMC_UART_CH_EnableInputInversion()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga655549975b9c7dce3fb9f28c89b5685f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga655549975b9c7dce3fb9f28c89b5685f">&#9670;&nbsp;</a></span>XMC_UART_CH_DisableInputSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_DisableInputSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46a66212b93204c18de9680a5b45d41e327">XMC_UART_CH_INPUT_RXD1</a> (for DX3), <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46a1dbf3656536ec612da6a63ecd25e67d4">XMC_UART_CH_INPUT_RXD2</a> (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables synchronous input for the UART input stage.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga52aa3807f291f58be66b4d946aec7d47">XMC_UART_CH_EnableInputSync()</a>, <a class="el" href="group___u_a_r_t.html#gaeec73a4f59460bbe97aad10c1d925c73">XMC_UART_CH_EnableInputDigitalFilter()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga34495c14c7650599ba2e2ab348333cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34495c14c7650599ba2e2ab348333cf9">&#9670;&nbsp;</a></span>XMC_UART_CH_DisableMasterClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_DisableMasterClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables the generation of the master clock MCLK.<br />
<br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gaf9deda88e97525978786d4711aa75067">XMC_USIC_CH_SetMclkOutputPassiveLevel()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gac81a2e2617e9c6e9ddd314036185c08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac81a2e2617e9c6e9ddd314036185c08f">&#9670;&nbsp;</a></span>XMC_UART_CH_EnableDataTransmission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_EnableDataTransmission </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enable data transmission.<br />
<br />
Use this function in combination with <a class="el" href="group___u_a_r_t.html#ga935afb3b95df6c123883f44a1d63208f">XMC_UART_CH_DisableDataTransmission()</a> to fill the FIFO and send the FIFO content without gaps in the transmission. FIFO is filled using <a class="el" href="group___u_s_i_c.html#gae96e9afeaefe2585b687e36f6227727f">XMC_USIC_CH_TXFIFO_PutData()</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you need more control over the start of transmission use <a class="el" href="group___u_s_i_c.html#ga3b02352ba5e94e8f79751dea304084e0">XMC_USIC_CH_SetStartTransmisionMode()</a></dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga935afb3b95df6c123883f44a1d63208f">XMC_UART_CH_DisableDataTransmission()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gaf511dd60e7f23bc40bad0207ff9bd266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf511dd60e7f23bc40bad0207ff9bd266">&#9670;&nbsp;</a></span>XMC_UART_CH_EnableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_EnableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event bitmasks to enable. Use the type <a class="el" href="group___u_a_r_t.html#ga122d0cf7042ea6cb81ccdb50df5f62b6">XMC_UART_CH_EVENT_t</a> for naming events. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6addd2af8f6f565002a1b4ea856b7bbcee">XMC_UART_CH_EVENT_RECEIVE_START</a>, <a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6a6e76badf4b36a6fa694cd7c4c0d873b9">XMC_UART_CH_EVENT_DATA_LOST</a>, <a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6af28054e5044087c68da450015df6771f">XMC_UART_CH_EVENT_TRANSMIT_SHIFT</a>, <a class="el" href="group___u_a_r_t.html#gga122d0cf7042ea6cb81ccdb50df5f62b6a26b35a7f887b79474fa97856749f182b">XMC_UART_CH_EVENT_TRANSMIT_BUFFER</a>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables interrupt events for UART communication.<br />
<br />
Multiple events can be combined using the bitwise OR operation and configured in one function call. <a class="el" href="group___u_a_r_t.html#ga122d0cf7042ea6cb81ccdb50df5f62b6">XMC_UART_CH_EVENT_t</a> enumerates multiple event bitmasks. These enumerations can be used as input to the API. Events are configured by setting bits in the CCR register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga87743034df2fe747615ce39a6b870a0c">XMC_UART_CH_DisableEvent()</a>, <a class="el" href="group___u_a_r_t.html#gaa013e09337b1c9c05b41eac29b2518ea">XMC_UART_CH_SetInterruptNodePointer()</a>, <a class="el" href="group___u_a_r_t.html#ga5578bae41ea73c00dd704924c63f7370">XMC_UART_CH_GetStatusFlag()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gaeec73a4f59460bbe97aad10c1d925c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeec73a4f59460bbe97aad10c1d925c73">&#9670;&nbsp;</a></span>XMC_UART_CH_EnableInputDigitalFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_EnableInputDigitalFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46a66212b93204c18de9680a5b45d41e327">XMC_UART_CH_INPUT_RXD1</a> (for DX3), <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46a1dbf3656536ec612da6a63ecd25e67d4">XMC_UART_CH_INPUT_RXD2</a> (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the digital filter for UART input stage.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gaef225ec3a0bc7db11ddf0b4f260a905c">XMC_UART_CH_DisableInputDigitalFilter()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga95acf430dde4497f55838626ec22b808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95acf430dde4497f55838626ec22b808">&#9670;&nbsp;</a></span>XMC_UART_CH_EnableInputInversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_EnableInputInversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46a66212b93204c18de9680a5b45d41e327">XMC_UART_CH_INPUT_RXD1</a> (for DX3), <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46a1dbf3656536ec612da6a63ecd25e67d4">XMC_UART_CH_INPUT_RXD2</a> (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables input inversion for UART input data signal.<br />
<br />
Polarity of the input source can be changed to provide inverted data input. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gafd566960d84740ec0c0713197839b071">XMC_UART_CH_DisableInputInversion()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga52aa3807f291f58be66b4d946aec7d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52aa3807f291f58be66b4d946aec7d47">&#9670;&nbsp;</a></span>XMC_UART_CH_EnableInputSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_EnableInputSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46a66212b93204c18de9680a5b45d41e327">XMC_UART_CH_INPUT_RXD1</a> (for DX3), <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46a1dbf3656536ec612da6a63ecd25e67d4">XMC_UART_CH_INPUT_RXD2</a> (for DX5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables synchronous input for the UART input stage.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga655549975b9c7dce3fb9f28c89b5685f">XMC_UART_CH_DisableInputSync()</a>, <a class="el" href="group___u_a_r_t.html#gaeec73a4f59460bbe97aad10c1d925c73">XMC_UART_CH_EnableInputDigitalFilter()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga60eafedc1effa37f174e772a313c94fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60eafedc1effa37f174e772a313c94fa">&#9670;&nbsp;</a></span>XMC_UART_CH_EnableMasterClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_EnableMasterClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the generation of the master clock MCLK.<br />
<br />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_s_i_c.html#gaf9deda88e97525978786d4711aa75067">XMC_USIC_CH_SetMclkOutputPassiveLevel()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga578c15fc0df2e8ea7a265c92c0a26536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga578c15fc0df2e8ea7a265c92c0a26536">&#9670;&nbsp;</a></span>XMC_UART_CH_GetReceivedData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XMC_UART_CH_GetReceivedData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t Received data over UART communication channel. </dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides one word of data received over UART communication channel.<br />
<br />
Based on the channel configuration, data is either read from the receive FIFO or RBUF register. Before returning the value, there is no check for data validity. User should check the appropriate data receive flags(standard receive/alternative receive/FIFO standard receive/FIFO alternative receive) before executing the API. Reading from an empty receive FIFO can generate a receive error event.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga5578bae41ea73c00dd704924c63f7370">XMC_UART_CH_GetStatusFlag()</a>, <a class="el" href="group___u_a_r_t.html#ga3a9b41f5d74a0dde43d9b19166ffa7c6">XMC_UART_CH_Transmit()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga5578bae41ea73c00dd704924c63f7370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5578bae41ea73c00dd704924c63f7370">&#9670;&nbsp;</a></span>XMC_UART_CH_GetStatusFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_UART_CH_GetStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Status of UART channel events. <br />
 <b>Range:</b> Use <a class="el" href="group___u_a_r_t.html#ga802a057f335dc7bc1465ae11b19d09af">XMC_UART_CH_STATUS_FLAG_t</a> enumerations for event bitmasks. <a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa8838558f1c949dfdfa117908e21d7058">XMC_UART_CH_STATUS_FLAG_TRANSMISSION_IDLE</a>, <a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afa02d60fc761d9eee4c4d1c525f2429a5c">XMC_UART_CH_STATUS_FLAG_RECEPTION_IDLE</a>, <a class="el" href="group___u_a_r_t.html#gga802a057f335dc7bc1465ae11b19d09afaeaf9ee65696e36e06e012e0e3e5b5855">XMC_UART_CH_STATUS_FLAG_SYNCHRONIZATION_BREAK_DETECTED</a> etc.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the status of UART channel events.<br />
<br />
Status provided by the API represents the status of multiple events at their bit positions. The bitmasks can be obtained using the enumeration XMC_UART_CH_STATUS_FLAG_t. Event status is obtained by reading the register PSR_ASCMode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gaf511dd60e7f23bc40bad0207ff9bd266">XMC_UART_CH_EnableEvent()</a>, <a class="el" href="group___u_a_r_t.html#ga6840ff2cfd59836fea619b9c1cfbbac5">XMC_UART_CH_ClearStatusFlag()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga719ad21f9ccaf9585dd0b473b4daef7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga719ad21f9ccaf9585dd0b473b4daef7e">&#9670;&nbsp;</a></span>XMC_UART_CH_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___u_a_r_t___c_h___c_o_n_f_i_g__t.html">XMC_UART_CH_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, XMC_UART0_CH1,XMC_UART1_CH0, XMC_UART1_CH1,XMC_UART2_CH0, XMC_UART2_CH1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Constant pointer to UART configuration structure of type <a class="el" href="struct_x_m_c___u_a_r_t___c_h___c_o_n_f_i_g__t.html">XMC_UART_CH_CONFIG_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_UART_CH_STATUS_t Status of initializing the USIC channel for UART protocol.<br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ggadd220ce3211af8111e0af876a0619788a1d4d4ea36dc6c0ceb6599efed42f0559">XMC_UART_CH_STATUS_OK</a> if initialization is successful.<br />
 <a class="el" href="group___u_a_r_t.html#ggadd220ce3211af8111e0af876a0619788a146ec14a2e6f316f449c332a863289b0">XMC_UART_CH_STATUS_ERROR</a> if configuration of baudrate failed.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Initializes the USIC channel for UART protocol.<br />
<br />
During the initialization, USIC channel is enabled, baudrate is configured with the defined oversampling value in the intialization structure. If the oversampling value is set to 0 in the structure, the default oversampling of 16 is considered. Sampling point for each symbol is configured at the half of sampling period. Symbol value is decided by the majority decision among 3 samples. Word length is configured with the number of data bits. If the value of <em>frame_length</em> is 0, then USIC channel frame length is set to the same value as word length. If <em>frame_length</em> is greater than 0, it is set as the USIC channel frame length. Parity mode is set to the value configured for <em>parity_mode</em>. The USIC channel should be set to UART mode by calling the <a class="el" href="group___u_a_r_t.html#ga786385b5527c6c6405d7e9e3626e0587">XMC_UART_CH_Start()</a> API after the initialization.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga786385b5527c6c6405d7e9e3626e0587">XMC_UART_CH_Start()</a>, <a class="el" href="group___u_a_r_t.html#ga083e4d7b2be613994d61ebc9841f7ebd">XMC_UART_CH_Stop()</a>, <a class="el" href="group___u_a_r_t.html#ga3a9b41f5d74a0dde43d9b19166ffa7c6">XMC_UART_CH_Transmit()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gaca0ca9010bb1284a819b265694b7a5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca0ca9010bb1284a819b265694b7a5f0">&#9670;&nbsp;</a></span>XMC_UART_CH_InitEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_InitEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___u_a_r_t___c_h___c_o_n_f_i_g__t.html">XMC_UART_CH_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init_brg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, XMC_UART0_CH1,XMC_UART1_CH0, XMC_UART1_CH1,XMC_UART2_CH0, XMC_UART2_CH1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Constant pointer to UART configuration structure of type <a class="el" href="struct_x_m_c___u_a_r_t___c_h___c_o_n_f_i_g__t.html">XMC_UART_CH_CONFIG_t</a>. </td></tr>
    <tr><td class="paramname">init_brg</td><td>Selects if the baudrate generator should be configured automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_UART_CH_STATUS_t Status of initializing the USIC channel for UART protocol.<br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ggadd220ce3211af8111e0af876a0619788a1d4d4ea36dc6c0ceb6599efed42f0559">XMC_UART_CH_STATUS_OK</a> if initialization is successful.<br />
 <a class="el" href="group___u_a_r_t.html#ggadd220ce3211af8111e0af876a0619788a146ec14a2e6f316f449c332a863289b0">XMC_UART_CH_STATUS_ERROR</a> if configuration of baudrate failed.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Initializes the USIC channel for UART protocol.<br />
<br />
During the initialization, USIC channel is enabled, baudrate is configured with the defined oversampling value in the intialization structure. If the oversampling value is set to 0 in the structure, the default oversampling of 16 is considered. Sampling point for each symbol is configured at the half of sampling period. Symbol value is decided by the majority decision among 3 samples. Word length is configured with the number of data bits. If the value of <em>frame_length</em> is 0, then USIC channel frame length is set to the same value as word length. If <em>frame_length</em> is greater than 0, it is set as the USIC channel frame length. Parity mode is set to the value configured for <em>parity_mode</em>. The USIC channel should be set to UART mode by calling the <a class="el" href="group___u_a_r_t.html#ga786385b5527c6c6405d7e9e3626e0587">XMC_UART_CH_Start()</a> API after the initialization.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga786385b5527c6c6405d7e9e3626e0587">XMC_UART_CH_Start()</a>, <a class="el" href="group___u_a_r_t.html#ga083e4d7b2be613994d61ebc9841f7ebd">XMC_UART_CH_Stop()</a>, <a class="el" href="group___u_a_r_t.html#ga3a9b41f5d74a0dde43d9b19166ffa7c6">XMC_UART_CH_Transmit()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gadd72632ef25d7f44d8518141fde99a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd72632ef25d7f44d8518141fde99a2c">&#9670;&nbsp;</a></span>XMC_UART_CH_SelectInterruptNodePointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_SelectInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga29676690a77272438ef1cfc21575ff6d">XMC_UART_CH_INTERRUPT_NODE_POINTER_t</a>&#160;</td>
          <td class="paramname"><em>interrupt_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interrupt_node</td><td>Interrupt node pointer to be configured. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga29676690a77272438ef1cfc21575ff6da0069cc6489d3bf33490bf4cc95e998d4">XMC_UART_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT</a>, <a class="el" href="group___u_a_r_t.html#gga29676690a77272438ef1cfc21575ff6da59a31b003753d05ac1b5d5067751121e">XMC_UART_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER</a> etc. </td></tr>
    <tr><td class="paramname">service_request</td><td>Service request number.<br />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the interrupt node for USIC channel events. <br />
<br />
For an event to generate interrupt, node pointer should be configured with service request(SR0, SR1..SR5). The NVIC node gets linked to the interrupt event by doing so.<br />
 Note: NVIC node should be separately enabled to generate the interrupt.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gaf511dd60e7f23bc40bad0207ff9bd266">XMC_UART_CH_EnableEvent()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga0f757d62a86fc8944cf7188137490b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f757d62a86fc8944cf7188137490b62">&#9670;&nbsp;</a></span>XMC_UART_CH_SetBaudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t.html#gadd220ce3211af8111e0af876a0619788">XMC_UART_CH_STATUS_t</a> XMC_UART_CH_SetBaudrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>oversampling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, XMC_UART0_CH1 ,XMC_UART1_CH0, XMC_UART1_CH1, XMC_UART2_CH0, XMC_UART2_CH1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rate</td><td>Desired baudrate. <br />
 <b>Range:</b> minimum value = 100, maximum value depends on the peripheral clock frequency<br />
 and <em>oversampling</em>. Maximum baudrate can be derived using the formula: (fperiph * 1023)/(1024 * oversampling) </td></tr>
    <tr><td class="paramname">oversampling</td><td>Required oversampling. The value indicates the number of time quanta for one symbol of data.<br />
 This can be related to the number of samples for each logic state of the data signal.<br />
 <b>Range:</b> 4 to 32. Value should be chosen based on the protocol used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_UART_CH_STATUS_t Status indicating the baudrate configuration.<br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ggaf0ce1333656386f14f018b400beb9e39a7f5eeda6309c7b3a3e8f08380ed47e3c">XMC_USIC_CH_STATUS_OK</a> if baudrate is successfully configured, <a class="el" href="group___u_s_i_c.html#ggaf0ce1333656386f14f018b400beb9e39af9cf48d10eb977902d20eeaed491bcf0">XMC_USIC_CH_STATUS_ERROR</a> if desired baudrate or oversampling is invalid.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the bus speed in bits per second.<br />
<br />
Derives the values of <em>STEP</em> and PDIV to arrive at the optimum realistic speed possible. <em>oversampling</em> is the number of samples to be taken for each symbol of UART protocol. Default <em>oversampling</em> of 16 is considered if the input <em>oversampling</em> is less than 4. It is recommended to keep a minimum oversampling of 4 for UART.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga719ad21f9ccaf9585dd0b473b4daef7e">XMC_UART_CH_Init()</a>, <a class="el" href="group___u_a_r_t.html#ga083e4d7b2be613994d61ebc9841f7ebd">XMC_UART_CH_Stop()</a>, <a class="el" href="group___u_s_i_c.html#gae9092b12f490047882c1bb9897985c0e">XMC_USIC_CH_GetBaudrate()</a> </dd></dl>

</div>
</div>
<a id="ga516877b6a939a19eb1c7ec772b6535f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga516877b6a939a19eb1c7ec772b6535f1">&#9670;&nbsp;</a></span>XMC_UART_CH_SetBaudrateEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t.html#gadd220ce3211af8111e0af876a0619788">XMC_UART_CH_STATUS_t</a> XMC_UART_CH_SetBaudrateEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>oversampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normal_divider_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, XMC_UART0_CH1 ,XMC_UART1_CH0, XMC_UART1_CH1, XMC_UART2_CH0, XMC_UART2_CH1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rate</td><td>Desired baudrate. <br />
 <b>Range:</b> minimum value = 100, maximum value depends on the peripheral clock frequency<br />
 and <em>oversampling</em>. Maximum baudrate can be derived using the formula: (fperiph * 1023)/(1024 * oversampling) </td></tr>
    <tr><td class="paramname">oversampling</td><td>Required oversampling. The value indicates the number of time quanta for one symbol of data.<br />
 This can be related to the number of samples for each logic state of the data signal.<br />
 <b>Range:</b> 4 to 32. Value should be chosen based on the protocol used. </td></tr>
    <tr><td class="paramname">normal_divider_mode</td><td>Selects normal divider mode for baudrate generator instead of default fractional divider decreasing jitter of signal at the cost of frequency selection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_UART_CH_STATUS_t Status indicating the baudrate configuration.<br />
 <b>Range:</b> <a class="el" href="group___u_s_i_c.html#ggaf0ce1333656386f14f018b400beb9e39a7f5eeda6309c7b3a3e8f08380ed47e3c">XMC_USIC_CH_STATUS_OK</a> if baudrate is successfully configured, <a class="el" href="group___u_s_i_c.html#ggaf0ce1333656386f14f018b400beb9e39af9cf48d10eb977902d20eeaed491bcf0">XMC_USIC_CH_STATUS_ERROR</a> if desired baudrate or oversampling is invalid.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the bus speed in bits per second.<br />
<br />
Derives the values of <em>STEP</em> and PDIV to arrive at the optimum realistic speed possible. <em>oversampling</em> is the number of samples to be taken for each symbol of UART protocol. Default <em>oversampling</em> of 16 is considered if the input <em>oversampling</em> is less than 4. It is recommended to keep a minimum oversampling of 4 for UART.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga719ad21f9ccaf9585dd0b473b4daef7e">XMC_UART_CH_Init()</a>, <a class="el" href="group___u_a_r_t.html#ga083e4d7b2be613994d61ebc9841f7ebd">XMC_UART_CH_Stop()</a>, <a class="el" href="group___u_s_i_c.html#gae9092b12f490047882c1bb9897985c0e">XMC_USIC_CH_GetBaudrate()</a> </dd></dl>

</div>
</div>
<a id="ga9f6eb4a3265729b4b7cf7e3d198130d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f6eb4a3265729b4b7cf7e3d198130d6">&#9670;&nbsp;</a></span>XMC_UART_CH_SetFrameLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_SetFrameLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>frame_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame_length</td><td>Number of data bits in each UART frame. <br />
 <b>Range:</b> minimum= 1, maximum= 64. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the number of data bits for UART communication.<br />
<br />
The frame length is configured by setting the input value to <em>SCTR</em> register. The value of <em>frame_length</em> will be decremented by 1, before setting it to the register. Frame length should not be set to 64 for UART communication.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga6b12b3bdebda3d3a6c28d5c79a12735b">XMC_UART_CH_SetWordLength()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gad6c3cf150769886938ceb811557db243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6c3cf150769886938ceb811557db243">&#9670;&nbsp;</a></span>XMC_UART_CH_SetInputSamplingFreq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_SetInputSamplingFreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga2deb0d11792f241e1e5c02e6a4063998">XMC_UART_CH_INPUT_SAMPLING_FREQ_t</a>&#160;</td>
          <td class="paramname"><em>sampling_freq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46a66212b93204c18de9680a5b45d41e327">XMC_UART_CH_INPUT_RXD1</a> (for DX3), <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46a1dbf3656536ec612da6a63ecd25e67d4">XMC_UART_CH_INPUT_RXD2</a> (for DX5). </td></tr>
    <tr><td class="paramname">sampling_freq</td><td>Input sampling frequency. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga2deb0d11792f241e1e5c02e6a4063998a916e6151ac686996fbef2b0c059d0527">XMC_UART_CH_INPUT_SAMPLING_FREQ_FPERIPH</a>, <a class="el" href="group___u_a_r_t.html#gga2deb0d11792f241e1e5c02e6a4063998ac1ae8f6ca1096c61ca0619dae0a18b92">XMC_UART_CH_INPUT_SAMPLING_FREQ_FRACTIONAL_DIVIDER</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the sampling frequency for the UART input stage.<br />
<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga52aa3807f291f58be66b4d946aec7d47">XMC_UART_CH_EnableInputSync()</a>, <a class="el" href="group___u_a_r_t.html#gaeec73a4f59460bbe97aad10c1d925c73">XMC_UART_CH_EnableInputDigitalFilter()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga1f6aded563def78ca10e8638889bd898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f6aded563def78ca10e8638889bd898">&#9670;&nbsp;</a></span>XMC_UART_CH_SetInputSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_SetInputSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>UART channel input stage of type <a class="el" href="group___u_a_r_t.html#ga7358da2d90633473ae9de4636ddb3a46">XMC_UART_CH_INPUT_t</a>. <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46acaf414b76fa9b98df96b90edbf3edc3d">XMC_UART_CH_INPUT_RXD</a> (for DX0), <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46a66212b93204c18de9680a5b45d41e327">XMC_UART_CH_INPUT_RXD1</a> (for DX3), <a class="el" href="group___u_a_r_t.html#gga7358da2d90633473ae9de4636ddb3a46a1dbf3656536ec612da6a63ecd25e67d4">XMC_UART_CH_INPUT_RXD2</a> (for DX5). </td></tr>
    <tr><td class="paramname">source</td><td>Input source select for the input stage. The table provided below maps the decimal value with the input source. <table class="doxtable">
<tr>
<td>0</td><td>DXnA</td></tr>
<tr>
<td>1</td><td>DXnB</td></tr>
<tr>
<td>2</td><td>DXnC</td></tr>
<tr>
<td>3</td><td>DXnD </td></tr>
<tr>
<td>4</td><td>DXnE</td></tr>
<tr>
<td>5</td><td>DXnF</td></tr>
<tr>
<td>6</td><td>DXnG</td></tr>
<tr>
<td>7</td><td>Always 1 </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets input soource for the UART communication.<br />
<br />
It is used for configuring the input stage for data reception. Selects the input data signal source among DXnA, DXnB.. DXnG for the input stage. The API can be used for the input stages DX0, DX3 and DX5.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga95acf430dde4497f55838626ec22b808">XMC_UART_CH_EnableInputInversion()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gaa013e09337b1c9c05b41eac29b2518ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa013e09337b1c9c05b41eac29b2518ea">&#9670;&nbsp;</a></span>XMC_UART_CH_SetInterruptNodePointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_SetInterruptNodePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>service_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_request</td><td>Service request number for generating protocol interrupts.<br />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the interrupt node for UART channel protocol events.<br />
<br />
For all the protocol events enlisted in the enumeration XMC_UART_CH_EVENT_t, one common interrupt gets generated. The service request connects the interrupt node to the UART protocol events. Note: NVIC node should be separately enabled to generate the interrupt.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gaf511dd60e7f23bc40bad0207ff9bd266">XMC_UART_CH_EnableEvent()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga12f39dca3684261d4e35aeb7af9c82a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12f39dca3684261d4e35aeb7af9c82a9">&#9670;&nbsp;</a></span>XMC_UART_CH_SetPulseLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_SetPulseLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>pulse_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pulse_length</td><td>Length of the zero pulse in number of time quanta. <br />
 <b>Range:</b> 0 to 7. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the length of zero pulse in number of time quanta. Value 0 indicates one time quanta.<br />
<br />
Maximum possible is 8 time quanta with the value configured as 7.<br />
The value is set to PCR_ASCMode register. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga95acf430dde4497f55838626ec22b808">XMC_UART_CH_EnableInputInversion()</a>, <a class="el" href="group___u_a_r_t.html#gacabdceef217f1be937dc494ce9140765">XMC_UART_CH_SetSamplePoint()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gacabdceef217f1be937dc494ce9140765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacabdceef217f1be937dc494ce9140765">&#9670;&nbsp;</a></span>XMC_UART_CH_SetSamplePoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_SetSamplePoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sample_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample_point</td><td>Sample point among the number of samples. <br />
 <b>Range:</b> minimum= 0, maximum= <em>oversampling</em> (DCTQ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the sample point among the multiple samples for each UART symbol.<br />
<br />
The sample point is the one sample among number of samples set as oversampling. The value should be less than the oversampling value. <a class="el" href="group___u_a_r_t.html#ga719ad21f9ccaf9585dd0b473b4daef7e">XMC_UART_CH_Init()</a> sets the sample point to the sample at the centre. For example if the oversampling is 16, then the sample point is set to 9. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga95acf430dde4497f55838626ec22b808">XMC_UART_CH_EnableInputInversion()</a>, <a class="el" href="group___u_a_r_t.html#gacabdceef217f1be937dc494ce9140765">XMC_UART_CH_SetSamplePoint()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga6b12b3bdebda3d3a6c28d5c79a12735b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b12b3bdebda3d3a6c28d5c79a12735b">&#9670;&nbsp;</a></span>XMC_UART_CH_SetWordLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_SetWordLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>word_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word_length</td><td>Data word length. <br />
 <b>Range:</b> minimum= 1, maximum= 16. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the data word length in number of bits.<br />
<br />
Word length can range from 1 to 16. It indicates the number of data bits in a data word. The value of <em>word_length</em> will be decremented by 1 before setting the value to <em>SCTR</em> register. If the UART data bits is more than 16, then the frame length should be set to the actual number of bits and word length should be configured with the number of bits expected in each transaction. For example, if number of data bits for UART communication is 20 bits, then the frame length should be set as 20. Word length can be set based on the transmit and receive handling. If data is stored as 8bit array, then the word length can be set to 8. In this case, a full message of UART data should be transmitted/ received as 3 data words.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga9f6eb4a3265729b4b7cf7e3d198130d6">XMC_UART_CH_SetFrameLength()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga786385b5527c6c6405d7e9e3626e0587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga786385b5527c6c6405d7e9e3626e0587">&#9670;&nbsp;</a></span>XMC_UART_CH_Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Sets the USIC channel operation mode to UART mode.<br />
<br />
CCR register bitfield <em>Mode</em> is set to 2(UART mode). This API should be called after configuring the USIC channel. Transmission and reception can happen only when the UART mode is set. This is an inline function.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga083e4d7b2be613994d61ebc9841f7ebd">XMC_UART_CH_Stop()</a>, <a class="el" href="group___u_a_r_t.html#ga3a9b41f5d74a0dde43d9b19166ffa7c6">XMC_UART_CH_Transmit()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga083e4d7b2be613994d61ebc9841f7ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga083e4d7b2be613994d61ebc9841f7ebd">&#9670;&nbsp;</a></span>XMC_UART_CH_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t.html#gadd220ce3211af8111e0af876a0619788">XMC_UART_CH_STATUS_t</a> XMC_UART_CH_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_UART_CH_STATUS_t Status to indicate if the communication channel is stopped successfully.<br />
 <a class="el" href="group___u_a_r_t.html#ggadd220ce3211af8111e0af876a0619788a1d4d4ea36dc6c0ceb6599efed42f0559">XMC_UART_CH_STATUS_OK</a> if the communication channel is stopped. <a class="el" href="group___u_a_r_t.html#ggadd220ce3211af8111e0af876a0619788a410817c31e098fd03c04f4d5ecb76ef1">XMC_UART_CH_STATUS_BUSY</a> if the communication channel is busy.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Stops the UART communication.<br />
<br />
CCR register bitfield <em>Mode</em> is reset. This disables the communication. Before starting the communication again, the channel has to be reconfigured.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga719ad21f9ccaf9585dd0b473b4daef7e">XMC_UART_CH_Init()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga3a9b41f5d74a0dde43d9b19166ffa7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a9b41f5d74a0dde43d9b19166ffa7c6">&#9670;&nbsp;</a></span>XMC_UART_CH_Transmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_Transmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Constant pointer to USIC channel handle of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Data to be transmitted. <br />
 <b>Range:</b> 16 bit unsigned data within the range 0 to 65535. Actual size of data transmitted depends on the configured number of bits for the UART protocol in the register SCTR. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Transmits data over serial communication channel using UART protocol.<br />
<br />
Based on the channel configuration, data is either put to the transmit FIFO or to TBUF register. Before putting data to TBUF, the API waits for TBUF to finish shifting its contents to shift register. So user can continuously execute the API without checking for TBUF busy status. Based on the number of data bits configured, the lower significant bits will be extracted for transmission.</dd></dl>
<p>Note: When FIFO is not configured, the API waits for the TBUF to be available. This makes the execution a blocking call.</p>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#ga578c15fc0df2e8ea7a265c92c0a26536">XMC_UART_CH_GetReceivedData()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga3a3d22e4821ed95b364793b3a7e711c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a3d22e4821ed95b364793b3a7e711c0">&#9670;&nbsp;</a></span>XMC_UART_CH_TriggerServiceRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_UART_CH_TriggerServiceRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> *const&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>service_request_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Pointer to USIC channel handler of type <a class="el" href="struct_x_m_c___u_s_i_c___c_h__t.html">XMC_USIC_CH_t</a> <br />
 <b>Range:</b> <a class="el" href="group___u_a_r_t.html#ga3dc31990cf98c3e7cf5743793187bd01">XMC_UART0_CH0</a>, <a class="el" href="group___u_a_r_t.html#gaa04c64ad7fa9ae5db3dd9b8b7999ef49">XMC_UART0_CH1</a>,<a class="el" href="group___u_a_r_t.html#gad784f4e853952a3d0be9f260a0f1c3c6">XMC_UART1_CH0</a>,<a class="el" href="group___u_a_r_t.html#ga8a09c318f27492e33d0d3e341ae0703e">XMC_UART1_CH1</a>,<a class="el" href="group___u_a_r_t.html#gaeb94319572f1e75648bcf89a98da324a">XMC_UART2_CH0</a>,<a class="el" href="group___u_a_r_t.html#gaa231ac5218c378cfa8801ae63ca8ee79">XMC_UART2_CH1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Availability of UART1 and UART2 depends on device selection </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">service_request_line</td><td>service request number of the event to be triggered. <br />
 <b>Range:</b> 0 to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Trigger a UART interrupt service request.<br />
<br />
When the UART service request is triggered, the NVIC interrupt associated with it will be generated if enabled.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___u_a_r_t.html#gadd72632ef25d7f44d8518141fde99a2c">XMC_UART_CH_SelectInterruptNodePointer()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>XMC Peripheral Library for XMC4000 Family</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
