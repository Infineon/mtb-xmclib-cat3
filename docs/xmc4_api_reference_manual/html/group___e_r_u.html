<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XMC Peripheral Library for XMC4000 Family: Event Request Unit (ERU)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC4000 Family</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___e_r_u.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Event Request Unit (ERU)</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___e_r_u___e_t_l___c_o_n_f_i_g__t.html">XMC_ERU_ETL_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_x_m_c___e_r_u___o_g_u___c_o_n_f_i_g__t.html">XMC_ERU_OGU_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga853b59a72ff0b97692d690697f1c9553"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#ga853b59a72ff0b97692d690697f1c9553">XMC_ERU_ETL_EDGE_DETECTION_t</a> </td></tr>
<tr class="separator:ga853b59a72ff0b97692d690697f1c9553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga308f21ee6d582ff8551092860b3f5ba4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#ga308f21ee6d582ff8551092860b3f5ba4">XMC_ERU_ETL_INPUT_A_t</a> </td></tr>
<tr class="separator:ga308f21ee6d582ff8551092860b3f5ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3fd5e4f15fa5da8177b31e28421bf42"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#gac3fd5e4f15fa5da8177b31e28421bf42">XMC_ERU_ETL_INPUT_B_t</a> </td></tr>
<tr class="separator:gac3fd5e4f15fa5da8177b31e28421bf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15d2fb3d1c965b350e28bcfae34eae87"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#ga15d2fb3d1c965b350e28bcfae34eae87">XMC_ERU_ETL_OUTPUT_TRIGGER_CHANNEL_t</a> </td></tr>
<tr class="separator:ga15d2fb3d1c965b350e28bcfae34eae87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fff35391900fcd87c7497daee0d0739"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#ga5fff35391900fcd87c7497daee0d0739">XMC_ERU_ETL_OUTPUT_TRIGGER_t</a> </td></tr>
<tr class="separator:ga5fff35391900fcd87c7497daee0d0739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace2abdc83ae2a12af12ca448bc5faa1c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#gace2abdc83ae2a12af12ca448bc5faa1c">XMC_ERU_ETL_SOURCE_t</a> </td></tr>
<tr class="separator:gace2abdc83ae2a12af12ca448bc5faa1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ea4e2b56bf3f57b0b59e0158f53d42c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#ga5ea4e2b56bf3f57b0b59e0158f53d42c">XMC_ERU_ETL_STATUS_FLAG_MODE_t</a> </td></tr>
<tr class="separator:ga5ea4e2b56bf3f57b0b59e0158f53d42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe843daae3d38c529ffd50b148d61628"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#gafe843daae3d38c529ffd50b148d61628">XMC_ERU_OGU_PATTERN_DETECTION_INPUT_t</a> </td></tr>
<tr class="separator:gafe843daae3d38c529ffd50b148d61628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf46891d9f1772a8f9cfb385c0afd3ce2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#gaf46891d9f1772a8f9cfb385c0afd3ce2">XMC_ERU_OGU_PATTERN_DETECTION_t</a> </td></tr>
<tr class="separator:gaf46891d9f1772a8f9cfb385c0afd3ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2ee1dc0cb1c6218868da04976b6819a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#gab2ee1dc0cb1c6218868da04976b6819a">XMC_ERU_OGU_PERIPHERAL_TRIGGER_t</a> </td></tr>
<tr class="separator:gab2ee1dc0cb1c6218868da04976b6819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae4af18f2e9af9ae235a3d69b4007c0e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#gaae4af18f2e9af9ae235a3d69b4007c0e">XMC_ERU_OGU_SERVICE_REQUEST_t</a> </td></tr>
<tr class="separator:gaae4af18f2e9af9ae235a3d69b4007c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga91a95048baad39ad478b0af050e797dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#ga91a95048baad39ad478b0af050e797dd">XMC_ERU_Disable</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru)</td></tr>
<tr class="separator:ga91a95048baad39ad478b0af050e797dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa023eb9a0615ae0322706f53577f000e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#gaa023eb9a0615ae0322706f53577f000e">XMC_ERU_Enable</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru)</td></tr>
<tr class="separator:gaa023eb9a0615ae0322706f53577f000e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e95f6b12bef69e7e6d1815048a34ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#gab3e95f6b12bef69e7e6d1815048a34ff">XMC_ERU_ETL_ClearStatusFlag</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel)</td></tr>
<tr class="separator:gab3e95f6b12bef69e7e6d1815048a34ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba049d5d9c2647fc0a99068609650c00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#gaba049d5d9c2647fc0a99068609650c00">XMC_ERU_ETL_DisableOutputTrigger</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel)</td></tr>
<tr class="separator:gaba049d5d9c2647fc0a99068609650c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6335e7c97f4834704eb27876741310d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#ga6335e7c97f4834704eb27876741310d7">XMC_ERU_ETL_EnableOutputTrigger</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel, const <a class="el" href="group___e_r_u.html#ga15d2fb3d1c965b350e28bcfae34eae87">XMC_ERU_ETL_OUTPUT_TRIGGER_CHANNEL_t</a> trigger)</td></tr>
<tr class="separator:ga6335e7c97f4834704eb27876741310d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4690514e452e671401660e0962592c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___e_r_u.html#ga853b59a72ff0b97692d690697f1c9553">XMC_ERU_ETL_EDGE_DETECTION_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#gaa4690514e452e671401660e0962592c4">XMC_ERU_ETL_GetEdgeDetection</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel)</td></tr>
<tr class="separator:gaa4690514e452e671401660e0962592c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83d258683013290648d57f18916e032c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#ga83d258683013290648d57f18916e032c">XMC_ERU_ETL_GetStatusFlag</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel)</td></tr>
<tr class="separator:ga83d258683013290648d57f18916e032c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ada9e9c756616d815c573168c841bd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#ga0ada9e9c756616d815c573168c841bd4">XMC_ERU_ETL_Init</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel, const <a class="el" href="struct_x_m_c___e_r_u___e_t_l___c_o_n_f_i_g__t.html">XMC_ERU_ETL_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga0ada9e9c756616d815c573168c841bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95937af5ccdea42b8a96a9e8aa3215dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#ga95937af5ccdea42b8a96a9e8aa3215dc">XMC_ERU_ETL_SetEdgeDetection</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel, const <a class="el" href="group___e_r_u.html#ga853b59a72ff0b97692d690697f1c9553">XMC_ERU_ETL_EDGE_DETECTION_t</a> edge_detection)</td></tr>
<tr class="separator:ga95937af5ccdea42b8a96a9e8aa3215dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4633b3a3c840ddab285503720b1e282e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#ga4633b3a3c840ddab285503720b1e282e">XMC_ERU_ETL_SetInput</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel, const <a class="el" href="group___e_r_u.html#ga308f21ee6d582ff8551092860b3f5ba4">XMC_ERU_ETL_INPUT_A_t</a> input_a, const <a class="el" href="group___e_r_u.html#gac3fd5e4f15fa5da8177b31e28421bf42">XMC_ERU_ETL_INPUT_B_t</a> input_b)</td></tr>
<tr class="separator:ga4633b3a3c840ddab285503720b1e282e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad32a6e519fa852eba1895ad9b2cb0448"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#gad32a6e519fa852eba1895ad9b2cb0448">XMC_ERU_ETL_SetSource</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel, const <a class="el" href="group___e_r_u.html#gace2abdc83ae2a12af12ca448bc5faa1c">XMC_ERU_ETL_SOURCE_t</a> source)</td></tr>
<tr class="separator:gad32a6e519fa852eba1895ad9b2cb0448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf81afcd379c5d8dd9b91847a7266d20a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#gaf81afcd379c5d8dd9b91847a7266d20a">XMC_ERU_ETL_SetStatusFlag</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel)</td></tr>
<tr class="separator:gaf81afcd379c5d8dd9b91847a7266d20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0f5c34432dc1067976409af3af971ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#gae0f5c34432dc1067976409af3af971ed">XMC_ERU_ETL_SetStatusFlagMode</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel, const <a class="el" href="group___e_r_u.html#ga5ea4e2b56bf3f57b0b59e0158f53d42c">XMC_ERU_ETL_STATUS_FLAG_MODE_t</a> mode)</td></tr>
<tr class="separator:gae0f5c34432dc1067976409af3af971ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff77065724a9ad6c1f7da14fbf31af9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#gaeff77065724a9ad6c1f7da14fbf31af9">XMC_ERU_OGU_DisablePatternDetection</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel)</td></tr>
<tr class="separator:gaeff77065724a9ad6c1f7da14fbf31af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66ee1efaa21c1b581756765f6a991a66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#ga66ee1efaa21c1b581756765f6a991a66">XMC_ERU_OGU_DisablePeripheralTrigger</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel)</td></tr>
<tr class="separator:ga66ee1efaa21c1b581756765f6a991a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8575bda905514eb0dbf318c55ef7d96d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#ga8575bda905514eb0dbf318c55ef7d96d">XMC_ERU_OGU_EnablePatternDetection</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel, const <a class="el" href="group___e_r_u.html#gafe843daae3d38c529ffd50b148d61628">XMC_ERU_OGU_PATTERN_DETECTION_INPUT_t</a> input)</td></tr>
<tr class="separator:ga8575bda905514eb0dbf318c55ef7d96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafca497a2865ef65cba5a604483954bca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#gafca497a2865ef65cba5a604483954bca">XMC_ERU_OGU_EnablePeripheralTrigger</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel, const <a class="el" href="group___e_r_u.html#gab2ee1dc0cb1c6218868da04976b6819a">XMC_ERU_OGU_PERIPHERAL_TRIGGER_t</a> peripheral_trigger)</td></tr>
<tr class="separator:gafca497a2865ef65cba5a604483954bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga134cd43e144a5142b668ac2bc85fa984"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#ga134cd43e144a5142b668ac2bc85fa984">XMC_ERU_OGU_GetPatternDetectionStatus</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel)</td></tr>
<tr class="separator:ga134cd43e144a5142b668ac2bc85fa984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f73655169649c7b0599688d390645a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#ga8f73655169649c7b0599688d390645a0">XMC_ERU_OGU_Init</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel, const <a class="el" href="union_x_m_c___e_r_u___o_g_u___c_o_n_f_i_g__t.html">XMC_ERU_OGU_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga8f73655169649c7b0599688d390645a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dc8b8a92b00cbcb2ed80fa5201a5ce0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_r_u.html#ga5dc8b8a92b00cbcb2ed80fa5201a5ce0">XMC_ERU_OGU_SetServiceRequestMode</a> (<a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const eru, const uint8_t channel, const <a class="el" href="group___e_r_u.html#gaae4af18f2e9af9ae235a3d69b4007c0e">XMC_ERU_OGU_SERVICE_REQUEST_t</a> mode)</td></tr>
<tr class="separator:ga5dc8b8a92b00cbcb2ed80fa5201a5ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="anchor" id="brief_pdlapi_eru"></a> The Event Request Unit (ERU) is a versatile multiple input event detection and processing unit. The ERU module can be used to expand the P-to-P connections of the device: ports-to-peripherals, peripherals-to-peripherals and ports-to-ports. It also offers configurable logic, that allows the generation of triggers, pattern detection and real-time signal monitoring.</p>
<div class="image">
<img src="eru_overview.png" alt="eru_overview.png"/>
</div>
<p>The driver is divided into two sections: </p><dl class="section user"><dt>Event trigger logic (ERU_ETL):</dt><dd>This section of the LLD provides the configuration structure <a class="el" href="struct_x_m_c___e_r_u___e_t_l___c_o_n_f_i_g__t.html">XMC_ERU_ETL_CONFIG_t</a> and the initialization function <a class="el" href="group___e_r_u.html#ga0ada9e9c756616d815c573168c841bd4">XMC_ERU_ETL_Init()</a>.<br />
It can be used to:<ol type="1">
<li>Select one out of two inputs (A and B). For each of these two inputs, a vector of 4 possible signals is available. (<a class="el" href="group___e_r_u.html#gad32a6e519fa852eba1895ad9b2cb0448">XMC_ERU_ETL_SetSource()</a>)</li>
<li>Logically combine the two input signals to a common trigger. (<a class="el" href="group___e_r_u.html#gad32a6e519fa852eba1895ad9b2cb0448">XMC_ERU_ETL_SetSource()</a>)</li>
<li>Define the transition (edge selection, or by software) that leads to a trigger event and can also store this status. (<a class="el" href="group___e_r_u.html#ga95937af5ccdea42b8a96a9e8aa3215dc">XMC_ERU_ETL_SetEdgeDetection()</a> and <a class="el" href="group___e_r_u.html#gaf81afcd379c5d8dd9b91847a7266d20a">XMC_ERU_ETL_SetStatusFlag()</a>)</li>
<li>Distribute the events and status flags to the output channels. (<a class="el" href="group___e_r_u.html#ga6335e7c97f4834704eb27876741310d7">XMC_ERU_ETL_EnableOutputTrigger()</a>)</li>
</ol>
</dd></dl>
<dl class="section user"><dt>Output gating unit (ERU_OGU):</dt><dd>This section of the LLD provides the provides the configuration structure <a class="el" href="union_x_m_c___e_r_u___o_g_u___c_o_n_f_i_g__t.html">XMC_ERU_OGU_CONFIG_t</a> and the initialization function XMC_ERU_ETL_OGU_Init(). It can be used to:<ol type="1">
<li>Combine the trigger events and status information and gates the output depending on a gating signal. (<a class="el" href="group___e_r_u.html#ga8575bda905514eb0dbf318c55ef7d96d">XMC_ERU_OGU_EnablePatternDetection()</a>, <a class="el" href="group___e_r_u.html#ga66ee1efaa21c1b581756765f6a991a66">XMC_ERU_OGU_DisablePeripheralTrigger()</a>, <a class="el" href="group___e_r_u.html#ga5dc8b8a92b00cbcb2ed80fa5201a5ce0">XMC_ERU_OGU_SetServiceRequestMode()</a>) </li>
</ol>
</dd></dl>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga853b59a72ff0b97692d690697f1c9553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga853b59a72ff0b97692d690697f1c9553">&#9670;&nbsp;</a></span>XMC_ERU_ETL_EDGE_DETECTION_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___e_r_u.html#ga853b59a72ff0b97692d690697f1c9553">XMC_ERU_ETL_EDGE_DETECTION_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines trigger edge for the event generation by ETLx (Event Trigger Logic, x = [0 to 3]) unit, by getting the signal from ERSx(Event request source, x = [0 to 3]) unit. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga853b59a72ff0b97692d690697f1c9553a645885fd795a881dd721972fbf3cf98a"></a>XMC_ERU_ETL_EDGE_DETECTION_DISABLED&#160;</td><td class="fielddoc"><p>no event enabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga853b59a72ff0b97692d690697f1c9553aa985133b3949739b02349d5e17ce7cab"></a>XMC_ERU_ETL_EDGE_DETECTION_RISING&#160;</td><td class="fielddoc"><p>detection of rising edge generates the event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga853b59a72ff0b97692d690697f1c9553a2f7606c58021c54783e2a4e8ca6f5d9a"></a>XMC_ERU_ETL_EDGE_DETECTION_FALLING&#160;</td><td class="fielddoc"><p>detection of falling edge generates the event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga853b59a72ff0b97692d690697f1c9553ad17cba429516f4a2b6da8f1c30e159f4"></a>XMC_ERU_ETL_EDGE_DETECTION_BOTH&#160;</td><td class="fielddoc"><p>detection of either edges generates the event </p>
</td></tr>
</table>

</div>
</div>
<a id="ga308f21ee6d582ff8551092860b3f5ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga308f21ee6d582ff8551092860b3f5ba4">&#9670;&nbsp;</a></span>XMC_ERU_ETL_INPUT_A_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___e_r_u.html#ga308f21ee6d582ff8551092860b3f5ba4">XMC_ERU_ETL_INPUT_A_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines input signal for path A of ERSx(Event request source, x = [0 to 3]) unit. </p><div class="image">
<img src="eru_input_a.png" alt="eru_input_a.png"/>
<div class="caption">
ETLx Input A selection</div></div>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga308f21ee6d582ff8551092860b3f5ba4a2a48a6504d6dfbe37fa302e387f63049"></a>XMC_ERU_ETL_INPUT_A0&#160;</td><td class="fielddoc"><p>input A0 is selected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga308f21ee6d582ff8551092860b3f5ba4a8c23ef4f4bfc8d119c75a47b0cbcbc2b"></a>XMC_ERU_ETL_INPUT_A1&#160;</td><td class="fielddoc"><p>input A1 is selected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga308f21ee6d582ff8551092860b3f5ba4a212ea13b2e200b2f320747ce42128efb"></a>XMC_ERU_ETL_INPUT_A2&#160;</td><td class="fielddoc"><p>input A2 is selected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga308f21ee6d582ff8551092860b3f5ba4a0dbffba00730a26e60ce9fcad3b1290a"></a>XMC_ERU_ETL_INPUT_A3&#160;</td><td class="fielddoc"><p>input A3 is selected </p>
</td></tr>
</table>

</div>
</div>
<a id="gac3fd5e4f15fa5da8177b31e28421bf42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3fd5e4f15fa5da8177b31e28421bf42">&#9670;&nbsp;</a></span>XMC_ERU_ETL_INPUT_B_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___e_r_u.html#gac3fd5e4f15fa5da8177b31e28421bf42">XMC_ERU_ETL_INPUT_B_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines input signal for path B of ERSx(Event request source, x = [0 to 3]) unit. </p><div class="image">
<img src="eru_input_b.png" alt="eru_input_b.png"/>
<div class="caption">
ETLx Input B selection</div></div>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac3fd5e4f15fa5da8177b31e28421bf42a32207ebe3bf72fadb9d1b8a5283de3e0"></a>XMC_ERU_ETL_INPUT_B0&#160;</td><td class="fielddoc"><p>input B0 is selected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac3fd5e4f15fa5da8177b31e28421bf42a1d906d6bf951b0ffe585987a37537d58"></a>XMC_ERU_ETL_INPUT_B1&#160;</td><td class="fielddoc"><p>input B1 is selected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac3fd5e4f15fa5da8177b31e28421bf42a941e3e2c1344950a985263641d098716"></a>XMC_ERU_ETL_INPUT_B2&#160;</td><td class="fielddoc"><p>input B2 is selected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac3fd5e4f15fa5da8177b31e28421bf42a321fdea9c9cf9633eb2154016581ae2a"></a>XMC_ERU_ETL_INPUT_B3&#160;</td><td class="fielddoc"><p>input B3 is selected </p>
</td></tr>
</table>

</div>
</div>
<a id="ga15d2fb3d1c965b350e28bcfae34eae87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15d2fb3d1c965b350e28bcfae34eae87">&#9670;&nbsp;</a></span>XMC_ERU_ETL_OUTPUT_TRIGGER_CHANNEL_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___e_r_u.html#ga15d2fb3d1c965b350e28bcfae34eae87">XMC_ERU_ETL_OUTPUT_TRIGGER_CHANNEL_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines Output Channel of OGUy(Output gating unit y = [0 to 3]) to be mapped by the trigger pulse generated by ETLx(Event Trigger Logic, x = [0 to 3]) unit. </p><dl class="section note"><dt>Note</dt><dd>Generation of output trigger pulse need to be enabled <a class="el" href="group___e_r_u.html#gab2ee1dc0cb1c6218868da04976b6819a">XMC_ERU_OGU_PERIPHERAL_TRIGGER_t</a> <div class="image">
<img src="eru_connection_matrix.png" alt="eru_connection_matrix.png"/>
<div class="caption">
ERU_ETL ERU_OGU Connection matrix</div></div>
</dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga15d2fb3d1c965b350e28bcfae34eae87a2b1ecb8037ab4c79389648c031cb4be3"></a>XMC_ERU_ETL_OUTPUT_TRIGGER_CHANNEL0&#160;</td><td class="fielddoc"><p>Event from input ETLx triggers output OGU0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15d2fb3d1c965b350e28bcfae34eae87addedc2d56ede0d207343f5f7b24ac537"></a>XMC_ERU_ETL_OUTPUT_TRIGGER_CHANNEL1&#160;</td><td class="fielddoc"><p>Event from input ETLx triggers output OGU1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15d2fb3d1c965b350e28bcfae34eae87aab49c9492b3b41265fc179e5be905fb1"></a>XMC_ERU_ETL_OUTPUT_TRIGGER_CHANNEL2&#160;</td><td class="fielddoc"><p>Event from input ETLx triggers output OGU2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15d2fb3d1c965b350e28bcfae34eae87ab0120f8b0d97ff7bdb8e35b6dae3c07c"></a>XMC_ERU_ETL_OUTPUT_TRIGGER_CHANNEL3&#160;</td><td class="fielddoc"><p>Event from input ETLx triggers output OGU3 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga5fff35391900fcd87c7497daee0d0739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fff35391900fcd87c7497daee0d0739">&#9670;&nbsp;</a></span>XMC_ERU_ETL_OUTPUT_TRIGGER_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___e_r_u.html#ga5fff35391900fcd87c7497daee0d0739">XMC_ERU_ETL_OUTPUT_TRIGGER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines generation of the trigger pulse by ETLx(Event Trigger Logic, x = [0 to 3]) unit. Use type XMC_ERU_ETL_OUTPUT_TRIGGER_t for this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5fff35391900fcd87c7497daee0d0739ad73b61f8848d24944749ff1057616172"></a>XMC_ERU_ETL_OUTPUT_TRIGGER_DISABLED&#160;</td><td class="fielddoc"><p>trigger pulse generation disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5fff35391900fcd87c7497daee0d0739a39ad1bcd93f3adcba320301cec2e399e"></a>XMC_ERU_ETL_OUTPUT_TRIGGER_ENABLED&#160;</td><td class="fielddoc"><p>trigger pulse generation enabled </p>
</td></tr>
</table>

</div>
</div>
<a id="gace2abdc83ae2a12af12ca448bc5faa1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace2abdc83ae2a12af12ca448bc5faa1c">&#9670;&nbsp;</a></span>XMC_ERU_ETL_SOURCE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___e_r_u.html#gace2abdc83ae2a12af12ca448bc5faa1c">XMC_ERU_ETL_SOURCE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines input path combination along with polarity for event generation by ERSx(Event request source) unit to ETLx(Event trigger logic),x = [0 to 3] unit. </p><div class="image">
<img src="eru_input_trigger.png" alt="eru_input_trigger.png"/>
<div class="caption">
ETLx input trigger signal generation</div></div>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggace2abdc83ae2a12af12ca448bc5faa1caeab420c3f80513096bf42848412814d6"></a>XMC_ERU_ETL_SOURCE_A&#160;</td><td class="fielddoc"><p>select (A) path as a event source </p>
</td></tr>
<tr><td class="fieldname"><a id="ggace2abdc83ae2a12af12ca448bc5faa1ca8f65af3ff5e5de3be3bad263c817d296"></a>XMC_ERU_ETL_SOURCE_B&#160;</td><td class="fielddoc"><p>select (B) path as a event source </p>
</td></tr>
<tr><td class="fieldname"><a id="ggace2abdc83ae2a12af12ca448bc5faa1cafd2c864567fd1740bd9065d1ce243e23"></a>XMC_ERU_ETL_SOURCE_A_OR_B&#160;</td><td class="fielddoc"><p>select (A <b>OR</b> B) path as a event source </p>
</td></tr>
<tr><td class="fieldname"><a id="ggace2abdc83ae2a12af12ca448bc5faa1cab7d2cd9aa27d4eaee8ba5ff94778602f"></a>XMC_ERU_ETL_SOURCE_A_AND_B&#160;</td><td class="fielddoc"><p>select (A <b>AND</b> B) path as a event source </p>
</td></tr>
<tr><td class="fieldname"><a id="ggace2abdc83ae2a12af12ca448bc5faa1ca1af919c8a85b5d2983541b1b425a7bbc"></a>XMC_ERU_ETL_SOURCE_NOT_A&#160;</td><td class="fielddoc"><p>select (inverted A) path as a event source </p>
</td></tr>
<tr><td class="fieldname"><a id="ggace2abdc83ae2a12af12ca448bc5faa1ca7e36d354d8b6466855747aeb9d003d28"></a>XMC_ERU_ETL_SOURCE_NOT_A_OR_B&#160;</td><td class="fielddoc"><p>select (inverted A <b>OR</b> B) path as a event source </p>
</td></tr>
<tr><td class="fieldname"><a id="ggace2abdc83ae2a12af12ca448bc5faa1caaf542d2e81deedf4d32546d728f1fee5"></a>XMC_ERU_ETL_SOURCE_NOT_A_AND_B&#160;</td><td class="fielddoc"><p>select (inverted A <b>AND</b> B) path as a event source </p>
</td></tr>
<tr><td class="fieldname"><a id="ggace2abdc83ae2a12af12ca448bc5faa1caf697d191ffa2fd991a0d7468ef798f14"></a>XMC_ERU_ETL_SOURCE_NOT_B&#160;</td><td class="fielddoc"><p>select (inverted B) path as a event source </p>
</td></tr>
<tr><td class="fieldname"><a id="ggace2abdc83ae2a12af12ca448bc5faa1ca967f6679770a1240d9220bba5a0fa393"></a>XMC_ERU_ETL_SOURCE_A_OR_NOT_B&#160;</td><td class="fielddoc"><p>select (A <b>OR</b> inverted B) path as a event source </p>
</td></tr>
<tr><td class="fieldname"><a id="ggace2abdc83ae2a12af12ca448bc5faa1cae5170991e6ea496a066941a591a736f6"></a>XMC_ERU_ETL_SOURCE_A_AND_NOT_B&#160;</td><td class="fielddoc"><p>select (A <b>AND</b> inverted B) path as a event source </p>
</td></tr>
<tr><td class="fieldname"><a id="ggace2abdc83ae2a12af12ca448bc5faa1ca35bb0af7037716205e823f52f5fb3bd1"></a>XMC_ERU_ETL_SOURCE_NOT_A_OR_NOT_B&#160;</td><td class="fielddoc"><p>select (inverted A <b>OR</b> inverted B) path as a event source </p>
</td></tr>
<tr><td class="fieldname"><a id="ggace2abdc83ae2a12af12ca448bc5faa1ca977784360e18610c2db0206892403ebf"></a>XMC_ERU_ETL_SOURCE_NOT_A_AND_NOT_B&#160;</td><td class="fielddoc"><p>select (inverted A <b>AND</b> inverted B) path as a event source </p>
</td></tr>
</table>

</div>
</div>
<a id="ga5ea4e2b56bf3f57b0b59e0158f53d42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ea4e2b56bf3f57b0b59e0158f53d42c">&#9670;&nbsp;</a></span>XMC_ERU_ETL_STATUS_FLAG_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___e_r_u.html#ga5ea4e2b56bf3f57b0b59e0158f53d42c">XMC_ERU_ETL_STATUS_FLAG_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines status flag reset mode generated by ETLx(Event Trigger Logic, x = [0 to 3]) unit. Use type XMC_ERU_ETL_STATUS_FLAG_MODE_t for this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5ea4e2b56bf3f57b0b59e0158f53d42ca5965d4240ed8250ebda43a1883778367"></a>XMC_ERU_ETL_STATUS_FLAG_MODE_SWCTRL&#160;</td><td class="fielddoc"><p>Status flag is in sticky mode. Retain the same state until cleared by software. In case of pattern match this mode is used. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5ea4e2b56bf3f57b0b59e0158f53d42cac365114ab18a4ca6fc9eec6b581c6ca9"></a>XMC_ERU_ETL_STATUS_FLAG_MODE_HWCTRL&#160;</td><td class="fielddoc"><p>Status flag is in non-sticky mode. Automatically cleared by the opposite edge detection.<br />
 eg. if positive edge is selected as trigger event, for the negative edge event the status flag is cleared. </p>
</td></tr>
</table>

</div>
</div>
<a id="gafe843daae3d38c529ffd50b148d61628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe843daae3d38c529ffd50b148d61628">&#9670;&nbsp;</a></span>XMC_ERU_OGU_PATTERN_DETECTION_INPUT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___e_r_u.html#gafe843daae3d38c529ffd50b148d61628">XMC_ERU_OGU_PATTERN_DETECTION_INPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the inputs for Pattern detection. The configured status flag signal from the ETLx(Event Trigger Logic, x = [0 to 3]) unit indicates the pattern to be detected. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafe843daae3d38c529ffd50b148d61628adf1a26796fdb20a72cb1ca335d17085e"></a>XMC_ERU_OGU_PATTERN_DETECTION_INPUT0&#160;</td><td class="fielddoc"><p>Status flag ETL0, participating in pattern match </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafe843daae3d38c529ffd50b148d61628a7016472cfdbf7886f3c25302c328f3fd"></a>XMC_ERU_OGU_PATTERN_DETECTION_INPUT1&#160;</td><td class="fielddoc"><p>Status flag ETL1, participating in pattern match </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafe843daae3d38c529ffd50b148d61628a09b5cb435dabfd13ecc6d582bea54f5a"></a>XMC_ERU_OGU_PATTERN_DETECTION_INPUT2&#160;</td><td class="fielddoc"><p>Status flag ETL0, participating in pattern match </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafe843daae3d38c529ffd50b148d61628ae0a0f7f22ac23f1899278e2e2cc107e8"></a>XMC_ERU_OGU_PATTERN_DETECTION_INPUT3&#160;</td><td class="fielddoc"><p>Status flag ETL0, participating in pattern match </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf46891d9f1772a8f9cfb385c0afd3ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf46891d9f1772a8f9cfb385c0afd3ce2">&#9670;&nbsp;</a></span>XMC_ERU_OGU_PATTERN_DETECTION_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___e_r_u.html#gaf46891d9f1772a8f9cfb385c0afd3ce2">XMC_ERU_OGU_PATTERN_DETECTION_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines pattern detection feature to be enabled or not in OGUy(Output gating unit, y = [0 to 3]). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf46891d9f1772a8f9cfb385c0afd3ce2af44426efaa292f169ab278be1bab3e57"></a>XMC_ERU_OGU_PATTERN_DETECTION_DISABLED&#160;</td><td class="fielddoc"><p>Pattern match is disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf46891d9f1772a8f9cfb385c0afd3ce2aca3188f35e04a604d08e9d6dfbb0c56d"></a>XMC_ERU_OGU_PATTERN_DETECTION_ENABLED&#160;</td><td class="fielddoc"><p>Pattern match is enabled, the selected status flags of ETLx(Event Trigger Logic, x = [0 to 3]) unit, are used in pattern detection. </p>
</td></tr>
</table>

</div>
</div>
<a id="gab2ee1dc0cb1c6218868da04976b6819a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2ee1dc0cb1c6218868da04976b6819a">&#9670;&nbsp;</a></span>XMC_ERU_OGU_PERIPHERAL_TRIGGER_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___e_r_u.html#gab2ee1dc0cb1c6218868da04976b6819a">XMC_ERU_OGU_PERIPHERAL_TRIGGER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines peripheral trigger signal for event generation. Based on the selected peripheral for event generation, the trigger signal is mapped. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab2ee1dc0cb1c6218868da04976b6819aa3c1a210cfd4691164e334c87011ef5e4"></a>XMC_ERU_OGU_PERIPHERAL_TRIGGER1&#160;</td><td class="fielddoc"><p>OGUy1 signal is mapped for event generation </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2ee1dc0cb1c6218868da04976b6819aa1c199c7b5768e348f02eade3297b1aaa"></a>XMC_ERU_OGU_PERIPHERAL_TRIGGER2&#160;</td><td class="fielddoc"><p>OGUy2 signal is mapped for event generation </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab2ee1dc0cb1c6218868da04976b6819aa63c69e2c28f6e1abce23f130be26b9cc"></a>XMC_ERU_OGU_PERIPHERAL_TRIGGER3&#160;</td><td class="fielddoc"><p>OGUy3 signal is mapped for event generation </p>
</td></tr>
</table>

</div>
</div>
<a id="gaae4af18f2e9af9ae235a3d69b4007c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae4af18f2e9af9ae235a3d69b4007c0e">&#9670;&nbsp;</a></span>XMC_ERU_OGU_SERVICE_REQUEST_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___e_r_u.html#gaae4af18f2e9af9ae235a3d69b4007c0e">XMC_ERU_OGU_SERVICE_REQUEST_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the gating scheme for service request generation. In later stage of the OGUy(Output gating unit, y = [0 to 3]) based on the gating scheme selected ERU_GOUTy(gated output signal) output is defined. </p><div class="image">
<img src="interrupt_gating_signal.png" alt="interrupt_gating_signal.png"/>
<div class="caption">
Interrupt gating signal</div></div>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaae4af18f2e9af9ae235a3d69b4007c0ea13ca9db2aa531750aa70efdf176ec854"></a>XMC_ERU_OGU_SERVICE_REQUEST_DISABLED&#160;</td><td class="fielddoc"><p>Service request blocked, ERUx_GOUTy = 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaae4af18f2e9af9ae235a3d69b4007c0ea5b62a526258183d0d1de2a8f491fd73d"></a>XMC_ERU_OGU_SERVICE_REQUEST_ON_TRIGGER&#160;</td><td class="fielddoc"><p>Service request generated enabled, ERUx_GOUTy = 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaae4af18f2e9af9ae235a3d69b4007c0ea57197232226ff2ba44702357f85a510f"></a>XMC_ERU_OGU_SERVICE_REQUEST_ON_TRIGGER_AND_PATTERN_MATCH&#160;</td><td class="fielddoc"><p>Service request generated on trigger event and input pattern match, ERUx_GOUTy = ~pattern matching result </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaae4af18f2e9af9ae235a3d69b4007c0eaaf704994abfd3973cb9a9e0c132275dd"></a>XMC_ERU_OGU_SERVICE_REQUEST_ON_TRIGGER_AND_PATTERN_MISMATCH&#160;</td><td class="fielddoc"><p>Service request generated on trigger event and input pattern mismatch, ERUx_GOUTy = pattern matching result </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga91a95048baad39ad478b0af050e797dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91a95048baad39ad478b0af050e797dd">&#9670;&nbsp;</a></span>XMC_ERU_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables clock and releases reset for ERU1 module.<br />
</dd></dl>
<dl class="section user"><dt>Note:</dt><dd><ol type="1">
<li>Required to configure ERU1 module again after calling <a class="el" href="group___e_r_u.html#ga0ada9e9c756616d815c573168c841bd4">XMC_ERU_ETL_Init()</a> or <a class="el" href="group___e_r_u.html#ga8f73655169649c7b0599688d390645a0">XMC_ERU_OGU_Init()</a>. Since the all the registers are reset with default values. </li>
</ol>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___e_r_u.html#gaa023eb9a0615ae0322706f53577f000e">XMC_ERU_Enable()</a> </dd></dl>

</div>
</div>
<a id="gaa023eb9a0615ae0322706f53577f000e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa023eb9a0615ae0322706f53577f000e">&#9670;&nbsp;</a></span>XMC_ERU_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>If ERU1 module is selected, it enables clock and releases reset.<br />
 </dd></dl>
<dl class="section user"><dt></dt><dd>This API is called by <a class="el" href="group___e_r_u.html#ga0ada9e9c756616d815c573168c841bd4">XMC_ERU_ETL_Init()</a> or <a class="el" href="group___e_r_u.html#ga8f73655169649c7b0599688d390645a0">XMC_ERU_OGU_Init()</a> and therefore no need to call it explicitly during initialization sequence. Call this API to enable ERU1 module once again if the module is disabled by calling <a class="el" href="group___e_r_u.html#ga91a95048baad39ad478b0af050e797dd">XMC_ERU_Disable()</a>. For ERU0 module clock gating and reset features are not available.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd><ol type="1">
<li>Required to configure ERU1 module again after calling <a class="el" href="group___e_r_u.html#ga91a95048baad39ad478b0af050e797dd">XMC_ERU_Disable()</a>. Since the all the registers are reset with default values. </li>
</ol>
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___e_r_u.html#ga0ada9e9c756616d815c573168c841bd4">XMC_ERU_ETL_Init()</a>, <a class="el" href="group___e_r_u.html#ga8f73655169649c7b0599688d390645a0">XMC_ERU_OGU_Init()</a>, <a class="el" href="group___e_r_u.html#ga91a95048baad39ad478b0af050e797dd">XMC_ERU_Disable()</a>. </dd></dl>

</div>
</div>
<a id="gab3e95f6b12bef69e7e6d1815048a34ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3e95f6b12bef69e7e6d1815048a34ff">&#9670;&nbsp;</a></span>XMC_ERU_ETL_ClearStatusFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_ETL_ClearStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address. </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_ETLx(Event trigger logic unit) channel. Range : [0 to 3]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Clear the status flag bit(FL) in EXICONx(x = [0 to 3]).<br />
 </dd></dl>
<dl class="section user"><dt></dt><dd>If auto clear of the status flag is not enabled by detection of the opposite edge of the event edge, this API clears the Flag. SO that next event is considered as new event. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___e_r_u.html#gaf81afcd379c5d8dd9b91847a7266d20a">XMC_ERU_ETL_SetStatusFlag()</a>, <a class="el" href="group___e_r_u.html#ga83d258683013290648d57f18916e032c">XMC_ERU_ETL_GetStatusFlag()</a> </dd></dl>

</div>
</div>
<a id="gaba049d5d9c2647fc0a99068609650c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba049d5d9c2647fc0a99068609650c00">&#9670;&nbsp;</a></span>XMC_ERU_ETL_DisableOutputTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_ETL_DisableOutputTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address. </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_ETLx(Event trigger logic unit) channel. Range : [0 to 3].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables the trigger pulse generation by clearing the (PE) of the EXICONx(x = <em>channel</em>). </dd></dl>
<dl class="section user"><dt></dt><dd>Typically this can used when only pattern match is being used for event generation.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___e_r_u.html#ga6335e7c97f4834704eb27876741310d7">XMC_ERU_ETL_EnableOutputTrigger()</a> </dd></dl>

</div>
</div>
<a id="ga6335e7c97f4834704eb27876741310d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6335e7c97f4834704eb27876741310d7">&#9670;&nbsp;</a></span>XMC_ERU_ETL_EnableOutputTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_ETL_EnableOutputTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___e_r_u.html#ga15d2fb3d1c965b350e28bcfae34eae87">XMC_ERU_ETL_OUTPUT_TRIGGER_CHANNEL_t</a>&#160;</td>
          <td class="paramname"><em>trigger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address. </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_ETLx(Event trigger logic unit) channel. Range : [0 to 3]. </td></tr>
    <tr><td class="paramname">trigger</td><td>Output Channel of OGUy(Output gating unit y = [0 to 3]) to be mapped by the trigger pulse Refer <a class="el" href="group___e_r_u.html#ga15d2fb3d1c965b350e28bcfae34eae87">XMC_ERU_ETL_OUTPUT_TRIGGER_CHANNEL_t</a> for valid value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configure which Channel of OGUy(Output gating unit y = [0 to 3]) to be mapped by the trigger pulse generated by ETLx(Event Trigger Logic, x = <em>channel</em>) by setting (OCS and PE) bit fields. </dd></dl>
<dl class="section user"><dt></dt><dd>The trigger pulse is generated for one clock pulse along with the flag status update. This is typically used to trigger the ISR for the external events. The configured OGUy(Output gating unit y = [0 to 3]), generates the event based on the trigger pulse.If output trigger pulse generation is disabled by <a class="el" href="group___e_r_u.html#gaba049d5d9c2647fc0a99068609650c00">XMC_ERU_ETL_DisableOutputTrigger()</a>, <a class="el" href="group___e_r_u.html#ga6335e7c97f4834704eb27876741310d7">XMC_ERU_ETL_EnableOutputTrigger()</a> can called to reconfigure. These values are set during initialization in <a class="el" href="group___e_r_u.html#ga0ada9e9c756616d815c573168c841bd4">XMC_ERU_ETL_Init()</a>. Call this to change the trigger edge, as needed later in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___e_r_u.html#gaba049d5d9c2647fc0a99068609650c00">XMC_ERU_ETL_DisableOutputTrigger()</a> </dd></dl>

</div>
</div>
<a id="gaa4690514e452e671401660e0962592c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4690514e452e671401660e0962592c4">&#9670;&nbsp;</a></span>XMC_ERU_ETL_GetEdgeDetection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___e_r_u.html#ga853b59a72ff0b97692d690697f1c9553">XMC_ERU_ETL_EDGE_DETECTION_t</a> XMC_ERU_ETL_GetEdgeDetection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address. </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_ETLx(Event trigger logic unit) channel. Range : [0 to 3]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_ERU_ETL_EDGE_DETECTION_t indicate which egde/s is configured for event generation</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Return event trigger edge/s by reading (RE, FE) bits of EXICONx(x = [0 to 3]) register.<br />
 </dd></dl>
<dl class="section user"><dt></dt><dd>Rising edge, falling edge or either edges can be selected to generate the event. Call this to get the configured trigger edge. </dd></dl>

</div>
</div>
<a id="ga83d258683013290648d57f18916e032c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83d258683013290648d57f18916e032c">&#9670;&nbsp;</a></span>XMC_ERU_ETL_GetStatusFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_ERU_ETL_GetStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address. </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_ETLx(Event trigger logic unit) channel. Range : [0 to 3].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t Current state of the status flag bit(FL). Result is in 32-bit format.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns status flag state of <em>channel</em>. </dd></dl>
<dl class="section user"><dt></dt><dd>The function can typically be used to clear the status flag using software, when auto clear is not enabled.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___e_r_u.html#gaf81afcd379c5d8dd9b91847a7266d20a">XMC_ERU_ETL_SetStatusFlag()</a>, <a class="el" href="group___e_r_u.html#gab3e95f6b12bef69e7e6d1815048a34ff">XMC_ERU_ETL_ClearStatusFlag()</a> </dd></dl>

</div>
</div>
<a id="ga0ada9e9c756616d815c573168c841bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ada9e9c756616d815c573168c841bd4">&#9670;&nbsp;</a></span>XMC_ERU_ETL_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_ETL_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___e_r_u___e_t_l___c_o_n_f_i_g__t.html">XMC_ERU_ETL_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_ETLx(Event trigger logic unit) channel Range : [0 to 3] </td></tr>
    <tr><td class="paramname">config</td><td>pointer to a constant ERU_ETLx configuration data structure. Refer data structure <a class="el" href="struct_x_m_c___e_r_u___e_t_l___c_o_n_f_i_g__t.html">XMC_ERU_ETL_CONFIG_t</a> for detail.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p><b>Description:</b><br />
 Initializes the selected ERU_ETLx <em>channel</em> with the <em>config</em> structure.<br />
</p>
<p>Invokes <a class="el" href="group___e_r_u.html#gaa023eb9a0615ae0322706f53577f000e">XMC_ERU_Enable()</a> to enable <em>eru</em> module clock. Then configures </p><ul>
<li>
Input signal for path A and Path B, </li>
<li>
Trigger pulse generation, </li>
<li>
status flag clear mode, </li>
<li>
Event Trigger edge, </li>
<li>
Output Channel of OGUy(Output gating unit y = [0 to 3]) to be mapped by the trigger pulse, </li>
<li>
input path combination along with polarity for event generation </li>
</ul>
<p>. </p>

</div>
</div>
<a id="ga95937af5ccdea42b8a96a9e8aa3215dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95937af5ccdea42b8a96a9e8aa3215dc">&#9670;&nbsp;</a></span>XMC_ERU_ETL_SetEdgeDetection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_ETL_SetEdgeDetection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___e_r_u.html#ga853b59a72ff0b97692d690697f1c9553">XMC_ERU_ETL_EDGE_DETECTION_t</a>&#160;</td>
          <td class="paramname"><em>edge_detection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address. </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_ETLx(Event trigger logic unit) channel. Range : [0 to 3] </td></tr>
    <tr><td class="paramname">edge_detection</td><td>event trigger edge. Refer <a class="el" href="group___e_r_u.html#ga853b59a72ff0b97692d690697f1c9553">XMC_ERU_ETL_EDGE_DETECTION_t</a> enum for valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configure event trigger edge/s by setting (RE, FE) bits of EXICONx(x = [0 to 3]) register.<br />
 </dd></dl>
<dl class="section user"><dt></dt><dd>Rising edge, falling edge or either edges can be selected to generate the event.These values are set during initialization in <a class="el" href="group___e_r_u.html#ga0ada9e9c756616d815c573168c841bd4">XMC_ERU_ETL_Init()</a>. Call this to change the trigger edge, as needed later in the program. </dd></dl>

</div>
</div>
<a id="ga4633b3a3c840ddab285503720b1e282e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4633b3a3c840ddab285503720b1e282e">&#9670;&nbsp;</a></span>XMC_ERU_ETL_SetInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_ETL_SetInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___e_r_u.html#ga308f21ee6d582ff8551092860b3f5ba4">XMC_ERU_ETL_INPUT_A_t</a>&#160;</td>
          <td class="paramname"><em>input_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___e_r_u.html#gac3fd5e4f15fa5da8177b31e28421bf42">XMC_ERU_ETL_INPUT_B_t</a>&#160;</td>
          <td class="paramname"><em>input_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address. </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_ETLx(Event trigger logic unit) channel. Range : [0 to 3] </td></tr>
    <tr><td class="paramname">input_a</td><td>input signal for path A of ERSx(Event request source, x = [0 to 3]) unit.<br />
 Refer XMC_ERU_ETL_INPUT_A_t for valid value or xmc1_eru_map.h/xmc4_eru_map.h file where the mapping of the input is done based on selected signal.<br />
 e.g: ERU0_ETL3_INPUTA_P2_7. </td></tr>
    <tr><td class="paramname">input_b</td><td>input signal for path B of ERSx(Event request source, x = [0 to 3]) unit.<br />
 Refer XMC_ERU_ETL_INPUT_B_t for valid value or xmc1_eru_map.h/xmc4_eru_map.h file where the mapping of the input is done based on selected signal.<br />
 e.g: ERU0_ETL0_INPUTB_P2_0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the event source for path A and path B in with selected <em>input_a</em> and <em>input_b</em> respectively.<br />
 </dd></dl>
<dl class="section user"><dt></dt><dd>These values are set during initialization in <a class="el" href="group___e_r_u.html#ga0ada9e9c756616d815c573168c841bd4">XMC_ERU_ETL_Init()</a>. Call this to change the input, as needed later in the program. According to the ports/peripheral selected, the event source has to be changed. </dd></dl>

</div>
</div>
<a id="gad32a6e519fa852eba1895ad9b2cb0448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad32a6e519fa852eba1895ad9b2cb0448">&#9670;&nbsp;</a></span>XMC_ERU_ETL_SetSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_ETL_SetSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___e_r_u.html#gace2abdc83ae2a12af12ca448bc5faa1c">XMC_ERU_ETL_SOURCE_t</a>&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address. </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_ETLx(Event trigger logic unit) channel. Range : [0 to 3] </td></tr>
    <tr><td class="paramname">source</td><td>input path combination along with polarity for event generation by ERSx(Event request source) unit. Refer <a class="el" href="group___e_r_u.html#gace2abdc83ae2a12af12ca448bc5faa1c">XMC_ERU_ETL_SOURCE_t</a> enum for valid input values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Select input path combination along with polarity for event generation by setting (SS, NA, NB) bits in ERSx(Event request source) unit <br />
 </dd></dl>
<dl class="section user"><dt></dt><dd>The signal ERSxO is generated from the selection and this is connected to ETLx(Event trigger logic, x = [0 to 3]) for further action. These values are set during initialization in <a class="el" href="group___e_r_u.html#ga0ada9e9c756616d815c573168c841bd4">XMC_ERU_ETL_Init()</a>. Call this to change the source, as needed later in the program. </dd></dl>

</div>
</div>
<a id="gaf81afcd379c5d8dd9b91847a7266d20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf81afcd379c5d8dd9b91847a7266d20a">&#9670;&nbsp;</a></span>XMC_ERU_ETL_SetStatusFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_ETL_SetStatusFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address. </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_ETLx(Event trigger logic unit) channel. Range : [0 to 3]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Set the status flag bit(FL) in EXICONx(x = [0 to 3]).<br />
 </dd></dl>
<dl class="section user"><dt></dt><dd>The status flag indicates that the configured event has occurred. This status flag is used in Pattern match detection by OGUy(Output gating unit, y = [0 to 3]). </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___e_r_u.html#gab3e95f6b12bef69e7e6d1815048a34ff">XMC_ERU_ETL_ClearStatusFlag()</a>, <a class="el" href="group___e_r_u.html#ga83d258683013290648d57f18916e032c">XMC_ERU_ETL_GetStatusFlag()</a> </dd></dl>

</div>
</div>
<a id="gae0f5c34432dc1067976409af3af971ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0f5c34432dc1067976409af3af971ed">&#9670;&nbsp;</a></span>XMC_ERU_ETL_SetStatusFlagMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_ETL_SetStatusFlagMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___e_r_u.html#ga5ea4e2b56bf3f57b0b59e0158f53d42c">XMC_ERU_ETL_STATUS_FLAG_MODE_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address. </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_ETLx(Event trigger logic unit) channel. Range : [0 to 3]. </td></tr>
    <tr><td class="paramname">mode</td><td>Set whether status flag has to be cleared by software or hardware. Refer <a class="el" href="group___e_r_u.html#ga5ea4e2b56bf3f57b0b59e0158f53d42c">XMC_ERU_ETL_STATUS_FLAG_MODE_t</a> for valid value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Set the mode for status flag mode by setting (LD) bit in EXICONx(x = <em>channel</em>) register.<br />
 </dd></dl>
<dl class="section user"><dt></dt><dd>If SWCTRL is selected, status flag has to be cleared by software. This is typically used for pattern match detection. If HWCTRL is selected, status flag is cleared by hardware. If Positive edge is selected as event edge, for negative edge status flag is cleared and vice versa.This is typically used for continuous event detection.These values are set during initialization in <a class="el" href="group___e_r_u.html#ga0ada9e9c756616d815c573168c841bd4">XMC_ERU_ETL_Init()</a>. Call this to change the trigger edge, as needed later in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___e_r_u.html#gab3e95f6b12bef69e7e6d1815048a34ff">XMC_ERU_ETL_ClearStatusFlag()</a>, <a class="el" href="group___e_r_u.html#ga83d258683013290648d57f18916e032c">XMC_ERU_ETL_GetStatusFlag()</a> </dd></dl>

</div>
</div>
<a id="gaeff77065724a9ad6c1f7da14fbf31af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeff77065724a9ad6c1f7da14fbf31af9">&#9670;&nbsp;</a></span>XMC_ERU_OGU_DisablePatternDetection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_OGU_DisablePatternDetection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_OGUy(Output gating unit) channel Range : [0 to 3]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disable the pattern detection by clearing (GEEN) bit. </dd></dl>
<dl class="section user"><dt></dt><dd>Typically XMC_ERU_OGU_DisablePatternDetection is used when events has to be generated peripheral triggers.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___e_r_u.html#ga8575bda905514eb0dbf318c55ef7d96d">XMC_ERU_OGU_EnablePatternDetection()</a>, <a class="el" href="group___e_r_u.html#ga134cd43e144a5142b668ac2bc85fa984">XMC_ERU_OGU_GetPatternDetectionStatus()</a> </dd></dl>

</div>
</div>
<a id="ga66ee1efaa21c1b581756765f6a991a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66ee1efaa21c1b581756765f6a991a66">&#9670;&nbsp;</a></span>XMC_ERU_OGU_DisablePeripheralTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_OGU_DisablePeripheralTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_OGUy(Output gating unit) channel Range : [0 to 3]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables event generation based on peripheral trigger by clearing (ISS) bit. </dd></dl>
<dl class="section user"><dt></dt><dd>This is typically used when peripheral trigger is no longer need. After calling <a class="el" href="group___e_r_u.html#ga66ee1efaa21c1b581756765f6a991a66">XMC_ERU_OGU_DisablePeripheralTrigger()</a>, <a class="el" href="group___e_r_u.html#gafca497a2865ef65cba5a604483954bca">XMC_ERU_OGU_EnablePeripheralTrigger()</a> has to be called to reconfigure the signals again.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___e_r_u.html#gafca497a2865ef65cba5a604483954bca">XMC_ERU_OGU_EnablePeripheralTrigger()</a> </dd></dl>

</div>
</div>
<a id="ga8575bda905514eb0dbf318c55ef7d96d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8575bda905514eb0dbf318c55ef7d96d">&#9670;&nbsp;</a></span>XMC_ERU_OGU_EnablePatternDetection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_OGU_EnablePatternDetection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___e_r_u.html#gafe843daae3d38c529ffd50b148d61628">XMC_ERU_OGU_PATTERN_DETECTION_INPUT_t</a>&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_OGUy(Output gating unit) channel Range : [0 to 3] </td></tr>
    <tr><td class="paramname">input</td><td>ERU_ETLx(x = [0 to 3]), for pattern match detection. Refer <a class="el" href="group___e_r_u.html#gafe843daae3d38c529ffd50b148d61628">XMC_ERU_OGU_PATTERN_DETECTION_INPUT_t</a> for valid values. Logical <b>OR</b> combination of the enum items can be passed as the input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures ERU_ETLx(x = [0 to 3]) for pattern match detection by setting IPENx(x = [0 to 3]) and GEEN bits. </dd></dl>
<dl class="section user"><dt></dt><dd>These bits are dedicated to each channel of the ERU_ETLx(x = [0 to 3]). These values are set during initialization in <a class="el" href="group___e_r_u.html#ga8f73655169649c7b0599688d390645a0">XMC_ERU_OGU_Init()</a>. Call this to change the pattern, as needed later in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___e_r_u.html#gaeff77065724a9ad6c1f7da14fbf31af9">XMC_ERU_OGU_DisablePatternDetection()</a>, <a class="el" href="group___e_r_u.html#ga134cd43e144a5142b668ac2bc85fa984">XMC_ERU_OGU_GetPatternDetectionStatus()</a> </dd></dl>

</div>
</div>
<a id="gafca497a2865ef65cba5a604483954bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafca497a2865ef65cba5a604483954bca">&#9670;&nbsp;</a></span>XMC_ERU_OGU_EnablePeripheralTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_OGU_EnablePeripheralTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___e_r_u.html#gab2ee1dc0cb1c6218868da04976b6819a">XMC_ERU_OGU_PERIPHERAL_TRIGGER_t</a>&#160;</td>
          <td class="paramname"><em>peripheral_trigger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_OGUy(Output gating unit) channel Range : [0 to 3] </td></tr>
    <tr><td class="paramname">peripheral_trigger</td><td>which peripheral trigger signal is used for event generation. Refer <a class="el" href="group___e_r_u.html#gab2ee1dc0cb1c6218868da04976b6819a">XMC_ERU_OGU_PERIPHERAL_TRIGGER_t</a> for the valid values, or xmc1_eru_map.h/xmc4_eru_map.h file where the mapping of the peripheral input is done based on input. e.g: ERU0_OGU0_PERIPHERAL_TRIGGER_CCU40_SR0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures peripheral trigger input, by setting (ISS) bit. </dd></dl>
<dl class="section user"><dt></dt><dd>Based on the peripheral the input signal has to be selected. These values are set during initialization in <a class="el" href="group___e_r_u.html#ga8f73655169649c7b0599688d390645a0">XMC_ERU_OGU_Init()</a>. Call this to change the input, as needed later in the program.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___e_r_u.html#ga66ee1efaa21c1b581756765f6a991a66">XMC_ERU_OGU_DisablePeripheralTrigger()</a> </dd></dl>

</div>
</div>
<a id="ga134cd43e144a5142b668ac2bc85fa984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga134cd43e144a5142b668ac2bc85fa984">&#9670;&nbsp;</a></span>XMC_ERU_OGU_GetPatternDetectionStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_ERU_OGU_GetPatternDetectionStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_OGUy(Output gating unit) channel Range : [0 to 3]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t returns the pattern match result. Result is in 32-bit format.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>This API returns the pattern match result by reading (PDR) bit. </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___e_r_u.html#ga8575bda905514eb0dbf318c55ef7d96d">XMC_ERU_OGU_EnablePatternDetection()</a>, <a class="el" href="group___e_r_u.html#gaeff77065724a9ad6c1f7da14fbf31af9">XMC_ERU_OGU_DisablePatternDetection()</a> </dd></dl>

</div>
</div>
<a id="ga8f73655169649c7b0599688d390645a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f73655169649c7b0599688d390645a0">&#9670;&nbsp;</a></span>XMC_ERU_OGU_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_OGU_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="union_x_m_c___e_r_u___o_g_u___c_o_n_f_i_g__t.html">XMC_ERU_OGU_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_OGUy(Output gating unit) channel Range : [0 to 3] </td></tr>
    <tr><td class="paramname">config</td><td>pointer to constant ERU_OGUy configuration data structure. Refer data structure <a class="el" href="union_x_m_c___e_r_u___o_g_u___c_o_n_f_i_g__t.html">XMC_ERU_OGU_CONFIG_t</a> for detail.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p><b>Description:</b><br />
 Initializes the selected ERU_OGUy <em>channel</em> with the <em>config</em> structure.<br />
</p>
<p>Invokes <a class="el" href="group___e_r_u.html#gaa023eb9a0615ae0322706f53577f000e">XMC_ERU_Enable()</a> to enable <em>eru</em> module clock. Then configures </p><ul>
<li>
Pattern detection, </li>
<li>
Peripheral trigger input, </li>
<li>
Gating for service request generation </li>
</ul>
<p>. </p>

</div>
</div>
<a id="ga5dc8b8a92b00cbcb2ed80fa5201a5ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dc8b8a92b00cbcb2ed80fa5201a5ce0">&#9670;&nbsp;</a></span>XMC_ERU_OGU_SetServiceRequestMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_ERU_OGU_SetServiceRequestMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a> *const&#160;</td>
          <td class="paramname"><em>eru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___e_r_u.html#gaae4af18f2e9af9ae235a3d69b4007c0e">XMC_ERU_OGU_SERVICE_REQUEST_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eru</td><td>A constant pointer to <a class="el" href="struct_x_m_c___e_r_u__t.html">XMC_ERU_t</a>, pointing to the ERU base address </td></tr>
    <tr><td class="paramname">channel</td><td>ERU_OGUy(Output gating unit) channel Range : [0 to 3] </td></tr>
    <tr><td class="paramname">mode</td><td>gating scheme for service request generation. Refer <a class="el" href="group___e_r_u.html#gaae4af18f2e9af9ae235a3d69b4007c0e">XMC_ERU_OGU_SERVICE_REQUEST_t</a> for valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures the gating scheme for service request generation by setting (GP) bit.<br />
 </dd></dl>
<dl class="section user"><dt></dt><dd>Typically this function is used to change the service request generation scheme. These values are set during initialization in <a class="el" href="group___e_r_u.html#ga8f73655169649c7b0599688d390645a0">XMC_ERU_OGU_Init()</a>. Call this to change the gating mode, as needed later in the program. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>XMC Peripheral Library for XMC4000 Family</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
