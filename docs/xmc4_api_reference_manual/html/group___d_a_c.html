<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XMC Peripheral Library for XMC4000 Family: Digital to Analog Converter (DAC)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC4000 Family</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___d_a_c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Digital to Analog Converter (DAC)</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___d_a_c___c_h___c_o_n_f_i_g__t.html">XMC_DAC_CH_CONFIG_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gafc2efa750fdd4aedbaa5be736a28400e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gafc2efa750fdd4aedbaa5be736a28400e">XMC_DAC0</a>&#160;&#160;&#160;((<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *)DAC_BASE)</td></tr>
<tr class="separator:gafc2efa750fdd4aedbaa5be736a28400e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca090211fa47a1235a81308382f7241c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gaca090211fa47a1235a81308382f7241c">XMC_DAC_NO_CHANNELS</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="separator:gaca090211fa47a1235a81308382f7241c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98fe05010708becbd4f109ccee7088b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga98fe05010708becbd4f109ccee7088b3">XMC_DAC_PATTERN_RECTANGLE</a>&#160;&#160;&#160;{31U, 31U, 31U, 31U, 31U, 31U, 31U, 31U, 31U}</td></tr>
<tr class="separator:ga98fe05010708becbd4f109ccee7088b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13c819b94bc1c769a4c879825accd83d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga13c819b94bc1c769a4c879825accd83d">XMC_DAC_PATTERN_SINE</a>&#160;&#160;&#160;{0U, 6U, 12U, 17U, 22U, 26U, 29U, 30U, 31U}</td></tr>
<tr class="separator:ga13c819b94bc1c769a4c879825accd83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb2705c3a364d91468f4a4f47f7d5145"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gacb2705c3a364d91468f4a4f47f7d5145">XMC_DAC_PATTERN_TRIANGLE</a>&#160;&#160;&#160;{0U, 4U, 8U, 12U, 16U, 19U, 23U, 27U, 31U}</td></tr>
<tr class="separator:gacb2705c3a364d91468f4a4f47f7d5145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed680bf1e0aacea27ca505c00822eef9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gaed680bf1e0aacea27ca505c00822eef9">XMC_DAC_SAMPLES_PER_PERIOD</a>&#160;&#160;&#160;(32U)</td></tr>
<tr class="separator:gaed680bf1e0aacea27ca505c00822eef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gabed6dedd39e5a4e8b5b88c780de85ea9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gabed6dedd39e5a4e8b5b88c780de85ea9">XMC_DAC_CH_DATA_TYPE_t</a> </td></tr>
<tr class="separator:gabed6dedd39e5a4e8b5b88c780de85ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab145218c4b905bdd94c85811b8ec7a2c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gab145218c4b905bdd94c85811b8ec7a2c">XMC_DAC_CH_MODE_t</a> </td></tr>
<tr class="separator:gab145218c4b905bdd94c85811b8ec7a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5e272a25affac666157d497783ccb2b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gaf5e272a25affac666157d497783ccb2b">XMC_DAC_CH_OUTPUT_NEGATION_t</a> </td></tr>
<tr class="separator:gaf5e272a25affac666157d497783ccb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9372c99ba8d8daa984786b8f042d4007"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga9372c99ba8d8daa984786b8f042d4007">XMC_DAC_CH_OUTPUT_SCALE_t</a> </td></tr>
<tr class="separator:ga9372c99ba8d8daa984786b8f042d4007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1e4fb1ca9c2bad0de893feee98e6228"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gaf1e4fb1ca9c2bad0de893feee98e6228">XMC_DAC_CH_PATTERN_SIGN_OUTPUT_t</a> </td></tr>
<tr class="separator:gaf1e4fb1ca9c2bad0de893feee98e6228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e37be380b4227fc103ef44c765f2d4d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a> </td></tr>
<tr class="separator:ga4e37be380b4227fc103ef44c765f2d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9176e4c7b167ec22b5673e05ade18eba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga9176e4c7b167ec22b5673e05ade18eba">XMC_DAC_CH_TRIGGER_t</a> </td></tr>
<tr class="separator:ga9176e4c7b167ec22b5673e05ade18eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7612bd7d9cc0ff5168d9db256442f894"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga7612bd7d9cc0ff5168d9db256442f894">XMC_DAC_CH_DisableEvent</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:ga7612bd7d9cc0ff5168d9db256442f894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8fe5610029750fe602088229eb3337c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gac8fe5610029750fe602088229eb3337c">XMC_DAC_CH_DisableOutput</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:gac8fe5610029750fe602088229eb3337c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga901c74dfd9e06a0bdb4ead0d87bb4f71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga901c74dfd9e06a0bdb4ead0d87bb4f71">XMC_DAC_CH_DisableOutputNegation</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:ga901c74dfd9e06a0bdb4ead0d87bb4f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b40c57534700d37e8b70c2ea2f2eea3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga1b40c57534700d37e8b70c2ea2f2eea3">XMC_DAC_CH_DisablePatternSignOutput</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:ga1b40c57534700d37e8b70c2ea2f2eea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e2a705070f03534b1b91ea873b0aab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gac2e2a705070f03534b1b91ea873b0aab">XMC_DAC_CH_EnableEvent</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:gac2e2a705070f03534b1b91ea873b0aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3fe5631a70e40f4d25c473b553ed5af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gaf3fe5631a70e40f4d25c473b553ed5af">XMC_DAC_CH_EnableOutput</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:gaf3fe5631a70e40f4d25c473b553ed5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bf98abf89180297539722636ed9d51d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga8bf98abf89180297539722636ed9d51d">XMC_DAC_CH_EnableOutputNegation</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:ga8bf98abf89180297539722636ed9d51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga973af2e272600c5eeb163ee83579c738"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga973af2e272600c5eeb163ee83579c738">XMC_DAC_CH_EnablePatternSignOutput</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:ga973af2e272600c5eeb163ee83579c738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08350c8116ed004dd36f5ba0902df12d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___d_a_c.html#ga9372c99ba8d8daa984786b8f042d4007">XMC_DAC_CH_OUTPUT_SCALE_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga08350c8116ed004dd36f5ba0902df12d">XMC_DAC_CH_GetOutputScale</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:ga08350c8116ed004dd36f5ba0902df12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cd25ca6afe7a138dcb5bb42c449db0f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga3cd25ca6afe7a138dcb5bb42c449db0f">XMC_DAC_CH_GetRampStart</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:ga3cd25ca6afe7a138dcb5bb42c449db0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dd54e68ac3b4403aa5ba432f545f02e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga5dd54e68ac3b4403aa5ba432f545f02e">XMC_DAC_CH_GetRampStop</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:ga5dd54e68ac3b4403aa5ba432f545f02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94d6569836131b45c58c039fd2fa6a04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga94d6569836131b45c58c039fd2fa6a04">XMC_DAC_CH_Init</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel, const <a class="el" href="struct_x_m_c___d_a_c___c_h___c_o_n_f_i_g__t.html">XMC_DAC_CH_CONFIG_t</a> *const config)</td></tr>
<tr class="separator:ga94d6569836131b45c58c039fd2fa6a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga200437bd896ff475b50a8aa30aea0b42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga200437bd896ff475b50a8aa30aea0b42">XMC_DAC_CH_IsFifoEmpty</a> (const <a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:ga200437bd896ff475b50a8aa30aea0b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73e8d8035927fad18c69a6adf9451ace"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga73e8d8035927fad18c69a6adf9451ace">XMC_DAC_CH_IsFifoFull</a> (const <a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:ga73e8d8035927fad18c69a6adf9451ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18bb5866a5a41077e678ff8c7c6de58c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga18bb5866a5a41077e678ff8c7c6de58c">XMC_DAC_CH_IsOutputEnabled</a> (const <a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:ga18bb5866a5a41077e678ff8c7c6de58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdcfe6cd44bef3ebd95f96998604fec1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gacdcfe6cd44bef3ebd95f96998604fec1">XMC_DAC_CH_SetFrequency</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel, const uint32_t frequency)</td></tr>
<tr class="separator:gacdcfe6cd44bef3ebd95f96998604fec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1774217be659f37d640d13d48816762f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga1774217be659f37d640d13d48816762f">XMC_DAC_CH_SetMode</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel, const <a class="el" href="group___d_a_c.html#gab145218c4b905bdd94c85811b8ec7a2c">XMC_DAC_CH_MODE_t</a> mode)</td></tr>
<tr class="separator:ga1774217be659f37d640d13d48816762f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e1f75defe221c0db5b4133ca927e574"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga1e1f75defe221c0db5b4133ca927e574">XMC_DAC_CH_SetOutputOffset</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel, const uint8_t offset)</td></tr>
<tr class="separator:ga1e1f75defe221c0db5b4133ca927e574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc5544309ce97e7edf14b950e72ffa3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gabc5544309ce97e7edf14b950e72ffa3d">XMC_DAC_CH_SetOutputScale</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel, const <a class="el" href="group___d_a_c.html#ga9372c99ba8d8daa984786b8f042d4007">XMC_DAC_CH_OUTPUT_SCALE_t</a> scale)</td></tr>
<tr class="separator:gabc5544309ce97e7edf14b950e72ffa3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3c155e1596241e323a06bd449674410"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gab3c155e1596241e323a06bd449674410">XMC_DAC_CH_SetPattern</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel, const uint8_t *const pattern)</td></tr>
<tr class="separator:gab3c155e1596241e323a06bd449674410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga592cefaf4c5cc8e2cd83a1fa5472845d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga592cefaf4c5cc8e2cd83a1fa5472845d">XMC_DAC_CH_SetPatternFrequency</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel, const uint32_t frequency)</td></tr>
<tr class="separator:ga592cefaf4c5cc8e2cd83a1fa5472845d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdf995111daf8c4495bf1d2ef2ce58e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gabdf995111daf8c4495bf1d2ef2ce58e3">XMC_DAC_CH_SetRampFrequency</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel, const uint32_t frequency)</td></tr>
<tr class="separator:gabdf995111daf8c4495bf1d2ef2ce58e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf692f5b60cf4c74192b554ec88254aab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gaf692f5b60cf4c74192b554ec88254aab">XMC_DAC_CH_SetRampStart</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel, const uint16_t start)</td></tr>
<tr class="separator:gaf692f5b60cf4c74192b554ec88254aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe44b3910c68e67808aa372a4c6c86ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gafe44b3910c68e67808aa372a4c6c86ce">XMC_DAC_CH_SetRampStop</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel, const uint16_t stop)</td></tr>
<tr class="separator:gafe44b3910c68e67808aa372a4c6c86ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b0260c72dc3e2772c589ec48ffd2c80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga5b0260c72dc3e2772c589ec48ffd2c80">XMC_DAC_CH_SetSignedDataType</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:ga5b0260c72dc3e2772c589ec48ffd2c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac96c41befd18976b555d134013f231c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gac96c41befd18976b555d134013f231c3">XMC_DAC_CH_SetTrigger</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel, const <a class="el" href="group___d_a_c.html#ga9176e4c7b167ec22b5673e05ade18eba">XMC_DAC_CH_TRIGGER_t</a> trigger)</td></tr>
<tr class="separator:gac96c41befd18976b555d134013f231c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4aae1cc510efc383a66eb5c9d258769"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gae4aae1cc510efc383a66eb5c9d258769">XMC_DAC_CH_SetUnsignedDataType</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:gae4aae1cc510efc383a66eb5c9d258769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9620b8278dcabb391d7cf8b2b69f8311"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga9620b8278dcabb391d7cf8b2b69f8311">XMC_DAC_CH_SoftwareTrigger</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:ga9620b8278dcabb391d7cf8b2b69f8311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34d4edcff18efbc8893148120362a589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga34d4edcff18efbc8893148120362a589">XMC_DAC_CH_StartDataMode</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel, const <a class="el" href="group___d_a_c.html#ga9176e4c7b167ec22b5673e05ade18eba">XMC_DAC_CH_TRIGGER_t</a> trigger, const uint32_t frequency)</td></tr>
<tr class="separator:ga34d4edcff18efbc8893148120362a589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cdc0d2ae0c0d3e0ad8ed6babcbd4c04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga8cdc0d2ae0c0d3e0ad8ed6babcbd4c04">XMC_DAC_CH_StartNoiseMode</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel, const <a class="el" href="group___d_a_c.html#ga9176e4c7b167ec22b5673e05ade18eba">XMC_DAC_CH_TRIGGER_t</a> trigger, const uint32_t frequency)</td></tr>
<tr class="separator:ga8cdc0d2ae0c0d3e0ad8ed6babcbd4c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c8c3079b34269e1190e067c34a55f48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga9c8c3079b34269e1190e067c34a55f48">XMC_DAC_CH_StartPatternMode</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel, const uint8_t *const pattern, const <a class="el" href="group___d_a_c.html#gaf1e4fb1ca9c2bad0de893feee98e6228">XMC_DAC_CH_PATTERN_SIGN_OUTPUT_t</a> sign_output, const <a class="el" href="group___d_a_c.html#ga9176e4c7b167ec22b5673e05ade18eba">XMC_DAC_CH_TRIGGER_t</a> trigger, const uint32_t frequency)</td></tr>
<tr class="separator:ga9c8c3079b34269e1190e067c34a55f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1301e3dd09e47e4e81934de759675230"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga1301e3dd09e47e4e81934de759675230">XMC_DAC_CH_StartRampMode</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel, const uint16_t start, const uint16_t stop, const <a class="el" href="group___d_a_c.html#ga9176e4c7b167ec22b5673e05ade18eba">XMC_DAC_CH_TRIGGER_t</a> trigger, const uint32_t frequency)</td></tr>
<tr class="separator:ga1301e3dd09e47e4e81934de759675230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c8a12197978db3edc3216444faee6b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga6c8a12197978db3edc3216444faee6b8">XMC_DAC_CH_StartSingleValueMode</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel)</td></tr>
<tr class="separator:ga6c8a12197978db3edc3216444faee6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e3093f1aa4f47b0793ea0e992580040"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga8e3093f1aa4f47b0793ea0e992580040">XMC_DAC_CH_Write</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint8_t channel, const uint16_t data)</td></tr>
<tr class="separator:ga8e3093f1aa4f47b0793ea0e992580040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67de176f36749cba8a65ad1b9815f0dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga67de176f36749cba8a65ad1b9815f0dd">XMC_DAC_Disable</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac)</td></tr>
<tr class="separator:ga67de176f36749cba8a65ad1b9815f0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9668535a4a093bd1a3eb36cbc474a9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gab9668535a4a093bd1a3eb36cbc474a9f">XMC_DAC_DisableSimultaneousDataMode</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac)</td></tr>
<tr class="separator:gab9668535a4a093bd1a3eb36cbc474a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab97383cd03ebb21046c403c5c835f55c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gab97383cd03ebb21046c403c5c835f55c">XMC_DAC_Enable</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac)</td></tr>
<tr class="separator:gab97383cd03ebb21046c403c5c835f55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c81d639c99a26cebaeea3b20947a15c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga4c81d639c99a26cebaeea3b20947a15c">XMC_DAC_EnableSimultaneousDataMode</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac)</td></tr>
<tr class="separator:ga4c81d639c99a26cebaeea3b20947a15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdcd0136ab6dfc0d98d463136765ab69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#gafdcd0136ab6dfc0d98d463136765ab69">XMC_DAC_IsEnabled</a> (const <a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac)</td></tr>
<tr class="separator:gafdcd0136ab6dfc0d98d463136765ab69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81b11cead3aaabed68b046d40628f89d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_a_c.html#ga81b11cead3aaabed68b046d40628f89d">XMC_DAC_SimultaneousWrite</a> (<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const dac, const uint16_t data0, const uint16_t data1)</td></tr>
<tr class="separator:ga81b11cead3aaabed68b046d40628f89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>DAC driver uses DAC peripheral to convert digital value to analog value. XMC4000 microcontroller family has two DAC channels of 12-bit resolution and maximum conversion rate of 2MHz with full accuracy and 5MHz with reduced accuracy. It consists of inbuilt pattern generator, ramp generator and noise generator modes. Additionally, waveforms can be generated by configuring data registers in single value mode and in data mode. It has DMA handling capability to generate custom waveforms in data mode without CPU intervention.</p>
<p>DAC driver features:</p><ol type="1">
<li>Configuration structure <a class="el" href="struct_x_m_c___d_a_c___c_h___c_o_n_f_i_g__t.html">XMC_DAC_CH_CONFIG_t</a> and initialization function <a class="el" href="group___d_a_c.html#ga94d6569836131b45c58c039fd2fa6a04">XMC_DAC_CH_Init()</a> to initialize DAC and configure channel settings</li>
<li>Pattern Generator Mode:<ul>
<li>DAC is configured in pattern generator mode using <a class="el" href="group___d_a_c.html#ga9c8c3079b34269e1190e067c34a55f48">XMC_DAC_CH_StartPatternMode()</a></li>
<li><a class="el" href="group___d_a_c.html#gab3c155e1596241e323a06bd449674410">XMC_DAC_CH_SetPattern()</a> is used to set the waveform pattern values in pattern register for one quarter</li>
<li>Allows to change the trigger frequency using <a class="el" href="group___d_a_c.html#ga592cefaf4c5cc8e2cd83a1fa5472845d">XMC_DAC_CH_SetPatternFrequency()</a></li>
</ul>
</li>
<li>Single Value Mode:<ul>
<li>DAC is configured in single value mode using <a class="el" href="group___d_a_c.html#ga6c8a12197978db3edc3216444faee6b8">XMC_DAC_CH_StartSingleValueMode()</a></li>
<li>Allows to change the trigger frequency using <a class="el" href="group___d_a_c.html#gacdcfe6cd44bef3ebd95f96998604fec1">XMC_DAC_CH_SetFrequency()</a></li>
</ul>
</li>
<li>Data Mode:<ul>
<li>DAC is configured in data mode using <a class="el" href="group___d_a_c.html#ga34d4edcff18efbc8893148120362a589">XMC_DAC_CH_StartDataMode()</a></li>
<li>Allows to change the trigger frequency using <a class="el" href="group___d_a_c.html#gacdcfe6cd44bef3ebd95f96998604fec1">XMC_DAC_CH_SetFrequency()</a></li>
</ul>
</li>
<li>Ramp Mode:<ul>
<li>DAC is configured in ramp generator mode using <a class="el" href="group___d_a_c.html#ga1301e3dd09e47e4e81934de759675230">XMC_DAC_CH_StartRampMode()</a></li>
<li>Allows to change the trigger frequency using <a class="el" href="group___d_a_c.html#gabdf995111daf8c4495bf1d2ef2ce58e3">XMC_DAC_CH_SetRampFrequency()</a></li>
<li>Allows to set the start and stop values of the ramp using <a class="el" href="group___d_a_c.html#gaf692f5b60cf4c74192b554ec88254aab">XMC_DAC_CH_SetRampStart()</a> and <a class="el" href="group___d_a_c.html#gafe44b3910c68e67808aa372a4c6c86ce">XMC_DAC_CH_SetRampStop()</a></li>
</ul>
</li>
<li>Noise Mode:<ul>
<li>DAC is configured in noise mode using <a class="el" href="group___d_a_c.html#ga8cdc0d2ae0c0d3e0ad8ed6babcbd4c04">XMC_DAC_CH_StartNoiseMode()</a></li>
<li>Allows to change the trigger frequency using <a class="el" href="group___d_a_c.html#gacdcfe6cd44bef3ebd95f96998604fec1">XMC_DAC_CH_SetFrequency()</a></li>
</ul>
</li>
<li>Allows to change the scale, offset dynamically using <a class="el" href="group___d_a_c.html#gabc5544309ce97e7edf14b950e72ffa3d">XMC_DAC_CH_SetOutputScale()</a> and <a class="el" href="group___d_a_c.html#ga1e1f75defe221c0db5b4133ca927e574">XMC_DAC_CH_SetOutputOffset()</a> respectively</li>
<li>Allows to select one of the eight possible trigger sources using <a class="el" href="group___d_a_c.html#gac96c41befd18976b555d134013f231c3">XMC_DAC_CH_SetTrigger()</a></li>
<li>2 DAC channels can be used in synchronization in single value mode and data mode to generate two analog outputs in sync. <a class="el" href="group___d_a_c.html#ga4c81d639c99a26cebaeea3b20947a15c">XMC_DAC_EnableSimultaneousDataMode()</a> </li>
</ol>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gafc2efa750fdd4aedbaa5be736a28400e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc2efa750fdd4aedbaa5be736a28400e">&#9670;&nbsp;</a></span>XMC_DAC0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_DAC0&#160;&#160;&#160;((<a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *)DAC_BASE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DAC module register base </p>

</div>
</div>
<a id="gaca090211fa47a1235a81308382f7241c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca090211fa47a1235a81308382f7241c">&#9670;&nbsp;</a></span>XMC_DAC_NO_CHANNELS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_DAC_NO_CHANNELS&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DAC maximum channels </p>

</div>
</div>
<a id="ga98fe05010708becbd4f109ccee7088b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98fe05010708becbd4f109ccee7088b3">&#9670;&nbsp;</a></span>XMC_DAC_PATTERN_RECTANGLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_DAC_PATTERN_RECTANGLE&#160;&#160;&#160;{31U, 31U, 31U, 31U, 31U, 31U, 31U, 31U, 31U}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>First quarter Rectangle waveform samples </p>

</div>
</div>
<a id="ga13c819b94bc1c769a4c879825accd83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13c819b94bc1c769a4c879825accd83d">&#9670;&nbsp;</a></span>XMC_DAC_PATTERN_SINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_DAC_PATTERN_SINE&#160;&#160;&#160;{0U, 6U, 12U, 17U, 22U, 26U, 29U, 30U, 31U}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>First quarter Sine waveform samples </p>

</div>
</div>
<a id="gacb2705c3a364d91468f4a4f47f7d5145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb2705c3a364d91468f4a4f47f7d5145">&#9670;&nbsp;</a></span>XMC_DAC_PATTERN_TRIANGLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_DAC_PATTERN_TRIANGLE&#160;&#160;&#160;{0U, 4U, 8U, 12U, 16U, 19U, 23U, 27U, 31U}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>First quarter Triangle waveform samples </p>

</div>
</div>
<a id="gaed680bf1e0aacea27ca505c00822eef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed680bf1e0aacea27ca505c00822eef9">&#9670;&nbsp;</a></span>XMC_DAC_SAMPLES_PER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMC_DAC_SAMPLES_PER_PERIOD&#160;&#160;&#160;(32U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DAC samples per period in pattern mode </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gabed6dedd39e5a4e8b5b88c780de85ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabed6dedd39e5a4e8b5b88c780de85ea9">&#9670;&nbsp;</a></span>XMC_DAC_CH_DATA_TYPE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_a_c.html#gabed6dedd39e5a4e8b5b88c780de85ea9">XMC_DAC_CH_DATA_TYPE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data type of the input data </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabed6dedd39e5a4e8b5b88c780de85ea9a515ff00c5ccd8b9565257a0771347583"></a>XMC_DAC_CH_DATA_TYPE_UNSIGNED&#160;</td><td class="fielddoc"><p>input data is unsigned </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabed6dedd39e5a4e8b5b88c780de85ea9a3258da7e193fc755383c480a337037ff"></a>XMC_DAC_CH_DATA_TYPE_SIGNED&#160;</td><td class="fielddoc"><p>input data is signed </p>
</td></tr>
</table>

</div>
</div>
<a id="gab145218c4b905bdd94c85811b8ec7a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab145218c4b905bdd94c85811b8ec7a2c">&#9670;&nbsp;</a></span>XMC_DAC_CH_MODE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_a_c.html#gab145218c4b905bdd94c85811b8ec7a2c">XMC_DAC_CH_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operating modes of DAC </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab145218c4b905bdd94c85811b8ec7a2cab60cc89d056f1e994f95e5cf0ab3ee3f"></a>XMC_DAC_CH_MODE_IDLE&#160;</td><td class="fielddoc"><p>DAC is disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab145218c4b905bdd94c85811b8ec7a2caebed4f6d5058ad45ab0a93322898a102"></a>XMC_DAC_CH_MODE_SINGLE&#160;</td><td class="fielddoc"><p>Single value mode - single data value is updated and maintained </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab145218c4b905bdd94c85811b8ec7a2ca9dae61c469e47cd75be8a9e9689d8393"></a>XMC_DAC_CH_MODE_DATA&#160;</td><td class="fielddoc"><p>Data mode - continuous data processing </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab145218c4b905bdd94c85811b8ec7a2ca00245fd95505e05d1c3cc6670265fef0"></a>XMC_DAC_CH_MODE_PATTERN&#160;</td><td class="fielddoc"><p>Pattern mode - inbuilt pattern waveform generation - Sine, Triangle, Rectangle </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab145218c4b905bdd94c85811b8ec7a2caf63f03eca43e965fba40285cb92e3e62"></a>XMC_DAC_CH_MODE_NOISE&#160;</td><td class="fielddoc"><p>Noise mode - pseudo-random noise generation </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab145218c4b905bdd94c85811b8ec7a2cac6e5937740ac5cc3200c5f590e091fbf"></a>XMC_DAC_CH_MODE_RAMP&#160;</td><td class="fielddoc"><p>Ramp mode - ramp generation </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf5e272a25affac666157d497783ccb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5e272a25affac666157d497783ccb2b">&#9670;&nbsp;</a></span>XMC_DAC_CH_OUTPUT_NEGATION_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_a_c.html#gaf5e272a25affac666157d497783ccb2b">XMC_DAC_CH_OUTPUT_NEGATION_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Negation of input data (applicable only for XMC44 device) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf5e272a25affac666157d497783ccb2ba356969170b9cf3b7f70fd82d9bfe373a"></a>XMC_DAC_CH_OUTPUT_NEGATION_DISABLED&#160;</td><td class="fielddoc"><p>XMC_DAC_CH_OUTPUT_NEGATION_DISABLED </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf5e272a25affac666157d497783ccb2ba42549ee202f4c08f9e638656ae320dbb"></a>XMC_DAC_CH_OUTPUT_NEGATION_ENABLED&#160;</td><td class="fielddoc"><p>XMC_DAC_CH_OUTPUT_NEGATION_ENABLED </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9372c99ba8d8daa984786b8f042d4007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9372c99ba8d8daa984786b8f042d4007">&#9670;&nbsp;</a></span>XMC_DAC_CH_OUTPUT_SCALE_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_a_c.html#ga9372c99ba8d8daa984786b8f042d4007">XMC_DAC_CH_OUTPUT_SCALE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling of the input data </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9372c99ba8d8daa984786b8f042d4007ae98552d53e632106ecf1ce567b570a47"></a>XMC_DAC_CH_OUTPUT_SCALE_NONE&#160;</td><td class="fielddoc"><p>No scaling </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9372c99ba8d8daa984786b8f042d4007a01ebb295f7321fddbaa3ec0a969bdad6"></a>XMC_DAC_CH_OUTPUT_SCALE_MUL_2&#160;</td><td class="fielddoc"><p>multiplied by 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9372c99ba8d8daa984786b8f042d4007a7e8a6467c766097010ce1c173715dbc8"></a>XMC_DAC_CH_OUTPUT_SCALE_MUL_4&#160;</td><td class="fielddoc"><p>multiplied by 4 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9372c99ba8d8daa984786b8f042d4007aae6733f0486d9c306e749f222ef32e86"></a>XMC_DAC_CH_OUTPUT_SCALE_MUL_8&#160;</td><td class="fielddoc"><p>multiplied by 8 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9372c99ba8d8daa984786b8f042d4007a985ee78289a117a0f2277f8293385e50"></a>XMC_DAC_CH_OUTPUT_SCALE_MUL_16&#160;</td><td class="fielddoc"><p>multiplied by 16 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9372c99ba8d8daa984786b8f042d4007a6bcf2a549695fde6da39e76711f13f69"></a>XMC_DAC_CH_OUTPUT_SCALE_MUL_32&#160;</td><td class="fielddoc"><p>multiplied by 32 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9372c99ba8d8daa984786b8f042d4007a3d0fc15564713d3176a85f326c3c100a"></a>XMC_DAC_CH_OUTPUT_SCALE_MUL_64&#160;</td><td class="fielddoc"><p>multiplied by 64 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9372c99ba8d8daa984786b8f042d4007af6b6551310573ea15e033fa2220ccea9"></a>XMC_DAC_CH_OUTPUT_SCALE_MUL_128&#160;</td><td class="fielddoc"><p>multiplied by 128 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9372c99ba8d8daa984786b8f042d4007a81b76aa6cd1039295158077f779bcfbe"></a>XMC_DAC_CH_OUTPUT_SCALE_DIV_2&#160;</td><td class="fielddoc"><p>divided by 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9372c99ba8d8daa984786b8f042d4007a097c24e5d23da7a32ae91d98ba51cc8e"></a>XMC_DAC_CH_OUTPUT_SCALE_DIV_4&#160;</td><td class="fielddoc"><p>divided by 4 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9372c99ba8d8daa984786b8f042d4007a677b0dc54045bcec45ed017b90585726"></a>XMC_DAC_CH_OUTPUT_SCALE_DIV_8&#160;</td><td class="fielddoc"><p>divided by 8 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9372c99ba8d8daa984786b8f042d4007a66927dc300c8176b545bb8b3ac886ef2"></a>XMC_DAC_CH_OUTPUT_SCALE_DIV_16&#160;</td><td class="fielddoc"><p>divided by 16 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9372c99ba8d8daa984786b8f042d4007a43798edd742ce7279d2604f9e9c51a44"></a>XMC_DAC_CH_OUTPUT_SCALE_DIV_32&#160;</td><td class="fielddoc"><p>divided by 32 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9372c99ba8d8daa984786b8f042d4007a23006b4a49f768550ba7ca5928344281"></a>XMC_DAC_CH_OUTPUT_SCALE_DIV_64&#160;</td><td class="fielddoc"><p>divided by 64 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9372c99ba8d8daa984786b8f042d4007afed3adc5704981d3b3efab55fea9842a"></a>XMC_DAC_CH_OUTPUT_SCALE_DIV_128&#160;</td><td class="fielddoc"><p>divided by 128 </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf1e4fb1ca9c2bad0de893feee98e6228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1e4fb1ca9c2bad0de893feee98e6228">&#9670;&nbsp;</a></span>XMC_DAC_CH_PATTERN_SIGN_OUTPUT_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_a_c.html#gaf1e4fb1ca9c2bad0de893feee98e6228">XMC_DAC_CH_PATTERN_SIGN_OUTPUT_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output sign signal for the Pattern Generation Mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf1e4fb1ca9c2bad0de893feee98e6228a4ae92975858953559259477d7de9274c"></a>XMC_DAC_CH_PATTERN_SIGN_OUTPUT_DISABLED&#160;</td><td class="fielddoc"><p>Sign output signal generation is disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf1e4fb1ca9c2bad0de893feee98e6228a4735536396880c1868745af9944ad12a"></a>XMC_DAC_CH_PATTERN_SIGN_OUTPUT_ENABLED&#160;</td><td class="fielddoc"><p>Sign output signal generation is enabled </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4e37be380b4227fc103ef44c765f2d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e37be380b4227fc103ef44c765f2d4d">&#9670;&nbsp;</a></span>XMC_DAC_CH_STATUS_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return types of the API's </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4e37be380b4227fc103ef44c765f2d4da4143bb37824ebceee0c840d12ed980ef"></a>XMC_DAC_CH_STATUS_OK&#160;</td><td class="fielddoc"><p>Status is ok, no error detected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4e37be380b4227fc103ef44c765f2d4dab37b65d8effd30615d9e519bf684e647"></a>XMC_DAC_CH_STATUS_ERROR&#160;</td><td class="fielddoc"><p>Error detected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4e37be380b4227fc103ef44c765f2d4dab66a1d8173c7ca28c3f23d41f9bde504"></a>XMC_DAC_CH_STATUS_BUSY&#160;</td><td class="fielddoc"><p>DAC is busy </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4e37be380b4227fc103ef44c765f2d4dae5e20892a46f623543cddfc268d55cf6"></a>XMC_DAC_CH_STATUS_ERROR_FREQ2LOW&#160;</td><td class="fielddoc"><p>Frequency can't be configured. Frequency is to low. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4e37be380b4227fc103ef44c765f2d4dabceea708468c56846195fb5a6336527b"></a>XMC_DAC_CH_STATUS_ERROR_FREQ2HIGH&#160;</td><td class="fielddoc"><p>Frequency can't be configured. Frequency is to high. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9176e4c7b167ec22b5673e05ade18eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9176e4c7b167ec22b5673e05ade18eba">&#9670;&nbsp;</a></span>XMC_DAC_CH_TRIGGER_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_a_c.html#ga9176e4c7b167ec22b5673e05ade18eba">XMC_DAC_CH_TRIGGER_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trigger sources for the data update </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9176e4c7b167ec22b5673e05ade18ebaaf3c5c5c663d068867d11158e19e0c6e2"></a>XMC_DAC_CH_TRIGGER_INTERNAL&#160;</td><td class="fielddoc"><p>Internal trigger as per frequency divider value </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9176e4c7b167ec22b5673e05ade18ebaae8546e01f01037086fe41be6aeb3a07a"></a>XMC_DAC_CH_TRIGGER_EXTERNAL_CCU80_SR1&#160;</td><td class="fielddoc"><p>External trigger from CCU80 Interrupt SR1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9176e4c7b167ec22b5673e05ade18ebaaa13dab51ee1d83ec23cfbe90deed07cb"></a>XMC_DAC_CH_TRIGGER_EXTERNAL_CCU40_SR1&#160;</td><td class="fielddoc"><p>External trigger from CCU40 Interrupt SR1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9176e4c7b167ec22b5673e05ade18ebaa333a073d7997ad313e648b396c6fdbea"></a>XMC_DAC_CH_TRIGGER_EXTERNAL_CCU41_SR1&#160;</td><td class="fielddoc"><p>External trigger from CCU41 Interrupt SR1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9176e4c7b167ec22b5673e05ade18ebaa44cd76b8737807422c8759b6ee6b8897"></a>XMC_DAC_CH_TRIGGER_EXTERNAL_P2_9&#160;</td><td class="fielddoc"><p>External trigger from pin 2.9 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9176e4c7b167ec22b5673e05ade18ebaa2cfc68d782d6639fcfe359b7b9f1dee3"></a>XMC_DAC_CH_TRIGGER_EXTERNAL_P2_8&#160;</td><td class="fielddoc"><p>External trigger from pin 2.8 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9176e4c7b167ec22b5673e05ade18ebaa0dd9de57bceb55915b0af6cb99fcfdac"></a>XMC_DAC_CH_TRIGGER_EXTERNAL_U0C0_DX1INS&#160;</td><td class="fielddoc"><p>External trigger from USIC-0 DX1 Input Signal </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9176e4c7b167ec22b5673e05ade18ebaa5dd09d96ded088ce1f261e3446207a4d"></a>XMC_DAC_CH_TRIGGER_EXTERNAL_U1C0_DX1INS&#160;</td><td class="fielddoc"><p>External trigger from USIC-1 DX1 Input Signal </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9176e4c7b167ec22b5673e05ade18ebaad533a56154220c6844903436e8cc03a2"></a>XMC_DAC_CH_TRIGGER_SOFTWARE&#160;</td><td class="fielddoc"><p>Software trigger </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7612bd7d9cc0ff5168d9db256442f894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7612bd7d9cc0ff5168d9db256442f894">&#9670;&nbsp;</a></span>XMC_DAC_CH_DisableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_DisableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables service request by clearing <em>SREN</em> bit of <em>DAC0CFG0</em> register (for channel 0) / <em>DAC1CFG0</em> register (for channel 1).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#gac2e2a705070f03534b1b91ea873b0aab">XMC_DAC_CH_EnableEvent()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gac8fe5610029750fe602088229eb3337c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8fe5610029750fe602088229eb3337c">&#9670;&nbsp;</a></span>XMC_DAC_CH_DisableOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_DisableOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Channel <em>channel</em> output is disabled by clearing the <em>ANAEN</em> bit of <em>DAC0CFG1</em> register (for channel 0) / <em>DAC1CFG1</em> register (for channel 1).</dd></dl>
<dl class="section user"><dt></dt><dd>A call to this API stops driving the converted digital input to its output.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#gaf3fe5631a70e40f4d25c473b553ed5af">XMC_DAC_CH_EnableOutput()</a>, <a class="el" href="group___d_a_c.html#ga18bb5866a5a41077e678ff8c7c6de58c">XMC_DAC_CH_IsOutputEnabled()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga901c74dfd9e06a0bdb4ead0d87bb4f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga901c74dfd9e06a0bdb4ead0d87bb4f71">&#9670;&nbsp;</a></span>XMC_DAC_CH_DisableOutputNegation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_DisableOutputNegation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>Disables output negation.</dd></dl>
<dl class="section user"><dt></dt><dd>Negation is disabled by clearing <em>NEGATE</em> bit of <em>DAC0CFG0</em> register (for channel 0) / <em>DAC1CFG0</em> register (for channel 1).</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Negation feature is not applicable for XMC45 devices. Calling this API in XMC45 devices doesn't have any effect.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga8bf98abf89180297539722636ed9d51d">XMC_DAC_CH_EnableOutputNegation()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga1b40c57534700d37e8b70c2ea2f2eea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b40c57534700d37e8b70c2ea2f2eea3">&#9670;&nbsp;</a></span>XMC_DAC_CH_DisablePatternSignOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_DisablePatternSignOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables output sign information for Pattern Mode.</dd></dl>
<dl class="section user"><dt></dt><dd>Sign output is disabled by clearing <em>SIGNEN</em> bit of <em>DAC0CFG0</em> register (for channel 0) / DAC1CFG0 register (for channel 1).</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Call this API if the <em>channel</em> is set to Pattern mode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga9c8c3079b34269e1190e067c34a55f48">XMC_DAC_CH_StartPatternMode()</a>, <a class="el" href="group___d_a_c.html#ga973af2e272600c5eeb163ee83579c738">XMC_DAC_CH_EnablePatternSignOutput()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gac2e2a705070f03534b1b91ea873b0aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2e2a705070f03534b1b91ea873b0aab">&#9670;&nbsp;</a></span>XMC_DAC_CH_EnableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_EnableEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables service request by setting <em>SREN</em> bit of <em>DAC0CFG0</em> register (for channel 0) / <em>DAC1CFG0</em> register (for channel 1). Trigger signal is generated upon conversion of each data.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>The service request signal can be connected to NVIC, DMA.<br />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga7612bd7d9cc0ff5168d9db256442f894">XMC_DAC_CH_DisableEvent()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gaf3fe5631a70e40f4d25c473b553ed5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3fe5631a70e40f4d25c473b553ed5af">&#9670;&nbsp;</a></span>XMC_DAC_CH_EnableOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_EnableOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Channel <em>channel</em> output is enabled by setting the <em>ANAEN</em> bit of <em>DAC0CFG1</em> register (for channel 0) / <em>DAC1CFG1</em> register (for channel 1).</dd></dl>
<dl class="section user"><dt>Note:</dt><dd><em>tSTARTUP</em> time for DAC analog output starts after the <em>ANAEN</em> bit is set to one. After the expiry of the startup time the default value is driven to DAC output and a new value can be written.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#gac8fe5610029750fe602088229eb3337c">XMC_DAC_CH_DisableOutput()</a>, <a class="el" href="group___d_a_c.html#ga18bb5866a5a41077e678ff8c7c6de58c">XMC_DAC_CH_IsOutputEnabled()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga8bf98abf89180297539722636ed9d51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bf98abf89180297539722636ed9d51d">&#9670;&nbsp;</a></span>XMC_DAC_CH_EnableOutputNegation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_EnableOutputNegation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>Enables output negation.</dd></dl>
<dl class="section user"><dt></dt><dd>By negating the DAC value is converted to its two's complement values. Can be used in Ramp mode to generate negative ramp. Negation in enabled by setting <em>NEGATE</em> bit of <em>DAC0CFG0</em> register (for channel 0) / <em>DAC1CFG0</em> register (for channel 1).</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Negation feature is not applicable for XMC45 devices. Calling this API in XMC45 devices doesn't have any effect.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga901c74dfd9e06a0bdb4ead0d87bb4f71">XMC_DAC_CH_DisableOutputNegation()</a>, <a class="el" href="group___d_a_c.html#ga1301e3dd09e47e4e81934de759675230">XMC_DAC_CH_StartRampMode()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga973af2e272600c5eeb163ee83579c738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga973af2e272600c5eeb163ee83579c738">&#9670;&nbsp;</a></span>XMC_DAC_CH_EnablePatternSignOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_EnablePatternSignOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables the output sign information for Pattern Mode.</dd></dl>
<dl class="section user"><dt></dt><dd>Sign output is enabled by setting <em>SIGNEN</em> bit of <em>DAC0CFG0</em> register (for channel 0) / DAC1CFG0 register (for channel 1).</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Call this API if the <em>channel</em> is set to Pattern mode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga9c8c3079b34269e1190e067c34a55f48">XMC_DAC_CH_StartPatternMode()</a>, <a class="el" href="group___d_a_c.html#ga1b40c57534700d37e8b70c2ea2f2eea3">XMC_DAC_CH_DisablePatternSignOutput()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga08350c8116ed004dd36f5ba0902df12d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08350c8116ed004dd36f5ba0902df12d">&#9670;&nbsp;</a></span>XMC_DAC_CH_GetOutputScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___d_a_c.html#ga9372c99ba8d8daa984786b8f042d4007">XMC_DAC_CH_OUTPUT_SCALE_t</a> XMC_DAC_CH_GetOutputScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_DAC_CH_OUTPUT_SCALE_t</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns scaling information for the data. The input data could be either up-scaled (multiplied), down-scaled (divided) or without scaling (as is).<br />
Scaling factor is determined by reading bit-fields <em>MULDIV</em> and <em>SCALE</em> of <em>DAC0CFG1</em> register (for channel 0) / <em>DAC1CFG1</em> register (for channel 1).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#gabc5544309ce97e7edf14b950e72ffa3d">XMC_DAC_CH_SetOutputScale()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga3cd25ca6afe7a138dcb5bb42c449db0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cd25ca6afe7a138dcb5bb42c449db0f">&#9670;&nbsp;</a></span>XMC_DAC_CH_GetRampStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XMC_DAC_CH_GetRampStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Gets the ramp start value by reading <em>DATA0</em> bit-field of <em>DAC0DATA</em> register (for channel 0) / <em>DATA1</em> bit-field of <em>DAC1DATA</em> register (for channel 1). If the ramp counter reaches its stop value, it restarts from the start value with the next trigger pulse.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Call this API if the <em>channel</em> is set to Ramp mode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#gaf692f5b60cf4c74192b554ec88254aab">XMC_DAC_CH_SetRampStart()</a>, <a class="el" href="group___d_a_c.html#ga1301e3dd09e47e4e81934de759675230">XMC_DAC_CH_StartRampMode()</a>, <a class="el" href="group___d_a_c.html#ga5dd54e68ac3b4403aa5ba432f545f02e">XMC_DAC_CH_GetRampStop()</a>, <a class="el" href="group___d_a_c.html#gafe44b3910c68e67808aa372a4c6c86ce">XMC_DAC_CH_SetRampStop()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga5dd54e68ac3b4403aa5ba432f545f02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dd54e68ac3b4403aa5ba432f545f02e">&#9670;&nbsp;</a></span>XMC_DAC_CH_GetRampStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XMC_DAC_CH_GetRampStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Gets the ramp stop value by reading <em>DATA0</em> bit-field of <em>DAC01DATA</em> register (for channel 0) / <em>DATA1</em> bit-field of <em>DAC01DATA</em> register (for channel 1). If the ramp counter reaches its stop value, it restarts from the start value with the next trigger pulse.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Call this API if the <em>channel</em> is set to Ramp mode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#gafe44b3910c68e67808aa372a4c6c86ce">XMC_DAC_CH_SetRampStop()</a>, <a class="el" href="group___d_a_c.html#ga1301e3dd09e47e4e81934de759675230">XMC_DAC_CH_StartRampMode()</a>, <a class="el" href="group___d_a_c.html#ga3cd25ca6afe7a138dcb5bb42c449db0f">XMC_DAC_CH_GetRampStart()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga94d6569836131b45c58c039fd2fa6a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94d6569836131b45c58c039fd2fa6a04">&#9670;&nbsp;</a></span>XMC_DAC_CH_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___d_a_c___c_h___c_o_n_f_i_g__t.html">XMC_DAC_CH_CONFIG_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to the DAC channel configuration structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Initialises and configures the DAC <em>channel</em> with the configuration date pointed by <em>config</em>.</dd></dl>
<dl class="section user"><dt></dt><dd>DAC channel is initialised by configuring the registers <em>DAC0CFG0</em> and <em>DAC0CFG1</em> registers (for channel 0) / <em>DAC1CFG0</em> and <em>DAC1CFG1</em> registers (for channel 1). It enables the channel output by calling <a class="el" href="group___d_a_c.html#gaf3fe5631a70e40f4d25c473b553ed5af">XMC_DAC_CH_EnableOutput()</a>. </dd></dl>

</div>
</div>
<a id="ga200437bd896ff475b50a8aa30aea0b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga200437bd896ff475b50a8aa30aea0b42">&#9670;&nbsp;</a></span>XMC_DAC_CH_IsFifoEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_DAC_CH_IsFifoEmpty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool<br />
true - if FIFO is empty<br />
false - if FIFO is not empty</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns FIFO status.</dd></dl>
<dl class="section user"><dt></dt><dd>FIFIO empty status is determined by reading <em>FIFOEMP</em> bit of <em>DAC0CFG0</em> register (for channel 0) / <em>DAC1CFG0</em> register (for channel 1).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga73e8d8035927fad18c69a6adf9451ace">XMC_DAC_CH_IsFifoFull()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga73e8d8035927fad18c69a6adf9451ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73e8d8035927fad18c69a6adf9451ace">&#9670;&nbsp;</a></span>XMC_DAC_CH_IsFifoFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_DAC_CH_IsFifoFull </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool<br />
true - if FIFO is full<br />
false - if FIFO is not full</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns FIFO status.<br />
 </dd></dl>
<dl class="section user"><dt></dt><dd>FIFIO full status is determined by reading <em>FIFOFUL</em> bit of <em>DAC0CFG0</em> register (for channel 0) / <em>DAC1CFG0</em> register (for channel 1).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga200437bd896ff475b50a8aa30aea0b42">XMC_DAC_CH_IsFifoEmpty()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga18bb5866a5a41077e678ff8c7c6de58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18bb5866a5a41077e678ff8c7c6de58c">&#9670;&nbsp;</a></span>XMC_DAC_CH_IsOutputEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_DAC_CH_IsOutputEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool <br />
 true - if analog output is enabled <br />
 false - if analog output is disabled <br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the status of DAC analog output.</dd></dl>
<dl class="section user"><dt></dt><dd>Channel <em>channel</em> output enabled or disabled is determined by reading the <em>ANAEN</em> bit of <em>DAC0CFG1</em> register (for channel 0) / <em>DAC1CFG1</em> register (for channel 1).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#gaf3fe5631a70e40f4d25c473b553ed5af">XMC_DAC_CH_EnableOutput()</a>, <a class="el" href="group___d_a_c.html#gac8fe5610029750fe602088229eb3337c">XMC_DAC_CH_DisableOutput()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gacdcfe6cd44bef3ebd95f96998604fec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdcfe6cd44bef3ebd95f96998604fec1">&#9670;&nbsp;</a></span>XMC_DAC_CH_SetFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a> XMC_DAC_CH_SetFrequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number </td></tr>
    <tr><td class="paramname">frequency</td><td>Waveform frequency in [Hz]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_DAC_CH_STATUS_t</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the <em>frequency</em> of DAC channel.</dd></dl>
<dl class="section user"><dt></dt><dd>The value <em>frequency</em> acts as clock divider. The smallest <em>frequency</em> divider value is 16. A valid <em>frequency</em> value should be within the range XMC_DAC_MIN_FREQ_DIVIDER to XMC_DAC_MAX_FREQ_DIVIDER. A value outside this range is considered as in valid and API returns error. Frequency <em>frequency</em> is configured by setting <em>FREQ</em> bit-field of <em>DAC0CFG0</em> register (for channel 0) / <em>DAC1CFG0</em> register (for channel 1).</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Call this API only for Single value mode, Data mode and Noise mode. Call <a class="el" href="group___d_a_c.html#gabdf995111daf8c4495bf1d2ef2ce58e3">XMC_DAC_CH_SetRampFrequency()</a> in case of Ramp mode and <a class="el" href="group___d_a_c.html#ga592cefaf4c5cc8e2cd83a1fa5472845d">XMC_DAC_CH_SetPatternFrequency()</a> in case of Pattern mode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#gabdf995111daf8c4495bf1d2ef2ce58e3">XMC_DAC_CH_SetRampFrequency()</a>, <a class="el" href="group___d_a_c.html#ga592cefaf4c5cc8e2cd83a1fa5472845d">XMC_DAC_CH_SetPatternFrequency()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga1774217be659f37d640d13d48816762f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1774217be659f37d640d13d48816762f">&#9670;&nbsp;</a></span>XMC_DAC_CH_SetMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_SetMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___d_a_c.html#gab145218c4b905bdd94c85811b8ec7a2c">XMC_DAC_CH_MODE_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number </td></tr>
    <tr><td class="paramname">mode</td><td>DAC operation mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the operating <em>mode</em> for the <em>channel</em> by setting the <em>MODE</em> bit-field of <em>DAC0CFG0</em> register (for channel 0) / <em>DAC1CFG0</em> register (for channel 1). Different modes of DAC operation are defined by enum XMC_DAC_CH_MODE_t. </dd></dl>

</div>
</div>
<a id="ga1e1f75defe221c0db5b4133ca927e574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e1f75defe221c0db5b4133ca927e574">&#9670;&nbsp;</a></span>XMC_DAC_CH_SetOutputOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_SetOutputOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number </td></tr>
    <tr><td class="paramname">offset</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the offset value.<br />
Offset range:0 - 255<br />
interpreted as : -128 to 127 (twos complement) in signed mode and 0 to 255 in unsigned mode.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Scaling can be applied to the output data after adding the <em>offset</em> value.</dd></dl>
<dl class="section user"><dt></dt><dd>Channel <em>channel</em> <em>offset</em> value is loaded to the bit-field <em>DAC0CFG1</em> register (for channel 0) / <em>DAC1CFG1</em> register (for channel 1).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#gabc5544309ce97e7edf14b950e72ffa3d">XMC_DAC_CH_SetOutputScale()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gabc5544309ce97e7edf14b950e72ffa3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc5544309ce97e7edf14b950e72ffa3d">&#9670;&nbsp;</a></span>XMC_DAC_CH_SetOutputScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_SetOutputScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___d_a_c.html#ga9372c99ba8d8daa984786b8f042d4007">XMC_DAC_CH_OUTPUT_SCALE_t</a>&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number </td></tr>
    <tr><td class="paramname">scale</td><td>Input data scaling</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Data of the <em>channel</em> is scaled.</dd></dl>
<dl class="section user"><dt></dt><dd>The data can either be scaled up-scaled (multiplied), down-scaled (divided) or no scaling (as is) based on the value of <em>scale</em>. Scaling is configured by setting bit-fields <em>MULDIV</em> and <em>SCALE</em> of <em>DAC0CFG1</em> register (for channel 0) / <em>DAC1CFG1</em> register (for channel 1).</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga08350c8116ed004dd36f5ba0902df12d">XMC_DAC_CH_GetOutputScale()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gab3c155e1596241e323a06bd449674410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3c155e1596241e323a06bd449674410">&#9670;&nbsp;</a></span>XMC_DAC_CH_SetPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_SetPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number </td></tr>
    <tr><td class="paramname">pattern</td><td>Pointer to the data table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>The data for the Pattern mode is written to the <em>DAC0PATL</em> and <em>DAC0PATH</em> registers. The API is called by <a class="el" href="group___d_a_c.html#ga9c8c3079b34269e1190e067c34a55f48">XMC_DAC_CH_StartPatternMode()</a>.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Call this API if the <em>channel</em> is set to Pattern mode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga973af2e272600c5eeb163ee83579c738">XMC_DAC_CH_EnablePatternSignOutput()</a>, <a class="el" href="group___d_a_c.html#ga1b40c57534700d37e8b70c2ea2f2eea3">XMC_DAC_CH_DisablePatternSignOutput()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga592cefaf4c5cc8e2cd83a1fa5472845d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga592cefaf4c5cc8e2cd83a1fa5472845d">&#9670;&nbsp;</a></span>XMC_DAC_CH_SetPatternFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a> XMC_DAC_CH_SetPatternFrequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number </td></tr>
    <tr><td class="paramname">frequency</td><td>in [Hz]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_DAC_CH_STATUS_t</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the <em>frequency</em> of DAC channel by calling <a class="el" href="group___d_a_c.html#gacdcfe6cd44bef3ebd95f96998604fec1">XMC_DAC_CH_SetFrequency()</a>.</dd></dl>
<dl class="section user"><dt></dt><dd>For the Pattern mode, the <em>frequency</em> of operation depends on the total number of sample points <em>XMC_DAC_SAMPLES_PER_PERIOD</em>. Frequency <em>frequency</em> is multiplied by the total number of sample points, so that each trigger instance converts all the sample points of the pattern.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Call this API only if the <em>channel</em> is set to Pattern mode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga9c8c3079b34269e1190e067c34a55f48">XMC_DAC_CH_StartPatternMode()</a><br />
<br />
<br />
</dd></dl>
<p>&lt; DAC samples per period in pattern mode </p>

</div>
</div>
<a id="gabdf995111daf8c4495bf1d2ef2ce58e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdf995111daf8c4495bf1d2ef2ce58e3">&#9670;&nbsp;</a></span>XMC_DAC_CH_SetRampFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a> XMC_DAC_CH_SetRampFrequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number </td></tr>
    <tr><td class="paramname">frequency</td><td>[Hz]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_DAC_CH_STATUS_t</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the <em>frequency</em> of DAC channel by calling <a class="el" href="group___d_a_c.html#gacdcfe6cd44bef3ebd95f96998604fec1">XMC_DAC_CH_SetFrequency()</a>.</dd></dl>
<dl class="section user"><dt></dt><dd>For the Ramp mode, the <em>frequency</em> of operation depends on the total number of sample points (<em>stop</em> - <em>start</em>). Frequency <em>frequency</em> is multiplied by the total number of sample points, so that each trigger instance converts all the sample points of ramp.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Call this API only if the <em>channel</em> is set to Ramp mode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga1301e3dd09e47e4e81934de759675230">XMC_DAC_CH_StartRampMode()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gaf692f5b60cf4c74192b554ec88254aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf692f5b60cf4c74192b554ec88254aab">&#9670;&nbsp;</a></span>XMC_DAC_CH_SetRampStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_SetRampStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number </td></tr>
    <tr><td class="paramname">start</td><td>Ramp start point [0-4095]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the ramp start value by writing to the register <em>DAC0DATA</em> (for <em>channel</em> 0) or <em>DAC1DATA</em> (for <em>channel</em> 1). If the ramp counter reaches its stop value, it restarts from the <em>start</em> value with the next trigger pulse. Ensure <em>start</em> value is lower than the stop value.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Call this API if the <em>channel</em> is set to Ramp mode. Start value is a 12 bit data.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga3cd25ca6afe7a138dcb5bb42c449db0f">XMC_DAC_CH_GetRampStart()</a>, <a class="el" href="group___d_a_c.html#ga5dd54e68ac3b4403aa5ba432f545f02e">XMC_DAC_CH_GetRampStop()</a>, <a class="el" href="group___d_a_c.html#gafe44b3910c68e67808aa372a4c6c86ce">XMC_DAC_CH_SetRampStop()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gafe44b3910c68e67808aa372a4c6c86ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe44b3910c68e67808aa372a4c6c86ce">&#9670;&nbsp;</a></span>XMC_DAC_CH_SetRampStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_SetRampStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number </td></tr>
    <tr><td class="paramname">stop</td><td>Ramp stop point [0-4095]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the ramp stop value by writing to the bit-field <em>DATA0</em> (for <em>channel</em> 0) or <em>DATA1</em> (for <em>channel</em> 1) of <em>DAC01DATA</em> register. If the ramp counter reaches its <em>stop</em> value, it restarts from the start value with the next trigger pulse. Ensure <em>stop</em> value is higher than the start value.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Call this API if the <em>channel</em> is set to Ramp mode. Stop value is a 12 bit data.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga5dd54e68ac3b4403aa5ba432f545f02e">XMC_DAC_CH_GetRampStop()</a>, <a class="el" href="group___d_a_c.html#gaf692f5b60cf4c74192b554ec88254aab">XMC_DAC_CH_SetRampStart()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga5b0260c72dc3e2772c589ec48ffd2c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b0260c72dc3e2772c589ec48ffd2c80">&#9670;&nbsp;</a></span>XMC_DAC_CH_SetSignedDataType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_SetSignedDataType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the <em>channel's</em> data to signed type by setting <em>SIGN</em> bit of <em>DAC0CFG0</em> register (for channel 0) / <em>DAC1CFG0</em> register (for channel 1). The data for the conversion would then be treated as signed data type.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Offset and scaling can be applied to the data by calling <a class="el" href="group___d_a_c.html#ga1e1f75defe221c0db5b4133ca927e574">XMC_DAC_CH_SetOutputOffset()</a>, <a class="el" href="group___d_a_c.html#gabc5544309ce97e7edf14b950e72ffa3d">XMC_DAC_CH_SetOutputScale()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#gae4aae1cc510efc383a66eb5c9d258769">XMC_DAC_CH_SetUnsignedDataType()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gac96c41befd18976b555d134013f231c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac96c41befd18976b555d134013f231c3">&#9670;&nbsp;</a></span>XMC_DAC_CH_SetTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_SetTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___d_a_c.html#ga9176e4c7b167ec22b5673e05ade18eba">XMC_DAC_CH_TRIGGER_t</a>&#160;</td>
          <td class="paramname"><em>trigger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number </td></tr>
    <tr><td class="paramname">trigger</td><td>Trigger source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Selects the <em>trigger</em> source for the <em>channel</em> by configuring the bits TRIGSEL &amp; TRIGMOD of CFG register.</dd></dl>
<dl class="section user"><dt></dt><dd>Channel <em>channel</em> trigger source is selected by <em>TRIGSEL</em> bit-field of <em>DAC0CFG1</em> register (for channel 0) / DAC1CFG1 register(for channel 1). </dd></dl>

</div>
</div>
<a id="gae4aae1cc510efc383a66eb5c9d258769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4aae1cc510efc383a66eb5c9d258769">&#9670;&nbsp;</a></span>XMC_DAC_CH_SetUnsignedDataType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_SetUnsignedDataType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the <em>channel's</em> data to unsigned type by clearing <em>SIGN</em> bit of <em>DAC0CFG0</em> register (for channel 0) / <em>DAC1CFG0</em> register (for channel 1). The data for the conversion would then be treated as unsigned data type.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Offset and scaling can be applied to the data by calling <a class="el" href="group___d_a_c.html#ga1e1f75defe221c0db5b4133ca927e574">XMC_DAC_CH_SetOutputOffset()</a>, <a class="el" href="group___d_a_c.html#gabc5544309ce97e7edf14b950e72ffa3d">XMC_DAC_CH_SetOutputScale()</a>.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga5b0260c72dc3e2772c589ec48ffd2c80">XMC_DAC_CH_SetSignedDataType()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga9620b8278dcabb391d7cf8b2b69f8311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9620b8278dcabb391d7cf8b2b69f8311">&#9670;&nbsp;</a></span>XMC_DAC_CH_SoftwareTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_SoftwareTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>A call to this API generates a trigger pulse by setting <em>SWTRIG</em> bit of <em>DAC0CFG1</em> register (for channel 0) / <em>DAC1CFG1</em> register (for channel 1), provided the <em>TRIGMOD</em> bit of CFG register is set to <em>XMC_DAC_CH_TRIGGER_SOFTWARE</em>.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>If the <em>channel</em> is set to simultaneous data mode, SWTRIG bit of <em>channel</em> 1 is not valid. Only <em>SWTRIG</em> bit of channel 0 is used for channel 1.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#gac96c41befd18976b555d134013f231c3">XMC_DAC_CH_SetTrigger()</a>, <a class="el" href="group___d_a_c.html#gac2e2a705070f03534b1b91ea873b0aab">XMC_DAC_CH_EnableEvent()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga34d4edcff18efbc8893148120362a589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34d4edcff18efbc8893148120362a589">&#9670;&nbsp;</a></span>XMC_DAC_CH_StartDataMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a> XMC_DAC_CH_StartDataMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___d_a_c.html#ga9176e4c7b167ec22b5673e05ade18eba">XMC_DAC_CH_TRIGGER_t</a>&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number </td></tr>
    <tr><td class="paramname">trigger</td><td>Data points update trigger </td></tr>
    <tr><td class="paramname">frequency</td><td>Waveform frequency [Hz]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_DAC_CH_STATUS_t status</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the <em>channel</em> to Data mode. Trigger and frequency are configured.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Call <a class="el" href="group___d_a_c.html#ga8e3093f1aa4f47b0793ea0e992580040">XMC_DAC_CH_Write()</a> API to write the data. Call <a class="el" href="group___d_a_c.html#ga4c81d639c99a26cebaeea3b20947a15c">XMC_DAC_EnableSimultaneousDataMode()</a> to switch to Simultaneous data mode.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga94d6569836131b45c58c039fd2fa6a04">XMC_DAC_CH_Init()</a>, <a class="el" href="group___d_a_c.html#ga8e3093f1aa4f47b0793ea0e992580040">XMC_DAC_CH_Write()</a>, <a class="el" href="group___d_a_c.html#ga4c81d639c99a26cebaeea3b20947a15c">XMC_DAC_EnableSimultaneousDataMode()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga8cdc0d2ae0c0d3e0ad8ed6babcbd4c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cdc0d2ae0c0d3e0ad8ed6babcbd4c04">&#9670;&nbsp;</a></span>XMC_DAC_CH_StartNoiseMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a> XMC_DAC_CH_StartNoiseMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___d_a_c.html#ga9176e4c7b167ec22b5673e05ade18eba">XMC_DAC_CH_TRIGGER_t</a>&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number </td></tr>
    <tr><td class="paramname">trigger</td><td>Data points update trigger </td></tr>
    <tr><td class="paramname">frequency</td><td>Waveform frequency in [Hz]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_DAC_CH_STATUS_t status</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the <em>channel</em> to Noise mode. Trigger and frequency are configured. On a <em>trigger</em> the DAC starts converting and drives to <em>channel</em> output.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga94d6569836131b45c58c039fd2fa6a04">XMC_DAC_CH_Init()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga9c8c3079b34269e1190e067c34a55f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c8c3079b34269e1190e067c34a55f48">&#9670;&nbsp;</a></span>XMC_DAC_CH_StartPatternMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a> XMC_DAC_CH_StartPatternMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___d_a_c.html#gaf1e4fb1ca9c2bad0de893feee98e6228">XMC_DAC_CH_PATTERN_SIGN_OUTPUT_t</a>&#160;</td>
          <td class="paramname"><em>sign_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___d_a_c.html#ga9176e4c7b167ec22b5673e05ade18eba">XMC_DAC_CH_TRIGGER_t</a>&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number </td></tr>
    <tr><td class="paramname">pattern</td><td>Data table of a pattern </td></tr>
    <tr><td class="paramname">sign_output</td><td>Sign information of the waveform </td></tr>
    <tr><td class="paramname">trigger</td><td>Data points update trigger </td></tr>
    <tr><td class="paramname">frequency</td><td>Waveform frequency in [Hz]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_DAC_CH_STATUS_t status</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the <em>channel</em> to Pattern mode. Trigger, frequency, sign output and data are configured. On a <em>trigger</em>, the <em>pattern</em> values are converted and driven to <em>channel</em> output.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga94d6569836131b45c58c039fd2fa6a04">XMC_DAC_CH_Init()</a>, <a class="el" href="group___d_a_c.html#ga1b40c57534700d37e8b70c2ea2f2eea3">XMC_DAC_CH_DisablePatternSignOutput()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga1301e3dd09e47e4e81934de759675230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1301e3dd09e47e4e81934de759675230">&#9670;&nbsp;</a></span>XMC_DAC_CH_StartRampMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a> XMC_DAC_CH_StartRampMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___d_a_c.html#ga9176e4c7b167ec22b5673e05ade18eba">XMC_DAC_CH_TRIGGER_t</a>&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number </td></tr>
    <tr><td class="paramname">start</td><td>Start point of the ramp [0-4095] </td></tr>
    <tr><td class="paramname">stop</td><td>Stop point of the ramp [0-4095] </td></tr>
    <tr><td class="paramname">trigger</td><td>Data points update trigger </td></tr>
    <tr><td class="paramname">frequency</td><td>Ramp frequency in [Hz]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_DAC_CH_STATUS_t status</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the <em>channel</em> to Ramp mode. Trigger, frequency, start and stop values are configured. On a <em>trigger</em> ramp values are converted and driven to <em>channel</em> output. Start and stop have the range of [0-4095]. Stop should be equal or greater than start.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>If the ramp counter reaches its <em>stop</em> value, it restarts from the <em>start</em> value with the next trigger pulse.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga94d6569836131b45c58c039fd2fa6a04">XMC_DAC_CH_Init()</a>, <a class="el" href="group___d_a_c.html#ga3cd25ca6afe7a138dcb5bb42c449db0f">XMC_DAC_CH_GetRampStart()</a>, <a class="el" href="group___d_a_c.html#ga5dd54e68ac3b4403aa5ba432f545f02e">XMC_DAC_CH_GetRampStop()</a> <br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga6c8a12197978db3edc3216444faee6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c8a12197978db3edc3216444faee6b8">&#9670;&nbsp;</a></span>XMC_DAC_CH_StartSingleValueMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___d_a_c.html#ga4e37be380b4227fc103ef44c765f2d4d">XMC_DAC_CH_STATUS_t</a> XMC_DAC_CH_StartSingleValueMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Sets the <em>channel</em> to Single Value Mode by calling <a class="el" href="group___d_a_c.html#ga1774217be659f37d640d13d48816762f">XMC_DAC_CH_SetMode()</a>.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Call <a class="el" href="group___d_a_c.html#ga8e3093f1aa4f47b0793ea0e992580040">XMC_DAC_CH_Write()</a> API to write the data.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga8e3093f1aa4f47b0793ea0e992580040">XMC_DAC_CH_Write()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga8e3093f1aa4f47b0793ea0e992580040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e3093f1aa4f47b0793ea0e992580040">&#9670;&nbsp;</a></span>XMC_DAC_CH_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_CH_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">channel</td><td>DAC channel number </td></tr>
    <tr><td class="paramname">data</td><td>Data to be written [0-4095]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Writes the <em>data</em> to the <em>channel's</em> DATA register.</dd></dl>
<dl class="section user"><dt></dt><dd>The <em>data</em> is then converted and driven to the output. If the trigger is set, On a trigger event the data in DATA register is converted and driven to <em>channel</em> output. Data <em>data</em> is written to the <em>channel</em> by loading <em>data</em> to <em>DATA0</em> bit-field of <em>DAC0DATA</em> (for channel 0) / <em>DATA1</em> bit-field of <em>DAC1DATA</em> register (for channel 1). data has the range of [0-4095].</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>The API can be used for Single Value Mode, Data Mode (Individual) &amp; Ramp Mode. Call <a class="el" href="group___d_a_c.html#gaf3fe5631a70e40f4d25c473b553ed5af">XMC_DAC_CH_EnableOutput()</a> API to enable analog output.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga6c8a12197978db3edc3216444faee6b8">XMC_DAC_CH_StartSingleValueMode()</a>, <a class="el" href="group___d_a_c.html#ga34d4edcff18efbc8893148120362a589">XMC_DAC_CH_StartDataMode()</a>, <a class="el" href="group___d_a_c.html#ga1301e3dd09e47e4e81934de759675230">XMC_DAC_CH_StartRampMode()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga67de176f36749cba8a65ad1b9815f0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67de176f36749cba8a65ad1b9815f0dd">&#9670;&nbsp;</a></span>XMC_DAC_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Disables DAC clock and resets DAC.</dd></dl>
<dl class="section user"><dt></dt><dd>DAC clock is disabled by setting <em>DAC</em> bit of <em>CGATSET1</em> register. DAC is reset by setting <em>DACRS</em> bit of <em>PRSET1</em> register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#gafdcd0136ab6dfc0d98d463136765ab69">XMC_DAC_IsEnabled()</a>, <a class="el" href="group___d_a_c.html#gab97383cd03ebb21046c403c5c835f55c">XMC_DAC_Enable()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gab9668535a4a093bd1a3eb36cbc474a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9668535a4a093bd1a3eb36cbc474a9f">&#9670;&nbsp;</a></span>XMC_DAC_DisableSimultaneousDataMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_DisableSimultaneousDataMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>DAC switches to independent data mode from simultaneous Data mode.</dd></dl>
<dl class="section user"><dt></dt><dd>Independent data mode is the default data mode. Simultaneous data mode is disabled by clearing <em>DATMOD</em> bit of <em>DAC0CFG1</em> register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga34d4edcff18efbc8893148120362a589">XMC_DAC_CH_StartDataMode()</a>, <a class="el" href="group___d_a_c.html#ga4c81d639c99a26cebaeea3b20947a15c">XMC_DAC_EnableSimultaneousDataMode()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gab97383cd03ebb21046c403c5c835f55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab97383cd03ebb21046c403c5c835f55c">&#9670;&nbsp;</a></span>XMC_DAC_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Enables DAC clock and releases DAC reset.<br />
</dd></dl>
<dl class="section user"><dt></dt><dd>Enabling DAC is the first step of DAC initialisation. This API is called by <a class="el" href="group___d_a_c.html#ga94d6569836131b45c58c039fd2fa6a04">XMC_DAC_CH_Init()</a>. DAC clock is enabled by setting <em>DAC</em> bit of <em>CGATCLR1</em> register. DAC reset is released by setting <em>DACRS</em> bit of <em>PRCLR1</em> register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#gafdcd0136ab6dfc0d98d463136765ab69">XMC_DAC_IsEnabled()</a>, <a class="el" href="group___d_a_c.html#ga67de176f36749cba8a65ad1b9815f0dd">XMC_DAC_Disable()</a>, <a class="el" href="group___d_a_c.html#ga94d6569836131b45c58c039fd2fa6a04">XMC_DAC_CH_Init()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga4c81d639c99a26cebaeea3b20947a15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c81d639c99a26cebaeea3b20947a15c">&#9670;&nbsp;</a></span>XMC_DAC_EnableSimultaneousDataMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_EnableSimultaneousDataMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>DAC switches to Simultaneous data mode from Independent data mode.</dd></dl>
<dl class="section user"><dt></dt><dd>Independent data mode is the default data mode. Simultaneous data mode is enabled by setting <em>DATMOD</em> bit of <em>DAC0CFG1</em> register.</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Set channel 0 and channel 1 to Data mode before calling this API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga6c8a12197978db3edc3216444faee6b8">XMC_DAC_CH_StartSingleValueMode()</a>, <a class="el" href="group___d_a_c.html#ga34d4edcff18efbc8893148120362a589">XMC_DAC_CH_StartDataMode()</a>, <a class="el" href="group___d_a_c.html#ga81b11cead3aaabed68b046d40628f89d">XMC_DAC_SimultaneousWrite()</a>, <a class="el" href="group___d_a_c.html#gab9668535a4a093bd1a3eb36cbc474a9f">XMC_DAC_DisableSimultaneousDataMode()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="gafdcd0136ab6dfc0d98d463136765ab69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdcd0136ab6dfc0d98d463136765ab69">&#9670;&nbsp;</a></span>XMC_DAC_IsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_DAC_IsEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool<br />
 true - if DAC is enabled<br />
 false - if DAC is disabled</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Returns the state of the DAC.</dd></dl>
<dl class="section user"><dt></dt><dd>DAC enabled status is determined by referring to <em>DACRS</em> bit of <em>PRSTAT1</em> register.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#gab97383cd03ebb21046c403c5c835f55c">XMC_DAC_Enable()</a>, <a class="el" href="group___d_a_c.html#ga67de176f36749cba8a65ad1b9815f0dd">XMC_DAC_Disable()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
<a id="ga81b11cead3aaabed68b046d40628f89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81b11cead3aaabed68b046d40628f89d">&#9670;&nbsp;</a></span>XMC_DAC_SimultaneousWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_DAC_SimultaneousWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_m_c___d_a_c__t.html">XMC_DAC_t</a> *const&#160;</td>
          <td class="paramname"><em>dac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>data0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>data1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dac</td><td>Pointer to an instance of DAC module </td></tr>
    <tr><td class="paramname">data0</td><td>Data for DAC channel 0 [0-4095] </td></tr>
    <tr><td class="paramname">data1</td><td>Data for DAC channel 1 [0-4095]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>The data (<em>data0</em> &amp; <em>data1</em>) to be converted by channel 0 &amp; channel 1 are updated to <em>DATA1</em> bit-fields of <em>DAC01DATA</em> register. data0 and data1 have the range of [0-4095].</dd></dl>
<dl class="section user"><dt>Note:</dt><dd>Channel 0 and Channel 1 should be set to simultaneous data mode before calling this API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___d_a_c.html#ga4c81d639c99a26cebaeea3b20947a15c">XMC_DAC_EnableSimultaneousDataMode()</a><br />
<br />
<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>XMC Peripheral Library for XMC4000 Family</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
