<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XMC Peripheral Library for XMC4000 Family: Personalities Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC Peripheral Library for XMC4000 Family</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_personalities_reference.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Personalities Reference </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The XMC Peripheral Library includes a set of files to enable the ModusToolbox&trade; Device Configurator functionality. These files are known as personalities and describe the user interface for the Device Configurator in the xml format. Based on the user settings, personalities generate initialization code (the configuration structures and initialization API calls), which is executed within the init_cycfg_all() function. The init_cycfg_all() is usually executed within the cybsp_init() function, or may be called directly in the main() function by the user. The system clock personalities generate a strong definition of the SystemCoreClockSetup() function, which is executed at a startup (before jumping to main.c, not within the init_cycfg_all() unlike other ModusToolbox&trade; PDL products).</p>
<h1><a class="anchor" id="section_personality_advanced_settings"></a>
Advanced Settings</h1>
<p>Most of the personalities have several common parameters located in the Advanced Settings group:</p>
<ul>
<li><b>Start After Initialization:</b> if enabled, the peripheral will start at the end of the peripheral initialization.</li>
<li><b>Store Config in Flash:</b> controls whether the configuration structure is stored in flash (const, true) or SRAM (not const, false).</li>
</ul>
<h1><a class="anchor" id="section_personality_ccu4"></a>
CCU4 Personality</h1>
<p>There are two major revisions: 1.0 and 2.0</p>
<p>The CCU4 1.0 is legacy and contains old-style EVENT_HANDLER definitions, which are deprecated and not recommended for usage in new applications.</p>
<p>It is left in the XMCLib for the backward compatibility with already created projects that the user does not want to update.</p>
<p>This support will be removed in the next major XMCLib revision.</p>
<p>The CCU4 2.0 is almost the same as 1.0 but without the deprecated items, so it is recommended for new applications.</p>
<h2><a class="anchor" id="subsection_ccu_codeGen"></a>
Code Generation</h2>
<p>Instead of the deprecated items, modern INTERRUPT_HANDLER definitions are generated that are recommended for usage in applications:</p>
<div class="image">
<img src="ccu4_sr0_setting.png" alt="ccu4_sr0_setting.png"/>
</div>
 <div class="image">
<img src="ccu4_sr0_handler.png" alt="ccu4_sr0_handler.png"/>
</div>
<p> Then, these definitions can be used in the application code, for example for the xmc4xxx devices: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyCCU4_SR0_INTERRUPT_HANDLER(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___c_c_u4.html#ga40dd61be60dc66c77164829280181e90">XMC_CCU4_SLICE_ClearEvent</a>(MyCCU4Slice_HW, <a class="code" href="group___c_c_u4.html#gga9b6b22c75755089c6c4038de4a5d213ca1110754891260f416e50d1ad2bb30930">XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH</a>);</div><div class="line">}</div></div><!-- fragment --><p>and for enabling the CCU4 interrupt before starting the block: </p><div class="fragment"><div class="line">    NVIC_EnableIRQ(MyCCU4_SR0_IRQN);</div><div class="line">    <a class="code" href="group___c_c_u4.html#ga9997bb59706a4034e3e3be33a4935a7c">XMC_CCU4_SLICE_StartTimer</a>(MyCCU4Slice_HW);</div></div><!-- fragment --><p> Refer to the API reference <a class="el" href="group___c_c_u4.html">Capture Compare Unit 4(CCU4)</a> for the API details.</p>
<p>Refer to the device Datasheet and Reference Manual for the HW details.</p>
<h1><a class="anchor" id="section_personality_dsd"></a>
DSD Personality</h1>
<p>The general DSD block configuration structure: </p><div class="image">
<img src="dsd_settings_general.png" alt="dsd_settings_general.png"/>
</div>
<p>The single channel GUI configurates a separate DSD channel: </p><div class="image">
<img src="dsd_configuration_advanced.png" alt="dsd_configuration_advanced.png"/>
</div>
<p> The Trigger (Integrator) settings are available for Advanced Preconfiguration Mode only.</p>
<h2><a class="anchor" id="subsection_dsd_codeGen"></a>
Code Generation</h2>
<p>Note that all the public generated code items are prefixed with the name given in the Device Configurator: </p><div class="image">
<img src="dsd_instName.png" alt="dsd_instName.png"/>
</div>
<p> The personality generates a base address, channel ID, and interrupt-related macros that can be used in the application code: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyDSD_MAIN_FILTER_INTERRUPT_HANDLER(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___d_s_d.html#gac3e92415ba18b5bcedb454bc02409631">XMC_DSD_ClearResultEventFlag</a>(MyDSD_HW, MyDSD_CH_ID);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyDSD_AUX_FILTER_INTERRUPT_HANDLER(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___d_s_d.html#ga14280e89324e1fb9adaa379d8e10b9fa">XMC_DSD_ClearAlarmEventFlag</a>(MyDSD_HW, MyDSD_CH_ID);</div><div class="line">}</div></div><!-- fragment --><p>and then, for enabling the DSD interrupts and starting the block itself: </p><div class="fragment"><div class="line">    NVIC_EnableIRQ(MyDSD_MAIN_FILTER_IRQN);</div><div class="line">    NVIC_EnableIRQ(MyDSD_AUX_FILTER_IRQN);</div><div class="line">    <a class="code" href="group___d_s_d.html#gaf8ff4a18539762c79d68125f7298ccfe">XMC_DSD_Start</a>(MyDSD_HW, MyDSD_CH_ID);</div></div><!-- fragment --><p> Refer to the API reference <a class="el" href="group___d_s_d.html">Delta Sigma Demodulator (DSD)</a> for the API details.</p>
<p>Refer to the device Datasheet and Reference Manual for the HW details.</p>
<h1><a class="anchor" id="section_personality_hrpwm"></a>
HRPWM Personality</h1>
<h2><a class="anchor" id="subsection_personality_hrpwm_csg"></a>
Comparator &amp; Slope Generation Unit (CSG)</h2>
<p>The personality provides the following functionalities using the CSG peripheral:</p><ol type="1">
<li>Inverting the comparator output.</li>
<li>Blanking the comparator output.</li>
<li>Clamping the comparator output.</li>
<li>Slope generation in Decrementing mode.</li>
<li>Slope generation in Incrementing mode.</li>
<li>Slope generation in Triangle mode.</li>
<li>Updating the slope start and stop value.</li>
</ol>
<h2><a class="anchor" id="subsection_personality_hrpwm_hrc"></a>
High Resolution Channel (HRC)</h2>
<p>The personality provides the following functionalities using the CCU8 and HRC peripherals:</p><ol type="1">
<li>PWM signal generation on the selected port pins.</li>
<li>Setting the required frequency of operation and initial duty cycle with the high-resolution positioning.</li>
<li>Start the PWM unit after initialization or at a later time as required.</li>
<li>Operate the PWM in Single shot or Continuous mode.</li>
<li>Start multiple timers in the kernel synchronously.</li>
<li>Generate PWM in Edge/Center aligned, Symmetric/Asymmetric mode.</li>
<li>Select the passive state of the output.</li>
<li>Connect up-to-three external event signals. The following functions can be implemented:<ul>
<li>External Start</li>
<li>External Stop</li>
<li>External Count Direction</li>
<li>External Gating</li>
<li>External Count</li>
<li>External Load</li>
<li>External Modulation</li>
<li>External Override (Level)</li>
<li>External Trap</li>
</ul>
</li>
<li>Enable the period match or compare match events.</li>
<li>Generate dead time between complementary outputs.</li>
<li>Generate up-to-two PWMs with CCU8 and HRC slices.</li>
</ol>
<p>The next figure shows the functional overview of the PWM generation. The period match (PM) value is calculated based on the frequency and the compare match (CM) is calculated based on the duty cycle. The PWM state changes at the period and compare matches. </p><div class="image">
<img src="hrpwm_overview.png" alt="hrpwm_overview.png"/>
<div class="caption">
Overview of PWM generation</div></div>
 <h2><a class="anchor" id="subsection_personality_hrpwm_edge_symmetric"></a>
CCU8 in Edge Aligned Symmetric Mode of Operation</h2>
<p>In this mode, we can use the 2 compare registers to generate 2 pairs of complementary outputs, which means a total of 4 outputs. The minimum duty that can be generated is 0% and the maximum is 100%. Here, the output is initially LOW until a compare match occurs. The output remains HIGH until a next match occurs. </p><div class="image">
<img src="hrpwm_edge_symmetric.png" alt="hrpwm_edge_symmetric.png"/>
<div class="caption">
CCU8 in Edge Aligned Symmetric Mode</div></div>
<p> <b>Example with XMC4400:</b></p>
<p>\( Clock = 120MHz. \)</p>
<p>\( Prescaler = 0. \)</p>
<p>\( Required\:frequency\:of\:operation\:(F) = 100KHz. \)</p>
<p>\( Duty\:required\:(D) = 30\%. \)</p>
<p>\( Period = \frac{Clock}{(1 \texttt{&lt;&lt;} Prescaler) \cdot F} \)</p>
<p>\( Cmp_{reg} = \frac{Period \cdot (100 - D)}{100} \)</p>
<p>\( Period = \frac{120,000,000}{(1 \texttt{&lt;&lt;} 0) \cdot 100,000} \)</p>
<p>\( Period = 1200 \) &ensp; Note: The value loaded to period register is \( (Period - 1) \), i.e. \( 1199. \)</p>
<p>\( Cmp_{reg} = \frac{1200 \cdot (100 - 30)}{100} \)</p>
<p>\( Cmp_{reg} = 840 \) <br />
 <br />
 </p>
<h2><a class="anchor" id="subsection_personality_hrpwm_center_symmetric"></a>
CCU8 in Center Aligned Symmetric Mode of Operation</h2>
<p>In this mode, we can use the 2 compare registers to generate 2 pairs of complementary outputs, which means a total of 4 outputs. The minimum duty that can be generated is 0% and the maximum is 100%. Here, the output is initially LOW. When a compare match occurs during the timer up-counting, the output is set HIGH. The output remains HIGH until a compare match occurs again during the timer down-counting. Here, we can see that the ON time of channel 1 and channel 2 are aligned to the time period center. </p><div class="image">
<img src="hrpwm_center_symmetric.png" alt="hrpwm_center_symmetric.png"/>
<div class="caption">
CCU8 in Center Aligned Symmetric Mode</div></div>
<p> <b>Example with XMC4400:</b></p>
<p>\( Clock = 120MHz. \)</p>
<p>\( Prescaler = 0. \)</p>
<p>\( Required\:frequency\:of\:operation\:(F) = 100KHz. \)</p>
<p>\( Duty\:required\:(D) = 30\%. \)</p>
<p>\( Period = \frac{Clock}{(1 \texttt{&lt;&lt;} Prescaler) \cdot 2F} \)</p>
<p>\( Cmp_{reg} = \frac{Period \cdot (100 - D)}{100} \)</p>
<p>\( Period = \frac{120,000,000}{(1 \texttt{&lt;&lt;} 0) \cdot 2 \cdot 100,000} \)</p>
<p>\( Period = 600 \) &ensp; Note: The value loaded to period register is \( (Period - 1) \), i.e. \( 599. \)</p>
<p>\( Cmp_{reg} = \frac{600 \cdot (100 - 30)}{100} \)</p>
<p>\( Cmp_{reg} = 420 \) <br />
 <br />
 </p>
<h2><a class="anchor" id="subsection_personality_hrpwm_edge_asymmetric"></a>
CCU8 in Edge Aligned Asymmetric Mode of Operation</h2>
<p>In this mode, we can use the 2 compare registers to generate 1 pair of complementary outputs, which means a total of 2 outputs. The minimum duty that can be generated is 0% and the maximum is 100%. Here, the output remains LOW until a channel 1 compare match occurs. This duration can be called "shift". The output remains HIGH until a channel 2 compare match occurs. This duration is determined by the duty. The condition is that the channel 2 register value is required to be greater that the channel 1 register value. This allows us to place the ON time anywhere in the time period, as long as the limiting conditions are met. </p><div class="image">
<img src="hrpwm_edge_asymmetric.png" alt="hrpwm_edge_asymmetric.png"/>
<div class="caption">
CCU8 in Edge Aligned Asymmetric Mode</div></div>
<p> <b>Example with XMC4400:</b></p>
<p>\( Clock = 120MHz. \)</p>
<p>\( Prescaler = 0. \)</p>
<p>\( Required\:frequency\:of\:operation\:(F) = 100KHz. \)</p>
<p>\( Shift\:required\:(S) = 40\%. \)</p>
<p>\( Duty\:required\:(D) = 30\%. \)</p>
<p>\( Period = \frac{Clock}{(1 \texttt{&lt;&lt;} Prescaler) \cdot F} \)</p>
<p>\( Cmp_{reg1} = \frac{Period \cdot S}{100} \)</p>
<p>\( Cmp_{reg2} = \frac{Period \cdot (S + D)}{100} \)</p>
<p>\( Period = \frac{120,000,000}{(1 \texttt{&lt;&lt;} 0) \cdot 100,000} \)</p>
<p>\( Period = 1200 \) &ensp; Note: The value loaded to period register is \( (Period - 1) \), i.e. \( 1199. \)</p>
<p>\( Cmp_{reg1} = \frac{1200 \cdot 40}{100} \)</p>
<p>\( Cmp_{reg1} = 480 \)</p>
<p>\( Cmp_{reg2} = \frac{1200 \cdot (40 + 30)}{100} \)</p>
<p>\( Cmp_{reg2} = 840 \) <br />
 <br />
 </p>
<h2><a class="anchor" id="subsection_personality_hrpwm_center_asymmetric"></a>
CCU8 in Center Aligned Asymmetric Mode of Operation</h2>
<p>In this mode, we can use the 2 compare registers to generate 1 pair of complementary outputs, which means a total of 2 outputs. The minimum duty that can be generated is 0% and the maximum is 100%. Here, the output remains LOW until a channel 1 compare match occurs in the timer up-counting. This duration can be called "shift". The output remains HIGH until a channel 2 compare match occurs during the timer down-counting. This duration is determined by the duty. </p><div class="image">
<img src="hrpwm_center_asymmetric.png" alt="hrpwm_center_asymmetric.png"/>
<div class="caption">
CCU8 in Center Aligned Asymmetric Mode</div></div>
<p> <b>Example with XMC4400:</b></p>
<p>\( Clock = 120MHz. \)</p>
<p>\( Prescaler = 0. \)</p>
<p>\( Required\:frequency\:of\:operation\:(F) = 100KHz. \)</p>
<p>\( Shift\:required\:(S) = 40\%. \)</p>
<p>\( Duty\:required\:(D) = 40\%. \)</p>
<p>\( Period = \frac{Clock}{(1 \texttt{&lt;&lt;} Prescaler) \cdot 2F} \)</p>
<p>\( Cmp_{reg1} = \frac{2 \cdot Period \cdot S}{100} \)</p>
<p>\( Cmp_{reg2} = \frac{2 \cdot Period \cdot (100 - (S + D))}{100} \)</p>
<p>\( Period = \frac{120,000,000}{(1 \texttt{&lt;&lt;} 0) \cdot 2 \cdot 100,000} \)</p>
<p>\( Period = 600 \) &ensp; Note: The value loaded to period register is \( (Period - 1) \), i.e. \( 599. \)</p>
<p>\( Cmp_{reg1} = \frac{2 \cdot 600 \cdot 40}{100} \)</p>
<p>\( Cmp_{reg1} = 480 \)</p>
<p>\( Cmp_{reg2} = \frac{2 \cdot 600 \cdot (40 + 40)}{100} \)</p>
<p>\( Cmp_{reg2} = 480 \) <br />
 <br />
 </p>
<h2><a class="anchor" id="subsection_personality_hrpwm_ccu8"></a>
CCU8 with HRPWM Mode of Operation</h2>
<div class="image">
<img src="hrpwm_ccu8.png" alt="hrpwm_ccu8.png"/>
<div class="caption">
CCU8</div></div>
<p> <b>Example with XMC4400:</b></p>
<p>\( Period = 10. \)</p>
<p>\( Duty\:required\:(D) = 60\%. \)</p>
<p>\( Cmp_{reg} = \frac{Period \cdot (100 - D)}{100} \)</p>
<p>\( Cmp_{reg} = \frac{10 \cdot (100 - 60)}{100} \)</p>
<p>\( Cmp_{reg} = 4 \)</p>
<p>Now let us say:</p>
<p>\( Duty\:required\:(D) = 65\%. \)</p>
<p>\( Cmp_{reg} = \frac{10 \cdot (100 - 65)}{100} = 3.5 &cong; 3 \)</p>
<p>With compare register 3, we get a duty of 70%. Therefore, we are not able to get a duty of 65% with a period of 10. Hence, need to use the HRPWM module. </p><div class="image">
<img src="hrpwm_ccu8_hi_res.png" alt="hrpwm_ccu8_hi_res.png"/>
<div class="caption">
CCU8 with HRPWM</div></div>
<p> The CCU8 output is fed to the HRPWM module. The HRPWM module has two registers - CR1 and CR2. CR1 delays the rising edge of the output, whereas CR2 extends the falling edge of the output. The High Resolution module has a resolution of 150 Pico second. We can achieve the positioning of the output in the step of 150ps. Thus, by configuring the CR1, CR2 registers we can achieve finer generation of the shift and duty. Refer to the reference manual to determine the minimum and maximum duty cycle feasible with the HRPWM module.</p>
<p>Refer to the API reference <a class="el" href="group___h_r_p_w_m.html">High Resolution PWM Unit (HRPWM)</a> for the API details.</p>
<p>Refer to the device Datasheet and Reference Manual for the HW details.</p>
<h1><a class="anchor" id="section_personality_posif"></a>
POSIF Personality</h1>
<h2><a class="anchor" id="subsection_personality_posif_qd"></a>
Quadrature Decoder Mode</h2>
<p>Quadrature Decoder mode is used to find the position and speed of the motor using the incremental encoder. The profile is designed so that it can estimate the angle by consuming 3 CCU4 slices and an optional CCU4 slice along with POSIF and its interconnections.</p>
<p>Four CCU4 slices are consumed for the following purposes:</p><ol type="1">
<li>Position Counter - set the slice to be in Counter mode, which starts ticking based on encoder pulses to provide the absolute position:<ul>
<li>Connect the Status Signal of the Position Counter CCU4 to an optional Revolution Counter CCU4 slice Event 0 Input Signal.</li>
<li>Set the Count Function of the Revolution Counter CCU4 slice to Triggered by Event 0.</li>
<li>Set the Event 0 Edge Selection of the Revolution Counter CCU4 slice to Signal Active on Falling Edge.</li>
<li>Set the Event 0 Level Selection of the Revolution Counter CCU4 slice to Active on the High Level.</li>
</ul>
</li>
<li>Revolution Counter (optional) - set the slice to be in Counter mode, which ticks based on the Position Counter period match (Falling edge of ST signal).</li>
<li>Time Between Ticks - the slice to measure time between ticks for the angle extrapolation.</li>
<li>Time Stamp Trigger - the slice to generate a trigger at the time stamp point when the angle extrapolation is required.<ul>
<li>Connect the Status Signal of the Time Stamp Trigger CCU4 slice to the Position Counter and Revolution Counter CCU4 slices Event 2 Input Signal, and the Time Between Ticks CCU4 slice Event 1 Input Signal.</li>
<li>Set the Capture 0 Function of the Position Counter and Revolution Counter CCU4 slices to Triggered by Event 2 and set the Capture 1 Function for the Time Between Ticks CCU4 slice to Triggered by Event 1.</li>
<li>Set the Event 2 Edge Selection of the Position Counter and Revolution Counter as well as Event 1 Edge Selection of the Time Between Ticks CCU4 slices to Signal Active on Falling Edge.</li>
<li>Set the Event 2 Level Selection of the Position Counter and Revolution Counter as well as Event 1 Level Selection of the Time Between Ticks CCU4 slices to Active on High Level.</li>
</ul>
</li>
</ol>
<p>The POSIF module and its interconnection with CCU4 are depicted in the following diagram: </p><div class="image">
<img src="posif_encoder_structure.png" alt="posif_encoder_structure.png"/>
</div>
<h2><a class="anchor" id="subsection_personality_posif_hsm"></a>
Hall Sensor Mode</h2>
<p>Hall Sensor mode is used to find the position and speed of the motor using 2 or 3 hall sensors. The POSIF personality in Hall Sensor mode uses two CCU4 slices - one to add a phase delay and one to capture the time between two correct hall patterns.</p>
<p>The personality supports 3 hall sensors and 2 hall sensors in the following use cases:</p><ol type="1">
<li>Find the speed and position for the PMSM motor: In this use case, the speed and position of the PMSM motor is obtained based on the hall sensor input. It is used in the PMSM motor control, which drives the inverter as per SVM algorithm.</li>
<li>Find the speed and position for the BLDC motor: In this use case, the speed and position of the BLDC motor is obtained based on the hall sensor input. It is used in the BLDC motor control, which drives the inverter as per multi-channel pattern sequence.</li>
</ol>
<p>Refer to the API reference <a class="el" href="group___p_o_s_i_f.html">Position Interface Unit (POSIF)</a> for the API details.</p>
<p>Refer to the device Datasheet and Reference Manual for the HW details.</p>
<h1><a class="anchor" id="section_personality_wdt"></a>
WDT Personality</h1>
<p>The Window boundaries configuration: </p><div class="image">
<img src="wdt_window.png" alt="wdt_window.png"/>
</div>
 <div class="image">
<img src="wdt_window_cfg.png" alt="wdt_window_cfg.png"/>
</div>
<p>The Pre-Warning Alarm interrupt configuration: </p><div class="image">
<img src="wdt_prewarn.png" alt="wdt_prewarn.png"/>
</div>
 <div class="image">
<img src="wdt_prewarn_cfg.png" alt="wdt_prewarn_cfg.png"/>
</div>
<h2><a class="anchor" id="subsection_wdt_codeGen"></a>
Code Generation</h2>
<p>The configurator performs the [name]_EventHandler registration in the generated code, so declare it in the application code, for example for the xmc4xxx devices: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> NMI_Handler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___s_c_u.html#ga9ba1ce317ce89edfea107893fbd8a0be">XMC_SCU_IRQHandler</a>((uint32_t)SCU_0_IRQn);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyWDT_EventHandler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___w_d_t.html#ga5ce909e8a079938c30259381a993d316">XMC_WDT_Service</a>();</div><div class="line">}</div></div><!-- fragment --><p>and then start the block itself (the rest of configurations are performed in the generated code): </p><div class="fragment"><div class="line">    <a class="code" href="group___w_d_t.html#gad01935f7e01dcc6697efe642d64e0053">XMC_WDT_Start</a>();</div></div><!-- fragment --><p> Refer to the API reference <a class="el" href="group___w_d_t.html">Watchdog driver (WDT)</a> for the API details.</p>
<p>Refer to the device Datasheet and Reference Manual for HW details. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>XMC Peripheral Library for XMC4000 Family</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
